(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function(Z,ka){"object"===typeof exports&&"undefined"!==typeof module?module.exports=ka():"function"===typeof define&&define.amd?define(ka):Z.createREGL=ka()})(this,function(){function Z(a,b){this.id=Db++;this.type=a;this.data=b}function ka(a){if(0===a.length)return[];var b=a.charAt(0),c=a.charAt(a.length-1);if(1<a.length&&b===c&&('"'===b||"'"===b))return['"'+a.substr(1,a.length-2).replace(/\\/g,"\\\\").replace(/"/g,'\\"')+'"'];if(b=/\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(a))return ka(a.substr(0,
b.index)).concat(ka(b[1])).concat(ka(a.substr(b.index+b[0].length)));b=a.split(".");if(1===b.length)return['"'+a.replace(/\\/g,"\\\\").replace(/"/g,'\\"')+'"'];a=[];for(c=0;c<b.length;++c)a=a.concat(ka(b[c]));return a}function cb(a){return"["+ka(a).join("][")+"]"}function db(a,b){if("function"===typeof a)return new Z(0,a);if("number"===typeof a||"boolean"===typeof a)return new Z(5,a);if(Array.isArray(a))return new Z(6,a.map(function(a,e){return db(a,b+"["+e+"]")}));if(a instanceof Z)return a}function Eb(){var a=
{"":0},b=[""];return{id:function(c){var e=a[c];if(e)return e;e=a[c]=b.length;b.push(c);return e},str:function(a){return b[a]}}}function Fb(a,b,c){function e(){var b=window.innerWidth,e=window.innerHeight;a!==document.body&&(e=f.getBoundingClientRect(),b=e.right-e.left,e=e.bottom-e.top);f.width=c*b;f.height=c*e}var f=document.createElement("canvas");L(f.style,{border:0,margin:0,padding:0,top:0,left:0,width:"100%",height:"100%"});a.appendChild(f);a===document.body&&(f.style.position="absolute",L(a.style,
{margin:0,padding:0}));var d;a!==document.body&&"function"===typeof ResizeObserver?(d=new ResizeObserver(function(){setTimeout(e)}),d.observe(a)):window.addEventListener("resize",e,!1);e();return{canvas:f,onDestroy:function(){d?d.disconnect():window.removeEventListener("resize",e);a.removeChild(f)}}}function Gb(a,b){function c(c){try{return a.getContext(c,b)}catch(f){return null}}return c("webgl")||c("experimental-webgl")||c("webgl-experimental")}function eb(a){return"string"===typeof a?a.split():
a}function fb(a){return"string"===typeof a?document.querySelector(a):a}function Hb(a){var b=a||{},c,e,f,d;a={};var q=[],n=[],v="undefined"===typeof window?1:window.devicePixelRatio,k=!1,u=function(a){},m=function(){};"string"===typeof b?c=document.querySelector(b):"object"===typeof b&&("string"===typeof b.nodeName&&"function"===typeof b.appendChild&&"function"===typeof b.getBoundingClientRect?c=b:"function"===typeof b.drawArrays||"function"===typeof b.drawElements?(d=b,f=d.canvas):("gl"in b?d=b.gl:
"canvas"in b?f=fb(b.canvas):"container"in b&&(e=fb(b.container)),"attributes"in b&&(a=b.attributes),"extensions"in b&&(q=eb(b.extensions)),"optionalExtensions"in b&&(n=eb(b.optionalExtensions)),"onDone"in b&&(u=b.onDone),"profile"in b&&(k=!!b.profile),"pixelRatio"in b&&(v=+b.pixelRatio)));c&&("canvas"===c.nodeName.toLowerCase()?f=c:e=c);if(!d){if(!f){c=Fb(e||document.body,u,v);if(!c)return null;f=c.canvas;m=c.onDestroy}void 0===a.premultipliedAlpha&&(a.premultipliedAlpha=!0);d=Gb(f,a)}return d?{gl:d,
canvas:f,container:e,extensions:q,optionalExtensions:n,pixelRatio:v,profile:k,onDone:u,onDestroy:m}:(m(),u("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org"),null)}function Ib(a,b){function c(b){b=b.toLowerCase();var c;try{c=e[b]=a.getExtension(b)}catch(f){}return!!c}for(var e={},f=0;f<b.extensions.length;++f){var d=b.extensions[f];if(!c(d))return b.onDestroy(),b.onDone('"'+d+'" extension is not supported by the current WebGL context, try upgrading your system or a different browser'),
null}b.optionalExtensions.forEach(c);return{extensions:e,restore:function(){Object.keys(e).forEach(function(a){if(e[a]&&!c(a))throw Error("(regl): error restoring extension "+a);})}}}function R(a,b){for(var c=Array(a),e=0;e<a;++e)c[e]=b(e);return c}function gb(a){var b,c;b=(65535<a)<<4;a>>>=b;c=(255<a)<<3;a>>>=c;b|=c;c=(15<a)<<2;a>>>=c;b|=c;c=(3<a)<<1;return b|c|a>>>c>>1}function hb(){function a(a){a:{for(var b=16;268435456>=b;b*=16)if(a<=b){a=b;break a}a=0}b=c[gb(a)>>2];return 0<b.length?b.pop():
new ArrayBuffer(a)}function b(a){c[gb(a.byteLength)>>2].push(a)}var c=R(8,function(){return[]});return{alloc:a,free:b,allocType:function(b,c){var d=null;switch(b){case 5120:d=new Int8Array(a(c),0,c);break;case 5121:d=new Uint8Array(a(c),0,c);break;case 5122:d=new Int16Array(a(2*c),0,c);break;case 5123:d=new Uint16Array(a(2*c),0,c);break;case 5124:d=new Int32Array(a(4*c),0,c);break;case 5125:d=new Uint32Array(a(4*c),0,c);break;case 5126:d=new Float32Array(a(4*c),0,c);break;default:return null}return d.length!==
c?d.subarray(0,c):d},freeType:function(a){b(a.buffer)}}}function la(a){return!!a&&"object"===typeof a&&Array.isArray(a.shape)&&Array.isArray(a.stride)&&"number"===typeof a.offset&&a.shape.length===a.stride.length&&(Array.isArray(a.data)||O(a.data))}function ib(a,b,c,e,f,d){for(var q=0;q<b;++q)for(var n=a[q],v=0;v<c;++v)for(var k=n[v],u=0;u<e;++u)f[d++]=k[u]}function jb(a,b,c,e,f){for(var d=1,q=c+1;q<b.length;++q)d*=b[q];var n=b[c];if(4===b.length-c){var v=b[c+1],k=b[c+2];b=b[c+3];for(q=0;q<n;++q)ib(a[q],
v,k,b,e,f),f+=d}else for(q=0;q<n;++q)jb(a[q],b,c+1,e,f),f+=d}function Ha(a){return Ia[Object.prototype.toString.call(a)]|0}function kb(a,b){for(var c=0;c<b.length;++c)a[c]=b[c]}function lb(a,b,c,e,f,d,q){for(var n=0,v=0;v<c;++v)for(var k=0;k<e;++k)a[n++]=b[f*v+d*k+q]}function Jb(a,b,c,e){function f(b){this.id=v++;this.buffer=a.createBuffer();this.type=b;this.usage=35044;this.byteLength=0;this.dimension=1;this.dtype=5121;this.persistentData=null;c.profile&&(this.stats={size:0})}function d(b,c,l){b.byteLength=
c.byteLength;a.bufferData(b.type,c,l)}function q(a,b,c,g,h,r){a.usage=c;if(Array.isArray(b)){if(a.dtype=g||5126,0<b.length)if(Array.isArray(b[0])){h=mb(b);for(var p=g=1;p<h.length;++p)g*=h[p];a.dimension=g;b=Ua(b,h,a.dtype);d(a,b,c);r?a.persistentData=b:G.freeType(b)}else"number"===typeof b[0]?(a.dimension=h,h=G.allocType(a.dtype,b.length),kb(h,b),d(a,h,c),r?a.persistentData=h:G.freeType(h)):O(b[0])&&(a.dimension=b[0].length,a.dtype=g||Ha(b[0])||5126,b=Ua(b,[b.length,b[0].length],a.dtype),d(a,b,c),
r?a.persistentData=b:G.freeType(b))}else if(O(b))a.dtype=g||Ha(b),a.dimension=h,d(a,b,c),r&&(a.persistentData=new Uint8Array(new Uint8Array(b.buffer)));else if(la(b)){h=b.shape;var e=b.stride,p=b.offset,t=0,ma=0,f=0,k=0;1===h.length?(t=h[0],ma=1,f=e[0],k=0):2===h.length&&(t=h[0],ma=h[1],f=e[0],k=e[1]);a.dtype=g||Ha(b.data)||5126;a.dimension=ma;h=G.allocType(a.dtype,t*ma);lb(h,b.data,t,ma,f,k,p);d(a,h,c);r?a.persistentData=h:G.freeType(h)}else b instanceof ArrayBuffer&&(a.dtype=5121,a.dimension=h,
d(a,b,c),r&&(a.persistentData=new Uint8Array(new Uint8Array(b))))}function n(c){b.bufferCount--;e(c);a.deleteBuffer(c.buffer);c.buffer=null;delete k[c.id]}var v=0,k={};f.prototype.bind=function(){a.bindBuffer(this.type,this.buffer)};f.prototype.destroy=function(){n(this)};var u=[];c.profile&&(b.getTotalBufferSize=function(){var a=0;Object.keys(k).forEach(function(b){a+=k[b].stats.size});return a});return{create:function(m,e,d,g){function h(b){var e=35044,t=null,d=0,m=0,f=1;Array.isArray(b)||O(b)||
la(b)||b instanceof ArrayBuffer?t=b:"number"===typeof b?d=b|0:b&&("data"in b&&(t=b.data),"usage"in b&&(e=nb[b.usage]),"type"in b&&(m=Ja[b.type]),"dimension"in b&&(f=b.dimension|0),"length"in b&&(d=b.length|0));r.bind();t?q(r,t,e,m,f,g):(d&&a.bufferData(r.type,d,e),r.dtype=m||5121,r.usage=e,r.dimension=f,r.byteLength=d);c.profile&&(r.stats.size=r.byteLength*na[r.dtype]);return h}b.bufferCount++;var r=new f(e);k[r.id]=r;d||h(m);h._reglType="buffer";h._buffer=r;h.subdata=function(b,c){var t=(c||0)|0,
d;r.bind();if(O(b)||b instanceof ArrayBuffer)a.bufferSubData(r.type,t,b);else if(Array.isArray(b)){if(0<b.length)if("number"===typeof b[0]){var e=G.allocType(r.dtype,b.length);kb(e,b);a.bufferSubData(r.type,t,e);G.freeType(e)}else if(Array.isArray(b[0])||O(b[0]))d=mb(b),e=Ua(b,d,r.dtype),a.bufferSubData(r.type,t,e),G.freeType(e)}else if(la(b)){d=b.shape;var m=b.stride,g=e=0,f=0,y=0;1===d.length?(e=d[0],g=1,f=m[0],y=0):2===d.length&&(e=d[0],g=d[1],f=m[0],y=m[1]);d=Array.isArray(b.data)?r.dtype:Ha(b.data);
d=G.allocType(d,e*g);lb(d,b.data,e,g,f,y,b.offset);a.bufferSubData(r.type,t,d);G.freeType(d)}return h};c.profile&&(h.stats=r.stats);h.destroy=function(){n(r)};return h},createStream:function(a,b){var c=u.pop();c||(c=new f(a));c.bind();q(c,b,35040,0,1,!1);return c},destroyStream:function(a){u.push(a)},clear:function(){I(k).forEach(n);u.forEach(n)},getBuffer:function(a){return a&&a._buffer instanceof f?a._buffer:null},restore:function(){I(k).forEach(function(b){b.buffer=a.createBuffer();a.bindBuffer(b.type,
b.buffer);a.bufferData(b.type,b.persistentData||b.byteLength,b.usage)})},_initBuffer:q}}function Kb(a,b,c,e){function f(a){this.id=v++;n[this.id]=this;this.buffer=a;this.primType=4;this.type=this.vertCount=0}function d(d,e,f,g,h,r,p){d.buffer.bind();var k;e?((k=p)||O(e)&&(!la(e)||O(e.data))||(k=b.oes_element_index_uint?5125:5123),c._initBuffer(d.buffer,e,f,k,3)):(a.bufferData(34963,r,f),d.buffer.dtype=k||5121,d.buffer.usage=f,d.buffer.dimension=3,d.buffer.byteLength=r);k=p;if(!p){switch(d.buffer.dtype){case 5121:case 5120:k=
5121;break;case 5123:case 5122:k=5123;break;case 5125:case 5124:k=5125}d.buffer.dtype=k}d.type=k;e=h;0>e&&(e=d.buffer.byteLength,5123===k?e>>=1:5125===k&&(e>>=2));d.vertCount=e;e=g;0>g&&(e=4,g=d.buffer.dimension,1===g&&(e=0),2===g&&(e=1),3===g&&(e=4));d.primType=e}function q(a){e.elementsCount--;delete n[a.id];a.buffer.destroy();a.buffer=null}var n={},v=0,k={uint8:5121,uint16:5123};b.oes_element_index_uint&&(k.uint32=5125);f.prototype.bind=function(){this.buffer.bind()};var u=[];return{create:function(a,
b){function l(a){if(a)if("number"===typeof a)g(a),h.primType=4,h.vertCount=a|0,h.type=5121;else{var b=null,c=35044,e=-1,f=-1,m=0,n=0;if(Array.isArray(a)||O(a)||la(a))b=a;else if("data"in a&&(b=a.data),"usage"in a&&(c=nb[a.usage]),"primitive"in a&&(e=Ka[a.primitive]),"count"in a&&(f=a.count|0),"type"in a&&(n=k[a.type]),"length"in a)m=a.length|0;else if(m=f,5123===n||5122===n)m*=2;else if(5125===n||5124===n)m*=4;d(h,b,c,e,f,m,n)}else g(),h.primType=4,h.vertCount=0,h.type=5121;return l}var g=c.create(null,
34963,!0),h=new f(g._buffer);e.elementsCount++;l(a);l._reglType="elements";l._elements=h;l.subdata=function(a,b){g.subdata(a,b);return l};l.destroy=function(){q(h)};return l},createStream:function(a){var b=u.pop();b||(b=new f(c.create(null,34963,!0,!1)._buffer));d(b,a,35040,-1,-1,0,0);return b},destroyStream:function(a){u.push(a)},getElements:function(a){return"function"===typeof a&&a._elements instanceof f?a._elements:null},clear:function(){I(n).forEach(q)}}}function ob(a){for(var b=G.allocType(5123,
a.length),c=0;c<a.length;++c)if(isNaN(a[c]))b[c]=65535;else if(Infinity===a[c])b[c]=31744;else if(-Infinity===a[c])b[c]=64512;else{pb[0]=a[c];var e=Lb[0],f=e>>>31<<15,d=(e<<1>>>24)-127,e=e>>13&1023;b[c]=-24>d?f:-14>d?f+(e+1024>>-14-d):15<d?f+31744:f+(d+15<<10)+e}return b}function ra(a){return Array.isArray(a)||O(a)}function sa(a){return"[object "+a+"]"}function qb(a){return Array.isArray(a)&&(0===a.length||"number"===typeof a[0])}function rb(a){return Array.isArray(a)&&0!==a.length&&ra(a[0])?!0:!1}
function aa(a){return Object.prototype.toString.call(a)}function Va(a){if(!a)return!1;var b=aa(a);return 0<=Mb.indexOf(b)?!0:qb(a)||rb(a)||la(a)}function sb(a,b){36193===a.type?(a.data=ob(b),G.freeType(b)):a.data=b}function La(a,b,c,e,f,d){a="undefined"!==typeof C[a]?C[a]:U[a]*za[b];d&&(a*=6);if(f){for(e=0;1<=c;)e+=a*c*c,c/=2;return e}return a*c*e}function Nb(a,b,c,e,f,d,q){function n(){this.format=this.internalformat=6408;this.type=5121;this.flipY=this.premultiplyAlpha=this.compressed=!1;this.unpackAlignment=
1;this.colorSpace=37444;this.channels=this.height=this.width=0}function v(a,b){a.internalformat=b.internalformat;a.format=b.format;a.type=b.type;a.compressed=b.compressed;a.premultiplyAlpha=b.premultiplyAlpha;a.flipY=b.flipY;a.unpackAlignment=b.unpackAlignment;a.colorSpace=b.colorSpace;a.width=b.width;a.height=b.height;a.channels=b.channels}function k(a,b){if("object"===typeof b&&b){"premultiplyAlpha"in b&&(a.premultiplyAlpha=b.premultiplyAlpha);"flipY"in b&&(a.flipY=b.flipY);"alignment"in b&&(a.unpackAlignment=
b.alignment);"colorSpace"in b&&(a.colorSpace=Ob[b.colorSpace]);"type"in b&&(a.type=N[b.type]);var c=a.width,e=a.height,d=a.channels,f=!1;"shape"in b?(c=b.shape[0],e=b.shape[1],3===b.shape.length&&(d=b.shape[2],f=!0)):("radius"in b&&(c=e=b.radius),"width"in b&&(c=b.width),"height"in b&&(e=b.height),"channels"in b&&(d=b.channels,f=!0));a.width=c|0;a.height=e|0;a.channels=d|0;c=!1;"format"in b&&(c=b.format,e=a.internalformat=E[c],a.format=V[e],c in N&&!("type"in b)&&(a.type=N[c]),c in ga&&(a.compressed=
!0),c=!0);!f&&c?a.channels=U[a.format]:f&&!c&&a.channels!==Oa[a.format]&&(a.format=a.internalformat=Oa[a.channels])}}function u(b){a.pixelStorei(37440,b.flipY);a.pixelStorei(37441,b.premultiplyAlpha);a.pixelStorei(37443,b.colorSpace);a.pixelStorei(3317,b.unpackAlignment)}function m(){n.call(this);this.yOffset=this.xOffset=0;this.data=null;this.needsFree=!1;this.element=null;this.needsCopy=!1}function x(a,b){var c=null;Va(b)?c=b:b&&(k(a,b),"x"in b&&(a.xOffset=b.x|0),"y"in b&&(a.yOffset=b.y|0),Va(b.data)&&
(c=b.data));if(b.copy){var e=f.viewportWidth,d=f.viewportHeight;a.width=a.width||e-a.xOffset;a.height=a.height||d-a.yOffset;a.needsCopy=!0}else if(!c)a.width=a.width||1,a.height=a.height||1,a.channels=a.channels||4;else if(O(c))a.channels=a.channels||4,a.data=c,"type"in b||5121!==a.type||(a.type=Ia[Object.prototype.toString.call(c)]|0);else if(qb(c)){a.channels=a.channels||4;e=c;d=e.length;switch(a.type){case 5121:case 5123:case 5125:case 5126:d=G.allocType(a.type,d);d.set(e);a.data=d;break;case 36193:a.data=
ob(e)}a.alignment=1;a.needsFree=!0}else if(la(c)){e=c.data;Array.isArray(e)||5121!==a.type||(a.type=Ia[Object.prototype.toString.call(e)]|0);var d=c.shape,h=c.stride,y,t,g,p;3===d.length?(g=d[2],p=h[2]):p=g=1;y=d[0];t=d[1];d=h[0];h=h[1];a.alignment=1;a.width=y;a.height=t;a.channels=g;a.format=a.internalformat=Oa[g];a.needsFree=!0;y=p;c=c.offset;g=a.width;p=a.height;t=a.channels;for(var z=G.allocType(36193===a.type?5126:a.type,g*p*t),B=0,ha=0;ha<p;++ha)for(var oa=0;oa<g;++oa)for(var Wa=0;Wa<t;++Wa)z[B++]=
e[d*oa+h*ha+y*Wa+c];sb(a,z)}else if(aa(c)===Xa||aa(c)===Ya||aa(c)===ub)aa(c)===Xa||aa(c)===Ya?a.element=c:a.element=c.canvas,a.width=a.element.width,a.height=a.element.height,a.channels=4;else if(aa(c)===vb)a.element=c,a.width=c.width,a.height=c.height,a.channels=4;else if(aa(c)===wb)a.element=c,a.width=c.naturalWidth,a.height=c.naturalHeight,a.channels=4;else if(aa(c)===xb)a.element=c,a.width=c.videoWidth,a.height=c.videoHeight,a.channels=4;else if(rb(c)){e=a.width||c[0].length;d=a.height||c.length;
h=a.channels;h=ra(c[0][0])?h||c[0][0].length:h||1;y=Qa.shape(c);g=1;for(p=0;p<y.length;++p)g*=y[p];g=G.allocType(36193===a.type?5126:a.type,g);Qa.flatten(c,y,"",g);sb(a,g);a.alignment=1;a.width=e;a.height=d;a.channels=h;a.format=a.internalformat=Oa[h];a.needsFree=!0}}function l(b,c,d,h,g){var y=b.element,f=b.data,p=b.internalformat,t=b.format,k=b.type,z=b.width,B=b.height;u(b);y?a.texSubImage2D(c,g,d,h,t,k,y):b.compressed?a.compressedTexSubImage2D(c,g,d,h,p,z,B,f):b.needsCopy?(e(),a.copyTexSubImage2D(c,
g,d,h,b.xOffset,b.yOffset,z,B)):a.texSubImage2D(c,g,d,h,z,B,t,k,f)}function g(){return R.pop()||new m}function h(a){a.needsFree&&G.freeType(a.data);m.call(a);R.push(a)}function r(){n.call(this);this.genMipmaps=!1;this.mipmapHint=4352;this.mipmask=0;this.images=Array(16)}function p(a,b,c){var d=a.images[0]=g();a.mipmask=1;d.width=a.width=b;d.height=a.height=c;d.channels=a.channels=4}function P(a,b){var c=null;if(Va(b))c=a.images[0]=g(),v(c,a),x(c,b),a.mipmask=1;else if(k(a,b),Array.isArray(b.mipmap))for(var d=
b.mipmap,e=0;e<d.length;++e)c=a.images[e]=g(),v(c,a),c.width>>=e,c.height>>=e,x(c,d[e]),a.mipmask|=1<<e;else c=a.images[0]=g(),v(c,a),x(c,b),a.mipmask=1;v(a,a.images[0])}function t(b,c){for(var d=b.images,h=0;h<d.length&&d[h];++h){var g=d[h],y=c,f=h,p=g.element,t=g.data,k=g.internalformat,z=g.format,B=g.type,ha=g.width,oa=g.height;u(g);p?a.texImage2D(y,f,z,z,B,p):g.compressed?a.compressedTexImage2D(y,f,k,ha,oa,0,t):g.needsCopy?(e(),a.copyTexImage2D(y,f,z,g.xOffset,g.yOffset,ha,oa,0)):a.texImage2D(y,
f,z,ha,oa,0,z,B,t||null)}}function ma(){var a=Y.pop()||new r;n.call(a);for(var b=a.mipmask=0;16>b;++b)a.images[b]=null;return a}function ya(a){for(var b=a.images,c=0;c<b.length;++c)b[c]&&h(b[c]),b[c]=null;Y.push(a)}function w(){this.magFilter=this.minFilter=9728;this.wrapT=this.wrapS=33071;this.anisotropic=1;this.genMipmaps=!1;this.mipmapHint=4352}function H(a,b){"min"in b&&(a.minFilter=Aa[b.min],0<=Pb.indexOf(a.minFilter)&&!("faces"in b)&&(a.genMipmaps=!0));"mag"in b&&(a.magFilter=S[b.mag]);var c=
a.wrapS,d=a.wrapT;if("wrap"in b){var e=b.wrap;"string"===typeof e?c=d=ia[e]:Array.isArray(e)&&(c=ia[e[0]],d=ia[e[1]])}else"wrapS"in b&&(c=ia[b.wrapS]),"wrapT"in b&&(d=ia[b.wrapT]);a.wrapS=c;a.wrapT=d;"anisotropic"in b&&(a.anisotropic=b.anisotropic);if("mipmap"in b){c=!1;switch(typeof b.mipmap){case "string":a.mipmapHint=A[b.mipmap];c=a.genMipmaps=!0;break;case "boolean":c=a.genMipmaps=b.mipmap;break;case "object":a.genMipmaps=!1,c=!0}!c||"min"in b||(a.minFilter=9984)}}function M(c,d){a.texParameteri(d,
10241,c.minFilter);a.texParameteri(d,10240,c.magFilter);a.texParameteri(d,10242,c.wrapS);a.texParameteri(d,10243,c.wrapT);b.ext_texture_filter_anisotropic&&a.texParameteri(d,34046,c.anisotropic);c.genMipmaps&&(a.hint(33170,c.mipmapHint),a.generateMipmap(d))}function y(b){n.call(this);this.mipmask=0;this.internalformat=6408;this.id=Qb++;this.refCount=1;this.target=b;this.texture=a.createTexture();this.unit=-1;this.bindCount=0;this.texInfo=new w;q.profile&&(this.stats={size:0})}function T(b){a.activeTexture(33984);
a.bindTexture(b.target,b.texture)}function wa(){var b=W[0];b?a.bindTexture(b.target,b.texture):a.bindTexture(3553,null)}function F(b){var c=b.texture,e=b.unit,g=b.target;0<=e&&(a.activeTexture(33984+e),a.bindTexture(g,null),W[e]=null);a.deleteTexture(c);b.texture=null;b.params=null;b.pixels=null;b.refCount=0;delete ea[b.id];d.textureCount--}var A={"don't care":4352,"dont care":4352,nice:4354,fast:4353},ia={repeat:10497,clamp:33071,mirror:33648},S={nearest:9728,linear:9729},Aa=L({mipmap:9987,"nearest mipmap nearest":9984,
"linear mipmap nearest":9985,"nearest mipmap linear":9986,"linear mipmap linear":9987},S),Ob={none:0,browser:37444},N={uint8:5121,rgba4:32819,rgb565:33635,"rgb5 a1":32820},E={alpha:6406,luminance:6409,"luminance alpha":6410,rgb:6407,rgba:6408,rgba4:32854,"rgb5 a1":32855,rgb565:36194},ga={};b.ext_srgb&&(E.srgb=35904,E.srgba=35906);b.oes_texture_float&&(N.float32=N["float"]=5126);b.oes_texture_half_float&&(N.float16=N["half float"]=36193);b.webgl_depth_texture&&(L(E,{depth:6402,"depth stencil":34041}),
L(N,{uint16:5123,uint32:5125,"depth stencil":34042}));b.webgl_compressed_texture_s3tc&&L(ga,{"rgb s3tc dxt1":33776,"rgba s3tc dxt1":33777,"rgba s3tc dxt3":33778,"rgba s3tc dxt5":33779});b.webgl_compressed_texture_atc&&L(ga,{"rgb atc":35986,"rgba atc explicit alpha":35987,"rgba atc interpolated alpha":34798});b.webgl_compressed_texture_pvrtc&&L(ga,{"rgb pvrtc 4bppv1":35840,"rgb pvrtc 2bppv1":35841,"rgba pvrtc 4bppv1":35842,"rgba pvrtc 2bppv1":35843});b.webgl_compressed_texture_etc1&&(ga["rgb etc1"]=
36196);var J=Array.prototype.slice.call(a.getParameter(34467));Object.keys(ga).forEach(function(a){var b=ga[a];0<=J.indexOf(b)&&(E[a]=b)});var C=Object.keys(E);c.textureFormats=C;var ca=[];Object.keys(E).forEach(function(a){ca[E[a]]=a});var K=[];Object.keys(N).forEach(function(a){K[N[a]]=a});var Fa=[];Object.keys(S).forEach(function(a){Fa[S[a]]=a});var pa=[];Object.keys(Aa).forEach(function(a){pa[Aa[a]]=a});var qa=[];Object.keys(ia).forEach(function(a){qa[ia[a]]=a});var V=C.reduce(function(a,c){var d=
E[c];6409===d||6406===d||6409===d||6410===d||6402===d||34041===d||b.ext_srgb&&(35904===d||35906===d)?a[d]=d:32855===d||0<=c.indexOf("rgba")?a[d]=6408:a[d]=6407;return a},{}),R=[],Y=[],Qb=0,ea={},fa=c.maxTextureUnits,W=Array(fa).map(function(){return null});L(y.prototype,{bind:function(){this.bindCount+=1;var b=this.unit;if(0>b){for(var c=0;c<fa;++c){var e=W[c];if(e){if(0<e.bindCount)continue;e.unit=-1}W[c]=this;b=c;break}q.profile&&d.maxTextureUnits<b+1&&(d.maxTextureUnits=b+1);this.unit=b;a.activeTexture(33984+
b);a.bindTexture(this.target,this.texture)}return b},unbind:function(){--this.bindCount},decRef:function(){0>=--this.refCount&&F(this)}});q.profile&&(d.getTotalTextureSize=function(){var a=0;Object.keys(ea).forEach(function(b){a+=ea[b].stats.size});return a});return{create2D:function(b,c){function e(a,b){var c=f.texInfo;w.call(c);var d=ma();"number"===typeof a?"number"===typeof b?p(d,a|0,b|0):p(d,a|0,a|0):a?(H(c,a),P(d,a)):p(d,1,1);c.genMipmaps&&(d.mipmask=(d.width<<1)-1);f.mipmask=d.mipmask;v(f,
d);f.internalformat=d.internalformat;e.width=d.width;e.height=d.height;T(f);t(d,3553);M(c,3553);wa();ya(d);q.profile&&(f.stats.size=La(f.internalformat,f.type,d.width,d.height,c.genMipmaps,!1));e.format=ca[f.internalformat];e.type=K[f.type];e.mag=Fa[c.magFilter];e.min=pa[c.minFilter];e.wrapS=qa[c.wrapS];e.wrapT=qa[c.wrapT];return e}var f=new y(3553);ea[f.id]=f;d.textureCount++;e(b,c);e.subimage=function(a,b,c,d){b|=0;c|=0;d|=0;var y=g();v(y,f);y.width=0;y.height=0;x(y,a);y.width=y.width||(f.width>>
d)-b;y.height=y.height||(f.height>>d)-c;T(f);l(y,3553,b,c,d);wa();h(y);return e};e.resize=function(b,c){var d=b|0,g=c|0||d;if(d===f.width&&g===f.height)return e;e.width=f.width=d;e.height=f.height=g;T(f);for(var y=0;f.mipmask>>y;++y){var h=d>>y,z=g>>y;if(!h||!z)break;a.texImage2D(3553,y,f.format,h,z,0,f.format,f.type,null)}wa();q.profile&&(f.stats.size=La(f.internalformat,f.type,d,g,!1,!1));return e};e._reglType="texture2d";e._texture=f;q.profile&&(e.stats=f.stats);e.destroy=function(){f.decRef()};
return e},createCube:function(b,c,e,f,n,r){function m(a,b,c,d,e,f){var g,da=A.texInfo;w.call(da);for(g=0;6>g;++g)F[g]=ma();if("number"===typeof a||!a)for(a=a|0||1,g=0;6>g;++g)p(F[g],a,a);else if("object"===typeof a)if(b)P(F[0],a),P(F[1],b),P(F[2],c),P(F[3],d),P(F[4],e),P(F[5],f);else if(H(da,a),k(A,a),"faces"in a)for(a=a.faces,g=0;6>g;++g)v(F[g],A),P(F[g],a[g]);else for(g=0;6>g;++g)P(F[g],a);v(A,F[0]);A.mipmask=da.genMipmaps?(F[0].width<<1)-1:F[0].mipmask;A.internalformat=F[0].internalformat;m.width=
F[0].width;m.height=F[0].height;T(A);for(g=0;6>g;++g)t(F[g],34069+g);M(da,34067);wa();q.profile&&(A.stats.size=La(A.internalformat,A.type,m.width,m.height,da.genMipmaps,!0));m.format=ca[A.internalformat];m.type=K[A.type];m.mag=Fa[da.magFilter];m.min=pa[da.minFilter];m.wrapS=qa[da.wrapS];m.wrapT=qa[da.wrapT];for(g=0;6>g;++g)ya(F[g]);return m}var A=new y(34067);ea[A.id]=A;d.cubeCount++;var F=Array(6);m(b,c,e,f,n,r);m.subimage=function(a,b,c,d,e){c|=0;d|=0;e|=0;var f=g();v(f,A);f.width=0;f.height=0;
x(f,b);f.width=f.width||(A.width>>e)-c;f.height=f.height||(A.height>>e)-d;T(A);l(f,34069+a,c,d,e);wa();h(f);return m};m.resize=function(b){b|=0;if(b!==A.width){m.width=A.width=b;m.height=A.height=b;T(A);for(var c=0;6>c;++c)for(var d=0;A.mipmask>>d;++d)a.texImage2D(34069+c,d,A.format,b>>d,b>>d,0,A.format,A.type,null);wa();q.profile&&(A.stats.size=La(A.internalformat,A.type,m.width,m.height,!1,!0));return m}};m._reglType="textureCube";m._texture=A;q.profile&&(m.stats=A.stats);m.destroy=function(){A.decRef()};
return m},clear:function(){for(var b=0;b<fa;++b)a.activeTexture(33984+b),a.bindTexture(3553,null),W[b]=null;I(ea).forEach(F);d.cubeCount=0;d.textureCount=0},getTexture:function(a){return null},restore:function(){for(var b=0;b<fa;++b){var c=W[b];c&&(c.bindCount=0,c.unit=-1,W[b]=null)}I(ea).forEach(function(b){b.texture=a.createTexture();a.bindTexture(b.target,b.texture);for(var c=0;32>c;++c)if(0!==(b.mipmask&1<<c))if(3553===b.target)a.texImage2D(3553,c,b.internalformat,b.width>>c,b.height>>c,0,b.internalformat,
b.type,null);else for(var d=0;6>d;++d)a.texImage2D(34069+d,c,b.internalformat,b.width>>c,b.height>>c,0,b.internalformat,b.type,null);M(b.texInfo,b.target)})},refresh:function(){for(var b=0;b<fa;++b){var c=W[b];c&&(c.bindCount=0,c.unit=-1,W[b]=null);a.activeTexture(33984+b);a.bindTexture(3553,null);a.bindTexture(34067,null)}}}}function Rb(a,b,c,e,f,d){function q(a,b,c){this.target=a;this.texture=b;this.renderbuffer=c;var d=a=0;b?(a=b.width,d=b.height):c&&(a=c.width,d=c.height);this.width=a;this.height=
d}function n(a){a&&(a.texture&&a.texture._texture.decRef(),a.renderbuffer&&a.renderbuffer._renderbuffer.decRef())}function v(a,b,c){a&&(a.texture?a.texture._texture.refCount+=1:a.renderbuffer._renderbuffer.refCount+=1)}function k(b,c){c&&(c.texture?a.framebufferTexture2D(36160,b,c.target,c.texture._texture.texture,0):a.framebufferRenderbuffer(36160,b,36161,c.renderbuffer._renderbuffer.renderbuffer))}function u(a){var b=3553,c=null,d=null,e=a;"object"===typeof a&&(e=a.data,"target"in a&&(b=a.target|
0));a=e._reglType;"texture2d"===a?c=e:"textureCube"===a?c=e:"renderbuffer"===a&&(d=e,b=36161);return new q(b,c,d)}function m(a,b,c,d,g){if(c)return a=e.create2D({width:a,height:b,format:d,type:g}),a._texture.refCount=0,new q(3553,a,null);a=f.create({width:a,height:b,format:d});a._renderbuffer.refCount=0;return new q(36161,null,a)}function x(a){return a&&(a.texture||a.renderbuffer)}function l(a,b,c){a&&(a.texture?a.texture.resize(b,c):a.renderbuffer&&a.renderbuffer.resize(b,c),a.width=b,a.height=c)}
function g(){this.id=H++;M[this.id]=this;this.framebuffer=a.createFramebuffer();this.height=this.width=0;this.colorAttachments=[];this.depthStencilAttachment=this.stencilAttachment=this.depthAttachment=null}function h(a){a.colorAttachments.forEach(n);n(a.depthAttachment);n(a.stencilAttachment);n(a.depthStencilAttachment)}function r(b){a.deleteFramebuffer(b.framebuffer);b.framebuffer=null;d.framebufferCount--;delete M[b.id]}function p(b){var d;a.bindFramebuffer(36160,b.framebuffer);var e=b.colorAttachments;
for(d=0;d<e.length;++d)k(36064+d,e[d]);for(d=e.length;d<c.maxColorAttachments;++d)a.framebufferTexture2D(36160,36064+d,3553,null,0);a.framebufferTexture2D(36160,33306,3553,null,0);a.framebufferTexture2D(36160,36096,3553,null,0);a.framebufferTexture2D(36160,36128,3553,null,0);k(36096,b.depthAttachment);k(36128,b.stencilAttachment);k(33306,b.depthStencilAttachment);a.checkFramebufferStatus(36160);a.isContextLost();a.bindFramebuffer(36160,t.next?t.next.framebuffer:null);t.cur=t.next;a.getError()}function P(a,
b){function c(a,b){var d,g=0,f=0,t=!0,k=!0;d=null;var l=!0,n="rgba",r="uint8",y=1,q=null,P=null,pa=null,M=!1;if("number"===typeof a)g=a|0,f=b|0||g;else if(a){"shape"in a?(f=a.shape,g=f[0],f=f[1]):("radius"in a&&(g=f=a.radius),"width"in a&&(g=a.width),"height"in a&&(f=a.height));if("color"in a||"colors"in a)d=a.color||a.colors,Array.isArray(d);if(!d){"colorCount"in a&&(y=a.colorCount|0);"colorTexture"in a&&(l=!!a.colorTexture,n="rgba4");if("colorType"in a&&(r=a.colorType,!l))if("half float"===r||"float16"===
r)n="rgba16f";else if("float"===r||"float32"===r)n="rgba32f";"colorFormat"in a&&(n=a.colorFormat,0<=ma.indexOf(n)?l=!0:0<=ya.indexOf(n)&&(l=!1))}if("depthTexture"in a||"depthStencilTexture"in a)M=!(!a.depthTexture&&!a.depthStencilTexture);"depth"in a&&("boolean"===typeof a.depth?t=a.depth:(q=a.depth,k=!1));"stencil"in a&&("boolean"===typeof a.stencil?k=a.stencil:(P=a.stencil,t=!1));"depthStencil"in a&&("boolean"===typeof a.depthStencil?t=k=a.depthStencil:(pa=a.depthStencil,k=t=!1))}else g=f=1;var V=
null,H=null,T=null,w=null;if(Array.isArray(d))V=d.map(u);else if(d)V=[u(d)];else for(V=Array(y),d=0;d<y;++d)V[d]=m(g,f,l,n,r);g=g||V[0].width;f=f||V[0].height;q?H=u(q):t&&!k&&(H=m(g,f,M,"depth","uint32"));P?T=u(P):k&&!t&&(T=m(g,f,!1,"stencil","uint8"));pa?w=u(pa):!q&&!P&&k&&t&&(w=m(g,f,M,"depth stencil","depth stencil"));t=null;for(d=0;d<V.length;++d)v(V[d],g,f),V[d]&&V[d].texture&&(k=Za[V[d].texture._texture.format]*Ra[V[d].texture._texture.type],null===t&&(t=k));v(H,g,f);v(T,g,f);v(w,g,f);h(e);
e.width=g;e.height=f;e.colorAttachments=V;e.depthAttachment=H;e.stencilAttachment=T;e.depthStencilAttachment=w;c.color=V.map(x);c.depth=x(H);c.stencil=x(T);c.depthStencil=x(w);c.width=e.width;c.height=e.height;p(e);return c}var e=new g;d.framebufferCount++;c(a,b);return L(c,{resize:function(a,b){var d=Math.max(a|0,1),g=Math.max(b|0||d,1);if(d===e.width&&g===e.height)return c;for(var f=e.colorAttachments,h=0;h<f.length;++h)l(f[h],d,g);l(e.depthAttachment,d,g);l(e.stencilAttachment,d,g);l(e.depthStencilAttachment,
d,g);e.width=c.width=d;e.height=c.height=g;p(e);return c},_reglType:"framebuffer",_framebuffer:e,destroy:function(){r(e);h(e)},use:function(a){t.setFBO({framebuffer:c},a)}})}var t={cur:null,next:null,dirty:!1,setFBO:null},ma=["rgba"],ya=["rgba4","rgb565","rgb5 a1"];b.ext_srgb&&ya.push("srgba");b.ext_color_buffer_half_float&&ya.push("rgba16f","rgb16f");b.webgl_color_buffer_float&&ya.push("rgba32f");var w=["uint8"];b.oes_texture_half_float&&w.push("half float","float16");b.oes_texture_float&&w.push("float",
"float32");var H=0,M={};return L(t,{getFramebuffer:function(a){return"function"===typeof a&&"framebuffer"===a._reglType&&(a=a._framebuffer,a instanceof g)?a:null},create:P,createCube:function(a){function b(a){var d,g={color:null},f=0,h=null;d="rgba";var t="uint8",p=1;if("number"===typeof a)f=a|0;else if(a){"shape"in a?f=a.shape[0]:("radius"in a&&(f=a.radius|0),"width"in a?f=a.width|0:"height"in a&&(f=a.height|0));if("color"in a||"colors"in a)h=a.color||a.colors,Array.isArray(h);h||("colorCount"in
a&&(p=a.colorCount|0),"colorType"in a&&(t=a.colorType),"colorFormat"in a&&(d=a.colorFormat));"depth"in a&&(g.depth=a.depth);"stencil"in a&&(g.stencil=a.stencil);"depthStencil"in a&&(g.depthStencil=a.depthStencil)}else f=1;if(h)if(Array.isArray(h))for(a=[],d=0;d<h.length;++d)a[d]=h[d];else a=[h];else for(a=Array(p),h={radius:f,format:d,type:t},d=0;d<p;++d)a[d]=e.createCube(h);g.color=Array(a.length);for(d=0;d<a.length;++d)p=a[d],f=f||p.width,g.color[d]={target:34069,data:a[d]};for(d=0;6>d;++d){for(p=
0;p<a.length;++p)g.color[p].target=34069+d;0<d&&(g.depth=c[0].depth,g.stencil=c[0].stencil,g.depthStencil=c[0].depthStencil);if(c[d])c[d](g);else c[d]=P(g)}return L(b,{width:f,height:f,color:a})}var c=Array(6);b(a);return L(b,{faces:c,resize:function(a){var d=a|0;if(d===b.width)return b;var e=b.color;for(a=0;a<e.length;++a)e[a].resize(d);for(a=0;6>a;++a)c[a].resize(d);b.width=b.height=d;return b},_reglType:"framebufferCube",destroy:function(){c.forEach(function(a){a.destroy()})}})},clear:function(){I(M).forEach(r)},
restore:function(){t.cur=null;t.next=null;t.dirty=!0;I(M).forEach(function(b){b.framebuffer=a.createFramebuffer();p(b)})}})}function $a(){this.w=this.z=this.y=this.x=this.state=0;this.buffer=null;this.size=0;this.normalized=!1;this.type=5126;this.divisor=this.stride=this.offset=0}function Sb(a,b,c,e,f,d,q){function n(a){if(a!==r.currentVAO){var c=b.oes_vertex_array_object;a?c.bindVertexArrayOES(a.vao):c.bindVertexArrayOES(null);r.currentVAO=a}}function v(c){if(c!==r.currentVAO){if(c)c.bindAttrs();
else{for(var d=b.angle_instanced_arrays,e=0;e<l.length;++e){var g=l[e];g.buffer?(a.enableVertexAttribArray(e),g.buffer.bind(),a.vertexAttribPointer(e,g.size,g.type,g.normalized,g.stride,g.offfset),d&&g.divisor&&d.vertexAttribDivisorANGLE(e,g.divisor)):(a.disableVertexAttribArray(e),a.vertexAttrib4f(e,g.x,g.y,g.z,g.w))}q.elements?a.bindBuffer(34963,q.elements.buffer.buffer):a.bindBuffer(34963,null)}r.currentVAO=c}}function k(){I(h).forEach(function(a){a.destroy()})}function u(){this.id=++g;this.attributes=
[];this.elements=null;this.ownsElements=!1;this.offset=this.count=0;this.instances=-1;this.primitive=4;var a=b.oes_vertex_array_object;this.vao=a?a.createVertexArrayOES():null;h[this.id]=this;this.buffers=[]}function m(){b.oes_vertex_array_object&&I(h).forEach(function(a){a.refresh()})}var x=c.maxAttributes,l=Array(x);for(c=0;c<x;++c)l[c]=new $a;var g=0,h={},r={Record:$a,scope:{},state:l,currentVAO:null,targetVAO:null,restore:b.oes_vertex_array_object?m:function(){},createVAO:function(a){function b(a){var e;
Array.isArray(a)?(e=a,c.elements&&c.ownsElements&&c.elements.destroy(),c.elements=null,c.ownsElements=!1,c.offset=0,c.count=0,c.instances=-1,c.primitive=4):(a.elements?(e=a.elements,c.ownsElements?("function"===typeof e&&"elements"===e._reglType?c.elements.destroy():c.elements(e),c.ownsElements=!1):d.getElements(a.elements)?(c.elements=a.elements,c.ownsElements=!1):(c.elements=d.create(a.elements),c.ownsElements=!0)):(c.elements=null,c.ownsElements=!1),e=a.attributes,c.offset=0,c.count=-1,c.instances=
-1,c.primitive=4,c.elements&&(c.count=c.elements._elements.vertCount,c.primitive=c.elements._elements.primType),"offset"in a&&(c.offset=a.offset|0),"count"in a&&(c.count=a.count|0),"instances"in a&&(c.instances=a.instances|0),"primitive"in a&&(c.primitive=Ka[a.primitive]));a={};var g=c.attributes;g.length=e.length;for(var h=0;h<e.length;++h){var p=e[h],k=g[h]=new $a,m=p.data||p;if(Array.isArray(m)||O(m)||la(m)){var l;c.buffers[h]&&(l=c.buffers[h],O(m)&&l._buffer.byteLength>=m.byteLength?l.subdata(m):
(l.destroy(),c.buffers[h]=null));c.buffers[h]||(l=c.buffers[h]=f.create(p,34962,!1,!0));k.buffer=f.getBuffer(l);k.size=k.buffer.dimension|0;k.normalized=!1;k.type=k.buffer.dtype;k.offset=0;k.stride=0;k.divisor=0;k.state=1;a[h]=1}else f.getBuffer(p)?(k.buffer=f.getBuffer(p),k.size=k.buffer.dimension|0,k.normalized=!1,k.type=k.buffer.dtype,k.offset=0,k.stride=0,k.divisor=0,k.state=1):f.getBuffer(p.buffer)?(k.buffer=f.getBuffer(p.buffer),k.size=(+p.size||k.buffer.dimension)|0,k.normalized=!!p.normalized||
!1,k.type="type"in p?Ja[p.type]:k.buffer.dtype,k.offset=(p.offset||0)|0,k.stride=(p.stride||0)|0,k.divisor=(p.divisor||0)|0,k.state=1):"x"in p&&(k.x=+p.x||0,k.y=+p.y||0,k.z=+p.z||0,k.w=+p.w||0,k.state=2)}for(l=0;l<c.buffers.length;++l)!a[l]&&c.buffers[l]&&(c.buffers[l].destroy(),c.buffers[l]=null);c.refresh();return b}var c=new u;e.vaoCount+=1;b.destroy=function(){for(var a=0;a<c.buffers.length;++a)c.buffers[a]&&c.buffers[a].destroy();c.buffers.length=0;c.ownsElements&&(c.elements.destroy(),c.elements=
null,c.ownsElements=!1);c.destroy()};b._vao=c;b._reglType="vao";return b(a)},getVAO:function(a){return"function"===typeof a&&a._vao?a._vao:null},destroyBuffer:function(b){for(var c=0;c<l.length;++c){var d=l[c];d.buffer===b&&(a.disableVertexAttribArray(c),d.buffer=null)}},setVAO:b.oes_vertex_array_object?n:v,clear:b.oes_vertex_array_object?k:function(){}};u.prototype.bindAttrs=function(){for(var c=b.angle_instanced_arrays,e=this.attributes,g=0;g<e.length;++g){var f=e[g];f.buffer?(a.enableVertexAttribArray(g),
a.bindBuffer(34962,f.buffer.buffer),a.vertexAttribPointer(g,f.size,f.type,f.normalized,f.stride,f.offset),c&&f.divisor&&c.vertexAttribDivisorANGLE(g,f.divisor)):(a.disableVertexAttribArray(g),a.vertexAttrib4f(g,f.x,f.y,f.z,f.w))}for(c=e.length;c<x;++c)a.disableVertexAttribArray(c);(c=d.getElements(this.elements))?a.bindBuffer(34963,c.buffer.buffer):a.bindBuffer(34963,null)};u.prototype.refresh=function(){var a=b.oes_vertex_array_object;a&&(a.bindVertexArrayOES(this.vao),this.bindAttrs(),r.currentVAO=
null,a.bindVertexArrayOES(null))};u.prototype.destroy=function(){if(this.vao){var a=b.oes_vertex_array_object;this===r.currentVAO&&(r.currentVAO=null,a.bindVertexArrayOES(null));a.deleteVertexArrayOES(this.vao);this.vao=null}this.ownsElements&&(this.elements.destroy(),this.elements=null,this.ownsElements=!1);h[this.id]&&(delete h[this.id],--e.vaoCount)};return r}function Tb(a,b,c,e){function f(a,b,c,d){this.name=a;this.id=b;this.location=c;this.info=d}function d(a,b){for(var c=0;c<a.length;++c)if(a[c].id===
b.id){a[c].location=b.location;return}a.push(b)}function q(c,d,e){e=35632===c?k:u;var f=e[d];if(!f){var m=b.str(d),f=a.createShader(c);a.shaderSource(f,m);a.compileShader(f);e[d]=f}return f}function n(a,b){this.id=l++;this.fragId=a;this.vertId=b;this.program=null;this.uniforms=[];this.attributes=[];this.refCount=1;e.profile&&(this.stats={uniformsCount:0,attributesCount:0})}function v(c,h,k){var m;m=q(35632,c.fragId);var l=q(35633,c.vertId);h=c.program=a.createProgram();a.attachShader(h,m);a.attachShader(h,
l);if(k)for(m=0;m<k.length;++m)l=k[m],a.bindAttribLocation(h,l[0],l[1]);a.linkProgram(h);l=a.getProgramParameter(h,35718);e.profile&&(c.stats.uniformsCount=l);var n=c.uniforms;for(m=0;m<l;++m)if(k=a.getActiveUniform(h,m)){if(1<k.size)for(var v=0;v<k.size;++v){var u=k.name.replace("[0]","["+v+"]");d(n,new f(u,b.id(u),a.getUniformLocation(h,u),k))}v=k.name;1<k.size&&(v=v.replace("[0]",""));d(n,new f(v,b.id(v),a.getUniformLocation(h,v),k))}l=a.getProgramParameter(h,35721);e.profile&&(c.stats.attributesCount=
l);c=c.attributes;for(m=0;m<l;++m)(k=a.getActiveAttrib(h,m))&&d(c,new f(k.name,b.id(k.name),a.getAttribLocation(h,k.name),k))}var k={},u={},m={},x=[],l=0;e.profile&&(c.getMaxUniformsCount=function(){var a=0;x.forEach(function(b){b.stats.uniformsCount>a&&(a=b.stats.uniformsCount)});return a},c.getMaxAttributesCount=function(){var a=0;x.forEach(function(b){b.stats.attributesCount>a&&(a=b.stats.attributesCount)});return a});return{clear:function(){var b=a.deleteShader.bind(a);I(k).forEach(b);k={};I(u).forEach(b);
u={};x.forEach(function(b){a.deleteProgram(b.program)});x.length=0;m={};c.shaderCount=0},program:function(b,d,e,f){var l=m[d];l||(l=m[d]={});var q=l[b];if(q&&(q.refCount++,!f))return q;var w=new n(d,b);c.shaderCount++;v(w,e,f);q||(l[b]=w);x.push(w);return L(w,{destroy:function(){w.refCount--;if(0>=w.refCount){a.deleteProgram(w.program);var b=x.indexOf(w);x.splice(b,1);c.shaderCount--}0>=l[w.vertId].refCount&&(a.deleteShader(u[w.vertId]),delete u[w.vertId],delete m[w.fragId][w.vertId]);Object.keys(m[w.fragId]).length||
(a.deleteShader(k[w.fragId]),delete k[w.fragId],delete m[w.fragId])}})},restore:function(){k={};u={};for(var a=0;a<x.length;++a)v(x[a],null,x[a].attributes.map(function(a){return[a.location,a.name]}))},shader:q,frag:-1,vert:-1}}function Ub(a,b,c,e,f,d,q){function n(d){var f;f=null===b.next?5121:b.next.colorAttachments[0].texture._texture.type;var m=0,n=0,l=e.framebufferWidth,g=e.framebufferHeight,h=null;O(d)?h=d:d&&(m=d.x|0,n=d.y|0,l=(d.width||e.framebufferWidth-m)|0,g=(d.height||e.framebufferHeight-
n)|0,h=d.data||null);c();d=l*g*4;h||(5121===f?h=new Uint8Array(d):5126===f&&(h=h||new Float32Array(d)));a.pixelStorei(3333,4);a.readPixels(m,n,l,g,6408,f,h);return h}function v(a){var c;b.setFBO({framebuffer:a.framebuffer},function(){c=n(a)});return c}return function(a){return a&&"framebuffer"in a?v(a):n(a)}}function Ba(a){return Array.prototype.slice.call(a)}function Ca(a){return Ba(a).join("")}function Vb(){function a(){var a=[],b=[];return L(function(){a.push.apply(a,Ba(arguments))},{def:function(){var d=
"v"+c++;b.push(d);0<arguments.length&&(a.push(d,"="),a.push.apply(a,Ba(arguments)),a.push(";"));return d},toString:function(){return Ca([0<b.length?"var "+b.join(",")+";":"",Ca(a)])}})}function b(){function b(a,e){d(a,e,"=",c.def(a,e),";")}var c=a(),d=a(),e=c.toString,f=d.toString;return L(function(){c.apply(c,Ba(arguments))},{def:c.def,entry:c,exit:d,save:b,set:function(a,d,e){b(a,d);c(a,d,"=",e,";")},toString:function(){return e()+f()}})}var c=0,e=[],f=[],d=a(),q={};return{global:d,link:function(a){for(var b=
0;b<f.length;++b)if(f[b]===a)return e[b];b="g"+c++;e.push(b);f.push(a);return b},block:a,proc:function(a,c){function d(){var a="a"+e.length;e.push(a);return a}var e=[];c=c||0;for(var f=0;f<c;++f)d();var f=b(),x=f.toString;return q[a]=L(f,{arg:d,toString:function(){return Ca(["function(",e.join(),"){",x(),"}"])}})},scope:b,cond:function(){var a=Ca(arguments),c=b(),d=b(),e=c.toString,f=d.toString;return L(c,{then:function(){c.apply(c,Ba(arguments));return this},"else":function(){d.apply(d,Ba(arguments));
return this},toString:function(){var b=f();b&&(b="else{"+b+"}");return Ca(["if(",a,"){",e(),"}",b])}})},compile:function(){var a=['"use strict";',d,"return {"];Object.keys(q).forEach(function(b){a.push('"',b,'":',q[b].toString(),",")});a.push("}");var b=Ca(a).replace(/;/g,";\n").replace(/}/g,"}\n").replace(/{/g,"{\n");return Function.apply(null,e.concat(b)).apply(null,f)}}}function Sa(a){return Array.isArray(a)||O(a)||la(a)}function yb(a){return a.sort(function(a,c){return"viewport"===a?-1:"viewport"===
c?1:a<c?-1:1})}function J(a,b,c,e){this.thisDep=a;this.contextDep=b;this.propDep=c;this.append=e}function xa(a){return a&&!(a.thisDep||a.contextDep||a.propDep)}function w(a){return new J(!1,!1,!1,a)}function K(a,b){var c=a.type;if(0===c)return c=a.data.length,new J(!0,1<=c,2<=c,b);if(4===c)return c=a.data,new J(c.thisDep,c.contextDep,c.propDep,b);if(5===c)return new J(!1,!1,!1,b);if(6===c){for(var e=c=!1,f=!1,d=0;d<a.data.length;++d){var q=a.data[d];1===q.type?f=!0:2===q.type?e=!0:3===q.type?c=!0:
0===q.type?(c=!0,q=q.data,1<=q&&(e=!0),2<=q&&(f=!0)):4===q.type&&(c=c||q.data.thisDep,e=e||q.data.contextDep,f=f||q.data.propDep)}return new J(c,e,f,b)}return new J(3===c,2===c,1===c,b)}function Wb(a,b,c,e,f,d,q,n,v,k,u,m,x,l,g){function h(a){return a.replace(".","_")}function r(a,b,c){var d=h(a);Na.push(a);Ea[d]=ta[d]=!!c;ua[d]=b}function p(a,b,c){var d=h(a);Na.push(a);Array.isArray(c)?(ta[d]=c.slice(),Ea[d]=c.slice()):ta[d]=Ea[d]=c;va[d]=b}function P(){var a=Vb(),c=a.link,d=a.global;a.id=sa++;a.batchId=
"0";var e=c(tb),f=a.shared={props:"a0"};Object.keys(tb).forEach(function(a){f[a]=d.def(e,".",a)});var g=a.next={},da=a.current={};Object.keys(va).forEach(function(a){Array.isArray(ta[a])&&(g[a]=d.def(f.next,".",a),da[a]=d.def(f.current,".",a))});var D=a.constants={};Object.keys(Pa).forEach(function(a){D[a]=d.def(JSON.stringify(Pa[a]))});a.invoke=function(b,d){switch(d.type){case 0:var e=["this",f.context,f.props,a.batchId];return b.def(c(d.data),".call(",e.slice(0,Math.max(d.data.length+1,4)),")");
case 1:return b.def(f.props,d.data);case 2:return b.def(f.context,d.data);case 3:return b.def("this",d.data);case 4:return d.data.append(a,b),d.data.ref;case 5:return d.data.toString();case 6:return d.data.map(function(c){return a.invoke(b,c)})}};a.attribCache={};var ba={};a.scopeAttrib=function(a){a=b.id(a);if(a in ba)return ba[a];var d=k.scope[a];d||(d=k.scope[a]=new ea);return ba[a]=c(d)};return a}function t(a){var b=a["static"];a=a.dynamic;var c;if("profile"in b){var d=!!b.profile;c=w(function(a,
b){return d});c.enable=d}else if("profile"in a){var e=a.profile;c=K(e,function(a,b){return a.invoke(b,e)})}return c}function G(a,b){var c=a["static"],d=a.dynamic;if("framebuffer"in c){var e=c.framebuffer;return e?(e=n.getFramebuffer(e),w(function(a,b){var c=a.link(e),d=a.shared;b.set(d.framebuffer,".next",c);d=d.context;b.set(d,".framebufferWidth",c+".width");b.set(d,".framebufferHeight",c+".height");return c})):w(function(a,b){var c=a.shared;b.set(c.framebuffer,".next","null");c=c.context;b.set(c,
".framebufferWidth",c+".drawingBufferWidth");b.set(c,".framebufferHeight",c+".drawingBufferHeight");return"null"})}if("framebuffer"in d){var f=d.framebuffer;return K(f,function(a,b){var c=a.invoke(b,f),d=a.shared,e=d.framebuffer,c=b.def(e,".getFramebuffer(",c,")");b.set(e,".next",c);d=d.context;b.set(d,".framebufferWidth",c+"?"+c+".width:"+d+".drawingBufferWidth");b.set(d,".framebufferHeight",c+"?"+c+".height:"+d+".drawingBufferHeight");return c})}return null}function C(a,b,c){function d(a){if(a in
e){var c=e[a];a=!0;var z=c.x|0,g=c.y|0,h,da;"width"in c?h=c.width|0:a=!1;"height"in c?da=c.height|0:a=!1;return new J(!a&&b&&b.thisDep,!a&&b&&b.contextDep,!a&&b&&b.propDep,function(a,b){var d=a.shared.context,e=h;"width"in c||(e=b.def(d,".","framebufferWidth","-",z));var f=da;"height"in c||(f=b.def(d,".","framebufferHeight","-",g));return[z,g,e,f]})}if(a in f){var ha=f[a];a=K(ha,function(a,b){var c=a.invoke(b,ha),d=a.shared.context,e=b.def(c,".x|0"),f=b.def(c,".y|0"),z=b.def('"width" in ',c,"?",c,
".width|0:","(",d,".","framebufferWidth","-",e,")"),c=b.def('"height" in ',c,"?",c,".height|0:","(",d,".","framebufferHeight","-",f,")");return[e,f,z,c]});b&&(a.thisDep=a.thisDep||b.thisDep,a.contextDep=a.contextDep||b.contextDep,a.propDep=a.propDep||b.propDep);return a}return b?new J(b.thisDep,b.contextDep,b.propDep,function(a,b){var c=a.shared.context;return[0,0,b.def(c,".","framebufferWidth"),b.def(c,".","framebufferHeight")]}):null}var e=a["static"],f=a.dynamic;if(a=d("viewport")){var g=a;a=new J(a.thisDep,
a.contextDep,a.propDep,function(a,b){var c=g.append(a,b),d=a.shared.context;b.set(d,".viewportWidth",c[2]);b.set(d,".viewportHeight",c[3]);return c})}return{viewport:a,scissor_box:d("scissor.box")}}function O(a,b){var c=a["static"];if("string"===typeof c.frag&&"string"===typeof c.vert){if(0<Object.keys(b.dynamic).length)return null;var c=b["static"],d=Object.keys(c);if(0<d.length&&"number"===typeof c[d[0]]){for(var e=[],f=0;f<d.length;++f)e.push([c[d[f]]|0,d[f]]);return e}}return null}function H(a,
c,d){function e(a){if(a in f){var c=b.id(f[a]);a=w(function(){return c});a.id=c;return a}if(a in g){var d=g[a];return K(d,function(a,b){var c=a.invoke(b,d);return b.def(a.shared.strings,".id(",c,")")})}return null}var f=a["static"],g=a.dynamic,h=e("frag"),D=e("vert"),ba=null;xa(h)&&xa(D)?(ba=u.program(D.id,h.id,null,d),a=w(function(a,b){return a.link(ba)})):a=new J(h&&h.thisDep||D&&D.thisDep,h&&h.contextDep||D&&D.contextDep,h&&h.propDep||D&&D.propDep,function(a,b){var c=a.shared.shader,d;d=h?h.append(a,
b):b.def(c,".","frag");var e;e=D?D.append(a,b):b.def(c,".","vert");return b.def(c+".program("+e+","+d+")")});return{frag:h,vert:D,progVar:a,program:ba}}function M(a,b){function c(a,b){if(a in e){var d=e[a]|0;b?g.offset=d:g.instances=d;return w(function(a,c){b&&(a.OFFSET=d);return d})}if(a in f){var z=f[a];return K(z,function(a,c){var d=a.invoke(c,z);b&&(a.OFFSET=d);return d})}if(b){if(ba)return w(function(a,b){return a.OFFSET=0});if(h)return new J(D.thisDep,D.contextDep,D.propDep,function(a,b){return b.def(a.shared.vao+
".currentVAO?"+a.shared.vao+".currentVAO.offset:0")})}else if(h)return new J(D.thisDep,D.contextDep,D.propDep,function(a,b){return b.def(a.shared.vao+".currentVAO?"+a.shared.vao+".currentVAO.instances:-1")});return null}var e=a["static"],f=a.dynamic,g={},h=!1,D=function(){if("vao"in e){var a=e.vao;null!==a&&null===k.getVAO(a)&&(a=k.createVAO(a));h=!0;g.vao=a;return w(function(b){var c=k.getVAO(a);return c?b.link(c):"null"})}if("vao"in f){h=!0;var b=f.vao;return K(b,function(a,c){var d=a.invoke(c,
b);return c.def(a.shared.vao+".getVAO("+d+")")})}return null}(),ba=!1,X=function(){if("elements"in e){var a=e.elements;g.elements=a;if(Sa(a)){var b=g.elements=d.create(a,!0),a=d.getElements(b);ba=!0}else a&&(a=d.getElements(a),ba=!0);b=w(function(b,c){if(a){var d=b.link(a);return b.ELEMENTS=d}return b.ELEMENTS=null});b.value=a;return b}if("elements"in f){ba=!0;var c=f.elements;return K(c,function(a,b){var d=a.shared,e=d.isBufferArgs,d=d.elements,f=a.invoke(b,c),z=b.def("null"),e=b.def(e,"(",f,")"),
f=a.cond(e).then(z,"=",d,".createStream(",f,");")["else"](z,"=",d,".getElements(",f,");");b.entry(f);b.exit(a.cond(e).then(d,".destroyStream(",z,");"));return a.ELEMENTS=z})}return h?new J(D.thisDep,D.contextDep,D.propDep,function(a,b){return b.def(a.shared.vao+".currentVAO?"+a.shared.elements+".getElements("+a.shared.vao+".currentVAO.elements):null")}):null}(),ja=c("offset",!0),m=function(){if("primitive"in e){var a=e.primitive;g.primitive=a;return w(function(b,c){return Ka[a]})}if("primitive"in
f){var b=f.primitive;return K(b,function(a,c){var d=a.constants.primTypes,e=a.invoke(c,b);return c.def(d,"[",e,"]")})}return ba?xa(X)?X.value?w(function(a,b){return b.def(a.ELEMENTS,".primType")}):w(function(){return 4}):new J(X.thisDep,X.contextDep,X.propDep,function(a,b){var c=a.ELEMENTS;return b.def(c,"?",c,".primType:",4)}):h?new J(D.thisDep,D.contextDep,D.propDep,function(a,b){return b.def(a.shared.vao+".currentVAO?"+a.shared.vao+".currentVAO.primitive:4")}):null}(),l=function(){if("count"in
e){var a=e.count|0;g.count=a;return w(function(){return a})}if("count"in f){var b=f.count;return K(b,function(a,c){return a.invoke(c,b)})}return ba?xa(X)?X?ja?new J(ja.thisDep,ja.contextDep,ja.propDep,function(a,b){return b.def(a.ELEMENTS,".vertCount-",a.OFFSET)}):w(function(a,b){return b.def(a.ELEMENTS,".vertCount")}):w(function(){return-1}):new J(X.thisDep||ja.thisDep,X.contextDep||ja.contextDep,X.propDep||ja.propDep,function(a,b){var c=a.ELEMENTS;return a.OFFSET?b.def(c,"?",c,".vertCount-",a.OFFSET,
":-1"):b.def(c,"?",c,".vertCount:-1")}):h?new J(D.thisDep,D.contextDep,D.propDep,function(a,b){return b.def(a.shared.vao,".currentVAO?",a.shared.vao,".currentVAO.count:-1")}):null}(),p=c("instances",!1);return{elements:X,primitive:m,count:l,instances:p,offset:ja,vao:D,vaoActive:h,elementsActive:ba,"static":g}}function y(a,b){var c=a["static"],d=a.dynamic,e={};Na.forEach(function(a){function b(z,g){if(a in c){var B=z(c[a]);e[f]=w(function(){return B})}else if(a in d){var h=d[a];e[f]=K(h,function(a,
b){return g(a,b,a.invoke(b,h))})}}var f=h(a);switch(a){case "cull.enable":case "blend.enable":case "dither":case "stencil.enable":case "depth.enable":case "scissor.enable":case "polygonOffset.enable":case "sample.alpha":case "sample.enable":case "depth.mask":return b(function(a){return a},function(a,b,c){return c});case "depth.func":return b(function(a){return ab[a]},function(a,b,c){return b.def(a.constants.compareFuncs,"[",c,"]")});case "depth.range":return b(function(a){return a},function(a,b,c){a=
b.def("+",c,"[0]");b=b.def("+",c,"[1]");return[a,b]});case "blend.func":return b(function(a){return[Ga["srcRGB"in a?a.srcRGB:a.src],Ga["dstRGB"in a?a.dstRGB:a.dst],Ga["srcAlpha"in a?a.srcAlpha:a.src],Ga["dstAlpha"in a?a.dstAlpha:a.dst]]},function(a,b,c){function d(a,e){return b.def('"',a,e,'" in ',c,"?",c,".",a,e,":",c,".",a)}a=a.constants.blendFuncs;var e=d("src","RGB"),f=d("dst","RGB"),e=b.def(a,"[",e,"]"),z=b.def(a,"[",d("src","Alpha"),"]"),f=b.def(a,"[",f,"]");a=b.def(a,"[",d("dst","Alpha"),"]");
return[e,f,z,a]});case "blend.equation":return b(function(a){if("string"===typeof a)return[fa[a],fa[a]];if("object"===typeof a)return[fa[a.rgb],fa[a.alpha]]},function(a,b,c){var d=a.constants.blendEquations,e=b.def(),f=b.def();a=a.cond("typeof ",c,'==="string"');a.then(e,"=",f,"=",d,"[",c,"];");a["else"](e,"=",d,"[",c,".rgb];",f,"=",d,"[",c,".alpha];");b(a);return[e,f]});case "blend.color":return b(function(a){return R(4,function(b){return+a[b]})},function(a,b,c){return R(4,function(a){return b.def("+",
c,"[",a,"]")})});case "stencil.mask":return b(function(a){return a|0},function(a,b,c){return b.def(c,"|0")});case "stencil.func":return b(function(a){return[ab[a.cmp||"keep"],a.ref||0,"mask"in a?a.mask:-1]},function(a,b,c){a=b.def('"cmp" in ',c,"?",a.constants.compareFuncs,"[",c,".cmp]",":",7680);var d=b.def(c,".ref|0");b=b.def('"mask" in ',c,"?",c,".mask|0:-1");return[a,d,b]});case "stencil.opFront":case "stencil.opBack":return b(function(b){return["stencil.opBack"===a?1029:1028,Ta[b.fail||"keep"],
Ta[b.zfail||"keep"],Ta[b.zpass||"keep"]]},function(b,c,d){function e(a){return c.def('"',a,'" in ',d,"?",f,"[",d,".",a,"]:",7680)}var f=b.constants.stencilOps;return["stencil.opBack"===a?1029:1028,e("fail"),e("zfail"),e("zpass")]});case "polygonOffset.offset":return b(function(a){return[a.factor|0,a.units|0]},function(a,b,c){a=b.def(c,".factor|0");b=b.def(c,".units|0");return[a,b]});case "cull.face":return b(function(a){var b=0;"front"===a?b=1028:"back"===a&&(b=1029);return b},function(a,b,c){return b.def(c,
'==="front"?',1028,":",1029)});case "lineWidth":return b(function(a){return a},function(a,b,c){return c});case "frontFace":return b(function(a){return zb[a]},function(a,b,c){return b.def(c+'==="cw"?2304:2305')});case "colorMask":return b(function(a){return a.map(function(a){return!!a})},function(a,b,c){return R(4,function(a){return"!!"+c+"["+a+"]"})});case "sample.coverage":return b(function(a){return["value"in a?a.value:1,!!a.invert]},function(a,b,c){a=b.def('"value" in ',c,"?+",c,".value:1");b=
b.def("!!",c,".invert");return[a,b]})}});return e}function T(a,b){var c=a["static"],d=a.dynamic,e={};Object.keys(c).forEach(function(a){var b=c[a],d;if("number"===typeof b||"boolean"===typeof b)d=w(function(){return b});else if("function"===typeof b){var f=b._reglType;if("texture2d"===f||"textureCube"===f)d=w(function(a){return a.link(b)});else if("framebuffer"===f||"framebufferCube"===f)d=w(function(a){return a.link(b.color[0])})}else ra(b)&&(d=w(function(a){return a.global.def("[",R(b.length,function(a){return b[a]}),
"]")}));d.value=b;e[a]=d});Object.keys(d).forEach(function(a){var b=d[a];e[a]=K(b,function(a,c){return a.invoke(c,b)})});return e}function wa(a,c){var d=a["static"],e=a.dynamic,g={};Object.keys(d).forEach(function(a){var c=d[a],e=b.id(a),z=new ea;if(Sa(c))z.state=1,z.buffer=f.getBuffer(f.create(c,34962,!1,!0)),z.type=0;else{var B=f.getBuffer(c);if(B)z.state=1,z.buffer=B,z.type=0;else if("constant"in c){var h=c.constant;z.buffer="null";z.state=2;"number"===typeof h?z.x=h:Da.forEach(function(a,b){b<
h.length&&(z[a]=h[b])})}else{var B=Sa(c.buffer)?f.getBuffer(f.create(c.buffer,34962,!1,!0)):f.getBuffer(c.buffer),k=c.offset|0,m=c.stride|0,l=c.size|0,oa=!!c.normalized,p=0;"type"in c&&(p=Ja[c.type]);c=c.divisor|0;z.buffer=B;z.state=1;z.size=l;z.normalized=oa;z.type=p||B.dtype;z.offset=k;z.stride=m;z.divisor=c}}g[a]=w(function(a,b){var c=a.attribCache;if(e in c)return c[e];var d={isStream:!1};Object.keys(z).forEach(function(a){d[a]=z[a]});z.buffer&&(d.buffer=a.link(z.buffer),d.type=d.type||d.buffer+
".dtype");return c[e]=d})});Object.keys(e).forEach(function(a){var b=e[a];g[a]=K(b,function(a,c){function d(a){c(B[a],"=",e,".",a,"|0;")}var e=a.invoke(c,b),f=a.shared,z=a.constants,g=f.isBufferArgs,f=f.buffer,B={isStream:c.def(!1)},h=new ea;h.state=1;Object.keys(h).forEach(function(a){B[a]=c.def(""+h[a])});var k=B.buffer,m=B.type;c("if(",g,"(",e,")){",B.isStream,"=true;",k,"=",f,".createStream(",34962,",",e,");",m,"=",k,".dtype;","}else{",k,"=",f,".getBuffer(",e,");","if(",k,"){",m,"=",k,".dtype;",
'}else if("constant" in ',e,"){",B.state,"=",2,";","if(typeof "+e+'.constant === "number"){',B[Da[0]],"=",e,".constant;",Da.slice(1).map(function(a){return B[a]}).join("="),"=0;","}else{",Da.map(function(a,b){return B[a]+"="+e+".constant.length>"+b+"?"+e+".constant["+b+"]:0;"}).join(""),"}}else{","if(",g,"(",e,".buffer)){",k,"=",f,".createStream(",34962,",",e,".buffer);","}else{",k,"=",f,".getBuffer(",e,".buffer);","}",m,'="type" in ',e,"?",z.glTypes,"[",e,".type]:",k,".dtype;",B.normalized,"=!!",
e,".normalized;");d("size");d("offset");d("stride");d("divisor");c("}}");c.exit("if(",B.isStream,"){",f,".destroyStream(",k,");","}");return B})});return g}function F(a){var b=a["static"],c=a.dynamic,d={};Object.keys(b).forEach(function(a){var c=b[a];d[a]=w(function(a,b){return"number"===typeof c||"boolean"===typeof c?""+c:a.link(c)})});Object.keys(c).forEach(function(a){var b=c[a];d[a]=K(b,function(a,c){return a.invoke(c,b)})});return d}function A(a,b,d,e,f){function g(a){var b=p[a];b&&(ja[a]=b)}
var m=O(a,b),l=G(a,f),p=C(a,l,f),X=M(a,f),ja=y(a,f),q=H(a,f,m);g("viewport");g(h("scissor.box"));var n=0<Object.keys(ja).length,l={framebuffer:l,draw:X,shader:q,state:ja,dirty:n,scopeVAO:null,drawVAO:null,useVAO:!1,attributes:{}};l.profile=t(a,f);l.uniforms=T(d,f);l.drawVAO=l.scopeVAO=X.vao;if(!l.drawVAO&&q.program&&!m&&c.angle_instanced_arrays&&X["static"].elements){var r=!0;a=q.program.attributes.map(function(a){a=b["static"][a];r=r&&!!a;return a});if(r&&0<a.length){var u=k.getVAO(k.createVAO({attributes:a,
elements:X["static"].elements}));l.drawVAO=new J(null,null,null,function(a,b){return a.link(u)});l.useVAO=!0}}m?l.useVAO=!0:l.attributes=wa(b,f);l.context=F(e,f);return l}function ia(a,b,c){var d=a.shared.context,e=a.scope();Object.keys(c).forEach(function(f){b.save(d,"."+f);var g=c[f].append(a,b);Array.isArray(g)?e(d,".",f,"=[",g.join(),"];"):e(d,".",f,"=",g,";")});b(e)}function S(a,b,c,d){var e=a.shared,f=e.gl,g=e.framebuffer,h;Ma&&(h=b.def(e.extensions,".webgl_draw_buffers"));var k=a.constants,
e=k.drawBuffer,k=k.backBuffer;a=c?c.append(a,b):b.def(g,".next");d||b("if(",a,"!==",g,".cur){");b("if(",a,"){",f,".bindFramebuffer(",36160,",",a,".framebuffer);");Ma&&b(h,".drawBuffersWEBGL(",e,"[",a,".colorAttachments.length]);");b("}else{",f,".bindFramebuffer(",36160,",null);");Ma&&b(h,".drawBuffersWEBGL(",k,");");b("}",g,".cur=",a,";");d||b("}")}function Aa(a,b,c){var d=a.shared,e=d.gl,f=a.current,g=a.next,k=d.current,l=d.next,m=a.cond(k,".dirty");Na.forEach(function(b){b=h(b);if(!(b in c.state)){var d,
B;if(b in g){d=g[b];B=f[b];var p=R(ta[b].length,function(a){return m.def(d,"[",a,"]")});m(a.cond(p.map(function(a,b){return a+"!=="+B+"["+b+"]"}).join("||")).then(e,".",va[b],"(",p,");",p.map(function(a,b){return B+"["+b+"]="+a}).join(";"),";"))}else d=m.def(l,".",b),p=a.cond(d,"!==",k,".",b),m(p),b in ua?p(a.cond(d).then(e,".enable(",ua[b],");")["else"](e,".disable(",ua[b],");"),k,".",b,"=",d,";"):p(e,".",va[b],"(",d,");",k,".",b,"=",d,";")}});0===Object.keys(c.state).length&&m(k,".dirty=false;");
b(m)}function I(a,b,c,d){var e=a.shared,f=a.current,g=e.current,h=e.gl;yb(Object.keys(c)).forEach(function(e){var k=c[e];if(!d||d(k)){var m=k.append(a,b);if(ua[e]){var l=ua[e];xa(k)?m?b(h,".enable(",l,");"):b(h,".disable(",l,");"):b(a.cond(m).then(h,".enable(",l,");")["else"](h,".disable(",l,");"));b(g,".",e,"=",m,";")}else if(ra(m)){var p=f[e];b(h,".",va[e],"(",m,");",m.map(function(a,b){return p+"["+b+"]="+a}).join(";"),";")}else b(h,".",va[e],"(",m,");",g,".",e,"=",m,";")}})}function N(a,b){W&&
(a.instancing=b.def(a.shared.extensions,".angle_instanced_arrays"))}function E(a,b,c,d,e){function f(){return"undefined"===typeof performance?"Date.now()":"performance.now()"}function g(a){r=b.def();a(r,"=",f(),";");"string"===typeof e?a(p,".count+=",e,";"):a(p,".count++;");l&&(d?(u=b.def(),a(u,"=",n,".getNumPendingQueries();")):a(n,".beginQuery(",p,");"))}function h(a){a(p,".cpuTime+=",f(),"-",r,";");l&&(d?a(n,".pushScopeStats(",u,",",n,".getNumPendingQueries(),",p,");"):a(n,".endQuery();"))}function k(a){var c=
b.def(q,".profile");b(q,".profile=",a,";");b.exit(q,".profile=",c,";")}var m=a.shared,p=a.stats,q=m.current,n=m.timer;c=c.profile;var r,u;if(c){if(xa(c)){c.enable?(g(b),h(b.exit),k("true")):k("false");return}c=c.append(a,b);k(c)}else c=b.def(q,".profile");m=a.block();g(m);b("if(",c,"){",m,"}");a=a.block();h(a);b.exit("if(",c,"){",a,"}")}function ga(a,b,c,d,e){function f(a){switch(a){case 35664:case 35667:case 35671:return 2;case 35665:case 35668:case 35672:return 3;case 35666:case 35669:case 35673:return 4;
default:return 1}}function g(c,d,e){function f(){b("if(!",p,".buffer){",m,".enableVertexAttribArray(",l,");}");var c=e.type,g;g=e.size?b.def(e.size,"||",d):d;b("if(",p,".type!==",c,"||",p,".size!==",g,"||",n.map(function(a){return p+"."+a+"!=="+e[a]}).join("||"),"){",m,".bindBuffer(",34962,",",ha,".buffer);",m,".vertexAttribPointer(",[l,g,c,e.normalized,e.stride,e.offset],");",p,".type=",c,";",p,".size=",g,";",n.map(function(a){return p+"."+a+"="+e[a]+";"}).join(""),"}");W&&(c=e.divisor,b("if(",p,
".divisor!==",c,"){",a.instancing,".vertexAttribDivisorANGLE(",[l,c],");",p,".divisor=",c,";}"))}function k(){b("if(",p,".buffer){",m,".disableVertexAttribArray(",l,");",p,".buffer=null;","}if(",Da.map(function(a,b){return p+"."+a+"!=="+q[b]}).join("||"),"){",m,".vertexAttrib4f(",l,",",q,");",Da.map(function(a,b){return p+"."+a+"="+q[b]+";"}).join(""),"}")}var m=h.gl,l=b.def(c,".location"),p=b.def(h.attributes,"[",l,"]");c=e.state;var ha=e.buffer,q=[e.x,e.y,e.z,e.w],n=["buffer","normalized","offset",
"stride"];1===c?f():2===c?k():(b("if(",c,"===",1,"){"),f(),b("}else{"),k(),b("}"))}var h=a.shared;d.forEach(function(d){var h=d.name,k=c.attributes[h],m;if(k){if(!e(k))return;m=k.append(a,b)}else{if(!e(Ab))return;var l=a.scopeAttrib(h);m={};Object.keys(new ea).forEach(function(a){m[a]=b.def(l,".",a)})}g(a.link(d),f(d.info.type),m)})}function Q(a,c,d,e,f,g){for(var h=a.shared,k=h.gl,m={},l,p=0;p<e.length;++p){var q=e[p],n=q.name,r=q.info.type,u=q.info.size,t=d.uniforms[n];if(1<u){if(!t)continue;var v=
n.replace("[0]","");if(m[v])continue;m[v]=1}var q=a.link(q)+".location",x;if(t){if(!f(t))continue;if(xa(t)){n=t.value;if(35678===r||35680===r)r=a.link(n._texture||n.color[0]._texture),c(k,".uniform1i(",q,",",r+".bind());"),c.exit(r,".unbind();");else if(35674===r||35675===r||35676===r)u=a.global.def("new Float32Array(["+Array.prototype.slice.call(n)+"])"),n=2,35675===r?n=3:35676===r&&(n=4),c(k,".uniformMatrix",n,"fv(",q,",false,",u,");");else{switch(r){case 5126:l="1f";break;case 35664:l="2f";break;
case 35665:l="3f";break;case 35666:l="4f";break;case 35670:l="1i";break;case 5124:l="1i";break;case 35671:l="2i";break;case 35667:l="2i";break;case 35672:l="3i";break;case 35668:l="3i";break;case 35673:l="4i";break;case 35669:l="4i"}1<u?(l+="v",n=a.global.def("["+Array.prototype.slice.call(n)+"]")):n=ra(n)?Array.prototype.slice.call(n):n;c(k,".uniform",l,"(",q,",",n,");")}continue}else x=t.append(a,c)}else{if(!f(Ab))continue;x=c.def(h.uniforms,"[",b.id(n),"]")}35678===r?c("if(",x,"&&",x,'._reglType==="framebuffer"){',
x,"=",x,".color[0];","}"):35680===r&&c("if(",x,"&&",x,'._reglType==="framebufferCube"){',x,"=",x,".color[0];","}");n=1;switch(r){case 35678:case 35680:r=c.def(x,"._texture");c(k,".uniform1i(",q,",",r,".bind());");c.exit(r,".unbind();");continue;case 5124:case 35670:l="1i";break;case 35667:case 35671:l="2i";n=2;break;case 35668:case 35672:l="3i";n=3;break;case 35669:case 35673:l="4i";n=4;break;case 5126:l="1f";break;case 35664:l="2f";n=2;break;case 35665:l="3f";n=3;break;case 35666:l="4f";n=4;break;
case 35674:l="Matrix2fv";break;case 35675:l="Matrix3fv";break;case 35676:l="Matrix4fv"}-1===l.indexOf("Matrix")&&1<u&&(l+="v",n=1);if("M"===l.charAt(0)){c(k,".uniform",l,"(",q,",");var q=Math.pow(r-35674+2,2),y=a.global.def("new Float32Array(",q,")");Array.isArray(x)?c("false,(",R(q,function(a){return y+"["+a+"]="+x[a]}),",",y,")"):c("false,(Array.isArray(",x,")||",x," instanceof Float32Array)?",x,":(",R(q,function(a){return y+"["+a+"]="+x+"["+a+"]"}),",",y,")");c(");")}else{if(1<n){for(var r=[],
w=[],u=0;u<n;++u)Array.isArray(x)?w.push(x[u]):w.push(c.def(x+"["+u+"]")),g&&r.push(c.def());g&&c("if(!",a.batchId,"||",r.map(function(a,b){return a+"!=="+w[b]}).join("||"),"){",r.map(function(a,b){return a+"="+w[b]+";"}).join(""));c(k,".uniform",l,"(",q,",",w.join(","),");")}else g&&(r=c.def(),c("if(!",a.batchId,"||",r,"!==",x,"){",r,"=",x,";")),c(k,".uniform",l,"(",q,",",x,");");g&&c("}")}}}function U(a,b,c,d){function e(f){var g=m[f];return g?g.contextDep&&d.contextDynamic||g.propDep?g.append(a,
c):g.append(a,b):b.def(k,".",f)}function f(){function a(){c(t,".drawElementsInstancedANGLE(",[n,r,x,q+"<<(("+x+"-5121)>>1)",u],");")}function b(){c(t,".drawArraysInstancedANGLE(",[n,q,r,u],");")}p&&"null"!==p?v?a():(c("if(",p,"){"),a(),c("}else{"),b(),c("}")):b()}function g(){function a(){c(l+".drawElements("+[n,r,x,q+"<<(("+x+"-5121)>>1)"]+");")}function b(){c(l+".drawArrays("+[n,q,r]+");")}p&&"null"!==p?v?a():(c("if(",p,"){"),a(),c("}else{"),b(),c("}")):b()}var h=a.shared,l=h.gl,k=h.draw,m=d.draw,
p=function(){var e=m.elements,f=b;if(e){if(e.contextDep&&d.contextDynamic||e.propDep)f=c;e=e.append(a,f);m.elementsActive&&f("if("+e+")"+l+".bindBuffer(34963,"+e+".buffer.buffer);")}else e=f.def(),f(e,"=",k,".","elements",";","if(",e,"){",l,".bindBuffer(",34963,",",e,".buffer.buffer);}","else if(",h.vao,".currentVAO){",e,"=",a.shared.elements+".getElements("+h.vao,".currentVAO.elements);",na?"":"if("+e+")"+l+".bindBuffer(34963,"+e+".buffer.buffer);","}");return e}(),n=e("primitive"),q=e("offset"),
r=function(){var e=m.count,f=b;if(e){if(e.contextDep&&d.contextDynamic||e.propDep)f=c;e=e.append(a,f)}else e=f.def(k,".","count");return e}();if("number"===typeof r){if(0===r)return}else c("if(",r,"){"),c.exit("}");var u,t;W&&(u=e("instances"),t=a.instancing);var x=p+".type",v=m.elements&&xa(m.elements)&&!m.vaoActive;W&&("number"!==typeof u||0<=u)?"string"===typeof u?(c("if(",u,">0){"),f(),c("}else if(",u,"<0){"),g(),c("}")):f():g()}function ca(a,b,c,d,e){b=P();e=b.proc("body",e);W&&(b.instancing=
e.def(b.shared.extensions,".angle_instanced_arrays"));a(b,e,c,d);return b.compile().body}function Z(a,b,c,d){N(a,b);c.useVAO?c.drawVAO?b(a.shared.vao,".setVAO(",c.drawVAO.append(a,b),");"):b(a.shared.vao,".setVAO(",a.shared.vao,".targetVAO);"):(b(a.shared.vao,".setVAO(null);"),ga(a,b,c,d.attributes,function(){return!0}));Q(a,b,c,d.uniforms,function(){return!0},!1);U(a,b,b,c)}function Fa(a,b){var c=a.proc("draw",1);N(a,c);ia(a,c,b.context);S(a,c,b.framebuffer);Aa(a,c,b);I(a,c,b.state);E(a,c,b,!1,!0);
var d=b.shader.progVar.append(a,c);c(a.shared.gl,".useProgram(",d,".program);");if(b.shader.program)Z(a,c,b,b.shader.program);else{c(a.shared.vao,".setVAO(null);");var e=a.global.def("{}"),f=c.def(d,".id"),g=c.def(e,"[",f,"]");c(a.cond(g).then(g,".call(this,a0);")["else"](g,"=",e,"[",f,"]=",a.link(function(c){return ca(Z,a,b,c,1)}),"(",d,");",g,".call(this,a0);"))}0<Object.keys(b.state).length&&c(a.shared.current,".dirty=true;");a.shared.vao&&c(a.shared.vao,".setVAO(null);")}function pa(a,b,c,d){function e(){return!0}
a.batchId="a1";N(a,b);ga(a,b,c,d.attributes,e);Q(a,b,c,d.uniforms,e,!1);U(a,b,b,c)}function qa(a,b,c,d){function e(a){return a.contextDep&&g||a.propDep}function f(a){return!e(a)}N(a,b);var g=c.contextDep,h=b.def(),l=b.def();a.shared.props=l;a.batchId=h;var k=a.scope(),m=a.scope();b(k.entry,"for(",h,"=0;",h,"<","a1",";++",h,"){",l,"=","a0","[",h,"];",m,"}",k.exit);c.needsContext&&ia(a,m,c.context);c.needsFramebuffer&&S(a,m,c.framebuffer);I(a,m,c.state,e);c.profile&&e(c.profile)&&E(a,m,c,!1,!0);d?(c.useVAO?
c.drawVAO?e(c.drawVAO)?m(a.shared.vao,".setVAO(",c.drawVAO.append(a,m),");"):k(a.shared.vao,".setVAO(",c.drawVAO.append(a,k),");"):k(a.shared.vao,".setVAO(",a.shared.vao,".targetVAO);"):(k(a.shared.vao,".setVAO(null);"),ga(a,k,c,d.attributes,f),ga(a,m,c,d.attributes,e)),Q(a,k,c,d.uniforms,f,!1),Q(a,m,c,d.uniforms,e,!0),U(a,k,m,c)):(b=a.global.def("{}"),d=c.shader.progVar.append(a,m),l=m.def(d,".id"),k=m.def(b,"[",l,"]"),m(a.shared.gl,".useProgram(",d,".program);","if(!",k,"){",k,"=",b,"[",l,"]=",
a.link(function(b){return ca(pa,a,c,b,2)}),"(",d,");}",k,".call(this,a0[",h,"],",h,");"))}function V(a,b){function c(a){return a.contextDep&&e||a.propDep}var d=a.proc("batch",2);a.batchId="0";N(a,d);var e=!1,f=!0;Object.keys(b.context).forEach(function(a){e=e||b.context[a].propDep});e||(ia(a,d,b.context),f=!1);var g=b.framebuffer,h=!1;g?(g.propDep?e=h=!0:g.contextDep&&e&&(h=!0),h||S(a,d,g)):S(a,d,null);b.state.viewport&&b.state.viewport.propDep&&(e=!0);Aa(a,d,b);I(a,d,b.state,function(a){return!c(a)});
b.profile&&c(b.profile)||E(a,d,b,!1,"a1");b.contextDep=e;b.needsContext=f;b.needsFramebuffer=h;f=b.shader.progVar;if(f.contextDep&&e||f.propDep)qa(a,d,b,null);else if(f=f.append(a,d),d(a.shared.gl,".useProgram(",f,".program);"),b.shader.program)qa(a,d,b,b.shader.program);else{d(a.shared.vao,".setVAO(null);");var g=a.global.def("{}"),h=d.def(f,".id"),l=d.def(g,"[",h,"]");d(a.cond(l).then(l,".call(this,a0,a1);")["else"](l,"=",g,"[",h,"]=",a.link(function(c){return ca(qa,a,b,c,2)}),"(",f,");",l,".call(this,a0,a1);"))}0<
Object.keys(b.state).length&&d(a.shared.current,".dirty=true;");a.shared.vao&&d(a.shared.vao,".setVAO(null);")}function ka(a,c){function d(b){var g=c.shader[b];g&&e.set(f.shader,"."+b,g.append(a,e))}var e=a.proc("scope",3);a.batchId="a2";var f=a.shared,g=f.current;ia(a,e,c.context);c.framebuffer&&c.framebuffer.append(a,e);yb(Object.keys(c.state)).forEach(function(b){var d=c.state[b].append(a,e);ra(d)?d.forEach(function(c,d){e.set(a.next[b],"["+d+"]",c)}):e.set(f.next,"."+b,d)});E(a,e,c,!0,!0);["elements",
"offset","count","instances","primitive"].forEach(function(b){var d=c.draw[b];d&&e.set(f.draw,"."+b,""+d.append(a,e))});Object.keys(c.uniforms).forEach(function(d){var g=c.uniforms[d].append(a,e);Array.isArray(g)&&(g="["+g.join()+"]");e.set(f.uniforms,"["+b.id(d)+"]",g)});Object.keys(c.attributes).forEach(function(b){var d=c.attributes[b].append(a,e),f=a.scopeAttrib(b);Object.keys(new ea).forEach(function(a){e.set(f,"."+a,d[a])})});c.scopeVAO&&e.set(f.vao,".targetVAO",c.scopeVAO.append(a,e));d("vert");
d("frag");0<Object.keys(c.state).length&&(e(g,".dirty=true;"),e.exit(g,".dirty=true;"));e("a1(",a.shared.context,",a0,",a.batchId,");")}function la(a){if("object"===typeof a&&!ra(a)){for(var b=Object.keys(a),c=0;c<b.length;++c)if(Y.isDynamic(a[b[c]]))return!0;return!1}}function aa(a,b,c){function d(a,b){g.forEach(function(c){var d=e[c];Y.isDynamic(d)&&(d=a.invoke(b,d),b(m,".",c,"=",d,";"))})}var e=b["static"][c];if(e&&la(e)){var f=a.global,g=Object.keys(e),h=!1,l=!1,k=!1,m=a.global.def("{}");g.forEach(function(b){var c=
e[b];if(Y.isDynamic(c))"function"===typeof c&&(c=e[b]=Y.unbox(c)),b=K(c,null),h=h||b.thisDep,k=k||b.propDep,l=l||b.contextDep;else{f(m,".",b,"=");switch(typeof c){case "number":f(c);break;case "string":f('"',c,'"');break;case "object":Array.isArray(c)&&f("[",c.join(),"]");break;default:f(a.link(c))}f(";")}});b.dynamic[c]=new Y.DynamicVariable(4,{thisDep:h,contextDep:l,propDep:k,ref:m,append:d});delete b["static"][c]}}var ea=k.Record,fa={add:32774,subtract:32778,"reverse subtract":32779};c.ext_blend_minmax&&
(fa.min=32775,fa.max=32776);var W=c.angle_instanced_arrays,Ma=c.webgl_draw_buffers,na=c.oes_vertex_array_object,ta={dirty:!0,profile:g.profile},Ea={},Na=[],ua={},va={};r("dither",3024);r("blend.enable",3042);p("blend.color","blendColor",[0,0,0,0]);p("blend.equation","blendEquationSeparate",[32774,32774]);p("blend.func","blendFuncSeparate",[1,0,1,0]);r("depth.enable",2929,!0);p("depth.func","depthFunc",513);p("depth.range","depthRange",[0,1]);p("depth.mask","depthMask",!0);p("colorMask","colorMask",
[!0,!0,!0,!0]);r("cull.enable",2884);p("cull.face","cullFace",1029);p("frontFace","frontFace",2305);p("lineWidth","lineWidth",1);r("polygonOffset.enable",32823);p("polygonOffset.offset","polygonOffset",[0,0]);r("sample.alpha",32926);r("sample.enable",32928);p("sample.coverage","sampleCoverage",[1,!1]);r("stencil.enable",2960);p("stencil.mask","stencilMask",-1);p("stencil.func","stencilFunc",[519,0,-1]);p("stencil.opFront","stencilOpSeparate",[1028,7680,7680,7680]);p("stencil.opBack","stencilOpSeparate",
[1029,7680,7680,7680]);r("scissor.enable",3089);p("scissor.box","scissor",[0,0,a.drawingBufferWidth,a.drawingBufferHeight]);p("viewport","viewport",[0,0,a.drawingBufferWidth,a.drawingBufferHeight]);var tb={gl:a,context:x,strings:b,next:Ea,current:ta,draw:m,elements:d,buffer:f,shader:u,attributes:k.state,vao:k,uniforms:v,framebuffer:n,extensions:c,timer:l,isBufferArgs:Sa},Pa={primTypes:Ka,compareFuncs:ab,blendFuncs:Ga,blendEquations:fa,stencilOps:Ta,glTypes:Ja,orientationType:zb};Ma&&(Pa.backBuffer=
[1029],Pa.drawBuffer=R(e.maxDrawbuffers,function(a){return 0===a?[0]:R(a,function(a){return 36064+a})}));var sa=0;return{next:Ea,current:ta,procs:function(){var a=P(),b=a.proc("poll"),d=a.proc("refresh"),f=a.block();b(f);d(f);var g=a.shared,h=g.gl,l=g.next,k=g.current;f(k,".dirty=false;");S(a,b);S(a,d,null,!0);var m;W&&(m=a.link(W));c.oes_vertex_array_object&&d(a.link(c.oes_vertex_array_object),".bindVertexArrayOES(null);");for(var p=0;p<e.maxAttributes;++p){var n=d.def(g.attributes,"[",p,"]"),q=
a.cond(n,".buffer");q.then(h,".enableVertexAttribArray(",p,");",h,".bindBuffer(",34962,",",n,".buffer.buffer);",h,".vertexAttribPointer(",p,",",n,".size,",n,".type,",n,".normalized,",n,".stride,",n,".offset);")["else"](h,".disableVertexAttribArray(",p,");",h,".vertexAttrib4f(",p,",",n,".x,",n,".y,",n,".z,",n,".w);",n,".buffer=null;");d(q);W&&d(m,".vertexAttribDivisorANGLE(",p,",",n,".divisor);")}d(a.shared.vao,".currentVAO=null;",a.shared.vao,".setVAO(",a.shared.vao,".targetVAO);");Object.keys(ua).forEach(function(c){var e=
ua[c],g=f.def(l,".",c),m=a.block();m("if(",g,"){",h,".enable(",e,")}else{",h,".disable(",e,")}",k,".",c,"=",g,";");d(m);b("if(",g,"!==",k,".",c,"){",m,"}")});Object.keys(va).forEach(function(c){var e=va[c],g=ta[c],m,p,n=a.block();n(h,".",e,"(");ra(g)?(e=g.length,m=a.global.def(l,".",c),p=a.global.def(k,".",c),n(R(e,function(a){return m+"["+a+"]"}),");",R(e,function(a){return p+"["+a+"]="+m+"["+a+"];"}).join("")),b("if(",R(e,function(a){return m+"["+a+"]!=="+p+"["+a+"]"}).join("||"),"){",n,"}")):(m=
f.def(l,".",c),p=f.def(k,".",c),n(m,");",k,".",c,"=",m,";"),b("if(",m,"!==",p,"){",n,"}"));d(n)});return a.compile()}(),compile:function(a,b,c,d,e){var f=P();f.stats=f.link(e);Object.keys(b["static"]).forEach(function(a){aa(f,b,a)});Xb.forEach(function(b){aa(f,a,b)});var g=A(a,b,c,d,f);Fa(f,g);ka(f,g);V(f,g);return L(f.compile(),{destroy:function(){g.shader.program.destroy()}})}}}function Bb(a,b){for(var c=0;c<a.length;++c)if(a[c]===b)return c;return-1}var L=function(a,b){for(var c=Object.keys(b),
e=0;e<c.length;++e)a[c[e]]=b[c[e]];return a},Db=0,Y={DynamicVariable:Z,define:function(a,b){return new Z(a,cb(b+""))},isDynamic:function(a){return"function"===typeof a&&!a._reglType||a instanceof Z},unbox:db,accessor:cb},bb={next:"function"===typeof requestAnimationFrame?function(a){return requestAnimationFrame(a)}:function(a){return setTimeout(a,16)},cancel:"function"===typeof cancelAnimationFrame?function(a){return cancelAnimationFrame(a)}:clearTimeout},Cb="undefined"!==typeof performance&&performance.now?
function(){return performance.now()}:function(){return+new Date},G=hb();G.zero=hb();var Yb=function(a,b){var c=1;b.ext_texture_filter_anisotropic&&(c=a.getParameter(34047));var e=1,f=1;b.webgl_draw_buffers&&(e=a.getParameter(34852),f=a.getParameter(36063));var d=!!b.oes_texture_float;if(d){d=a.createTexture();a.bindTexture(3553,d);a.texImage2D(3553,0,6408,1,1,0,6408,5126,null);var q=a.createFramebuffer();a.bindFramebuffer(36160,q);a.framebufferTexture2D(36160,36064,3553,d,0);a.bindTexture(3553,null);
if(36053!==a.checkFramebufferStatus(36160))d=!1;else{a.viewport(0,0,1,1);a.clearColor(1,0,0,1);a.clear(16384);var n=G.allocType(5126,4);a.readPixels(0,0,1,1,6408,5126,n);a.getError()?d=!1:(a.deleteFramebuffer(q),a.deleteTexture(d),d=1===n[0]);G.freeType(n)}}n=!0;"undefined"!==typeof navigator&&(/MSIE/.test(navigator.userAgent)||/Trident\//.test(navigator.appVersion)||/Edge/.test(navigator.userAgent))||(n=a.createTexture(),q=G.allocType(5121,36),a.activeTexture(33984),a.bindTexture(34067,n),a.texImage2D(34069,
0,6408,3,3,0,6408,5121,q),G.freeType(q),a.bindTexture(34067,null),a.deleteTexture(n),n=!a.getError());return{colorBits:[a.getParameter(3410),a.getParameter(3411),a.getParameter(3412),a.getParameter(3413)],depthBits:a.getParameter(3414),stencilBits:a.getParameter(3415),subpixelBits:a.getParameter(3408),extensions:Object.keys(b).filter(function(a){return!!b[a]}),maxAnisotropic:c,maxDrawbuffers:e,maxColorAttachments:f,pointSizeDims:a.getParameter(33901),lineWidthDims:a.getParameter(33902),maxViewportDims:a.getParameter(3386),
maxCombinedTextureUnits:a.getParameter(35661),maxCubeMapSize:a.getParameter(34076),maxRenderbufferSize:a.getParameter(34024),maxTextureUnits:a.getParameter(34930),maxTextureSize:a.getParameter(3379),maxAttributes:a.getParameter(34921),maxVertexUniforms:a.getParameter(36347),maxVertexTextureUnits:a.getParameter(35660),maxVaryingVectors:a.getParameter(36348),maxFragmentUniforms:a.getParameter(36349),glsl:a.getParameter(35724),renderer:a.getParameter(7937),vendor:a.getParameter(7936),version:a.getParameter(7938),
readFloat:d,npotTextureCube:n}},O=function(a){return a instanceof Uint8Array||a instanceof Uint16Array||a instanceof Uint32Array||a instanceof Int8Array||a instanceof Int16Array||a instanceof Int32Array||a instanceof Float32Array||a instanceof Float64Array||a instanceof Uint8ClampedArray},I=function(a){return Object.keys(a).map(function(b){return a[b]})},Qa={shape:function(a){for(var b=[];a.length;a=a[0])b.push(a.length);return b},flatten:function(a,b,c,e){var f=1;if(b.length)for(var d=0;d<b.length;++d)f*=
b[d];else f=0;c=e||G.allocType(c,f);switch(b.length){case 0:break;case 1:e=b[0];for(b=0;b<e;++b)c[b]=a[b];break;case 2:e=b[0];b=b[1];for(d=f=0;d<e;++d)for(var q=a[d],n=0;n<b;++n)c[f++]=q[n];break;case 3:ib(a,b[0],b[1],b[2],c,0);break;default:jb(a,b,0,c,0)}return c}},Ia={"[object Int8Array]":5120,"[object Int16Array]":5122,"[object Int32Array]":5124,"[object Uint8Array]":5121,"[object Uint8ClampedArray]":5121,"[object Uint16Array]":5123,"[object Uint32Array]":5125,"[object Float32Array]":5126,"[object Float64Array]":5121,
"[object ArrayBuffer]":5121},Ja={int8:5120,int16:5122,int32:5124,uint8:5121,uint16:5123,uint32:5125,"float":5126,float32:5126},nb={dynamic:35048,stream:35040,"static":35044},Ua=Qa.flatten,mb=Qa.shape,na=[];na[5120]=1;na[5122]=2;na[5124]=4;na[5121]=1;na[5123]=2;na[5125]=4;na[5126]=4;var Ka={points:0,point:0,lines:1,line:1,triangles:4,triangle:4,"line loop":2,"line strip":3,"triangle strip":5,"triangle fan":6},pb=new Float32Array(1),Lb=new Uint32Array(pb.buffer),Pb=[9984,9986,9985,9987],Oa=[0,6409,
6410,6407,6408],U={};U[6409]=U[6406]=U[6402]=1;U[34041]=U[6410]=2;U[6407]=U[35904]=3;U[6408]=U[35906]=4;var Xa=sa("HTMLCanvasElement"),Ya=sa("OffscreenCanvas"),ub=sa("CanvasRenderingContext2D"),vb=sa("ImageBitmap"),wb=sa("HTMLImageElement"),xb=sa("HTMLVideoElement"),Mb=Object.keys(Ia).concat([Xa,Ya,ub,vb,wb,xb]),za=[];za[5121]=1;za[5126]=4;za[36193]=2;za[5123]=2;za[5125]=4;var C=[];C[32854]=2;C[32855]=2;C[36194]=2;C[34041]=4;C[33776]=.5;C[33777]=.5;C[33778]=1;C[33779]=1;C[35986]=.5;C[35987]=1;C[34798]=
1;C[35840]=.5;C[35841]=.25;C[35842]=.5;C[35843]=.25;C[36196]=.5;var Q=[];Q[32854]=2;Q[32855]=2;Q[36194]=2;Q[33189]=2;Q[36168]=1;Q[34041]=4;Q[35907]=4;Q[34836]=16;Q[34842]=8;Q[34843]=6;var Zb=function(a,b,c,e,f){function d(a){this.id=k++;this.refCount=1;this.renderbuffer=a;this.format=32854;this.height=this.width=0;f.profile&&(this.stats={size:0})}function q(b){var c=b.renderbuffer;a.bindRenderbuffer(36161,null);a.deleteRenderbuffer(c);b.renderbuffer=null;b.refCount=0;delete u[b.id];e.renderbufferCount--}
var n={rgba4:32854,rgb565:36194,"rgb5 a1":32855,depth:33189,stencil:36168,"depth stencil":34041};b.ext_srgb&&(n.srgba=35907);b.ext_color_buffer_half_float&&(n.rgba16f=34842,n.rgb16f=34843);b.webgl_color_buffer_float&&(n.rgba32f=34836);var v=[];Object.keys(n).forEach(function(a){v[n[a]]=a});var k=0,u={};d.prototype.decRef=function(){0>=--this.refCount&&q(this)};f.profile&&(e.getTotalRenderbufferSize=function(){var a=0;Object.keys(u).forEach(function(b){a+=u[b].stats.size});return a});return{create:function(b,
c){function l(b,c){var d=0,e=0,k=32854;"object"===typeof b&&b?("shape"in b?(e=b.shape,d=e[0]|0,e=e[1]|0):("radius"in b&&(d=e=b.radius|0),"width"in b&&(d=b.width|0),"height"in b&&(e=b.height|0)),"format"in b&&(k=n[b.format])):"number"===typeof b?(d=b|0,e="number"===typeof c?c|0:d):b||(d=e=1);if(d!==g.width||e!==g.height||k!==g.format)return l.width=g.width=d,l.height=g.height=e,g.format=k,a.bindRenderbuffer(36161,g.renderbuffer),a.renderbufferStorage(36161,k,d,e),f.profile&&(g.stats.size=Q[g.format]*
g.width*g.height),l.format=v[g.format],l}var g=new d(a.createRenderbuffer());u[g.id]=g;e.renderbufferCount++;l(b,c);l.resize=function(b,c){var d=b|0,e=c|0||d;if(d===g.width&&e===g.height)return l;l.width=g.width=d;l.height=g.height=e;a.bindRenderbuffer(36161,g.renderbuffer);a.renderbufferStorage(36161,g.format,d,e);f.profile&&(g.stats.size=Q[g.format]*g.width*g.height);return l};l._reglType="renderbuffer";l._renderbuffer=g;f.profile&&(l.stats=g.stats);l.destroy=function(){g.decRef()};return l},clear:function(){I(u).forEach(q)},
restore:function(){I(u).forEach(function(b){b.renderbuffer=a.createRenderbuffer();a.bindRenderbuffer(36161,b.renderbuffer);a.renderbufferStorage(36161,b.format,b.width,b.height)});a.bindRenderbuffer(36161,null)}}},Za=[];Za[6408]=4;Za[6407]=3;var Ra=[];Ra[5121]=1;Ra[5126]=4;Ra[36193]=2;var Da=["x","y","z","w"],Xb="blend.func blend.equation stencil.func stencil.opFront stencil.opBack sample.coverage viewport scissor.box polygonOffset.offset".split(" "),Ga={0:0,1:1,zero:0,one:1,"src color":768,"one minus src color":769,
"src alpha":770,"one minus src alpha":771,"dst color":774,"one minus dst color":775,"dst alpha":772,"one minus dst alpha":773,"constant color":32769,"one minus constant color":32770,"constant alpha":32771,"one minus constant alpha":32772,"src alpha saturate":776},ab={never:512,less:513,"<":513,equal:514,"=":514,"==":514,"===":514,lequal:515,"<=":515,greater:516,">":516,notequal:517,"!=":517,"!==":517,gequal:518,">=":518,always:519},Ta={0:0,zero:0,keep:7680,replace:7681,increment:7682,decrement:7683,
"increment wrap":34055,"decrement wrap":34056,invert:5386},zb={cw:2304,ccw:2305},Ab=new J(!1,!1,!1,function(){}),$b=function(a,b){function c(){this.endQueryIndex=this.startQueryIndex=-1;this.sum=0;this.stats=null}function e(a,b,d){var e=q.pop()||new c;e.startQueryIndex=a;e.endQueryIndex=b;e.sum=0;e.stats=d;n.push(e)}if(!b.ext_disjoint_timer_query)return null;var f=[],d=[],q=[],n=[],v=[],k=[];return{beginQuery:function(a){var c=f.pop()||b.ext_disjoint_timer_query.createQueryEXT();b.ext_disjoint_timer_query.beginQueryEXT(35007,
c);d.push(c);e(d.length-1,d.length,a)},endQuery:function(){b.ext_disjoint_timer_query.endQueryEXT(35007)},pushScopeStats:e,update:function(){var a,c;a=d.length;if(0!==a){k.length=Math.max(k.length,a+1);v.length=Math.max(v.length,a+1);v[0]=0;var e=k[0]=0;for(c=a=0;c<d.length;++c){var l=d[c];b.ext_disjoint_timer_query.getQueryObjectEXT(l,34919)?(e+=b.ext_disjoint_timer_query.getQueryObjectEXT(l,34918),f.push(l)):d[a++]=l;v[c+1]=e;k[c+1]=a}d.length=a;for(c=a=0;c<n.length;++c){var e=n[c],g=e.startQueryIndex,
l=e.endQueryIndex;e.sum+=v[l]-v[g];g=k[g];l=k[l];l===g?(e.stats.gpuTime+=e.sum/1E6,q.push(e)):(e.startQueryIndex=g,e.endQueryIndex=l,n[a++]=e)}n.length=a}},getNumPendingQueries:function(){return d.length},clear:function(){f.push.apply(f,d);for(var a=0;a<f.length;a++)b.ext_disjoint_timer_query.deleteQueryEXT(f[a]);d.length=0;f.length=0},restore:function(){d.length=0;f.length=0}}};return function(a){function b(){if(0===E.length)t&&t.update(),ca=null;else{ca=bb.next(b);u();for(var a=E.length-1;0<=a;--a){var c=
E[a];c&&c(H,null,0)}l.flush();t&&t.update()}}function c(){!ca&&0<E.length&&(ca=bb.next(b))}function e(){ca&&(bb.cancel(b),ca=null)}function f(a){a.preventDefault();e();R.forEach(function(a){a()})}function d(a){l.getError();h.restore();F.restore();y.restore();A.restore();O.restore();S.restore();K.restore();t&&t.restore();I.procs.refresh();c();U.forEach(function(a){a()})}function q(a){function b(a,c){var d={},e={};Object.keys(a).forEach(function(b){var f=a[b];if(Y.isDynamic(f))e[b]=Y.unbox(f,b);else{if(c&&
Array.isArray(f))for(var g=0;g<f.length;++g)if(Y.isDynamic(f[g])){e[b]=Y.unbox(f,b);return}d[b]=f}});return{dynamic:e,"static":d}}function c(a){for(;n.length<a;)n.push(null);return n}var d=b(a.context||{},!0),e=b(a.uniforms||{},!0),f=b(a.attributes||{},!1);a=b(function(a){function b(a){if(a in c){var d=c[a];delete c[a];Object.keys(d).forEach(function(b){c[a+"."+b]=d[b]})}}var c=L({},a);delete c.uniforms;delete c.attributes;delete c.context;delete c.vao;"stencil"in c&&c.stencil.op&&(c.stencil.opBack=
c.stencil.opFront=c.stencil.op,delete c.stencil.op);b("blend");b("depth");b("cull");b("stencil");b("polygonOffset");b("scissor");b("sample");"vao"in a&&(c.vao=a.vao);return c}(a),!1);var g={gpuTime:0,cpuTime:0,count:0},h=I.compile(a,f,e,d,g),k=h.draw,l=h.batch,m=h.scope,n=[];return L(function(a,b){var d;if("function"===typeof a)return m.call(this,null,a,0);if("function"===typeof b)if("number"===typeof a)for(d=0;d<a;++d)m.call(this,null,b,d);else if(Array.isArray(a))for(d=0;d<a.length;++d)m.call(this,
a[d],b,d);else return m.call(this,a,b,0);else if("number"===typeof a){if(0<a)return l.call(this,c(a|0),a|0)}else if(Array.isArray(a)){if(a.length)return l.call(this,a,a.length)}else return k.call(this,a)},{stats:g,destroy:function(){h.destroy()}})}function n(a,b){var c=0;I.procs.poll();var d=b.color;d&&(l.clearColor(+d[0]||0,+d[1]||0,+d[2]||0,+d[3]||0),c|=16384);"depth"in b&&(l.clearDepth(+b.depth),c|=256);"stencil"in b&&(l.clearStencil(b.stencil|0),c|=1024);l.clear(c)}function v(a){E.push(a);c();
return{cancel:function(){function b(){var a=Bb(E,b);E[a]=E[E.length-1];--E.length;0>=E.length&&e()}var c=Bb(E,a);E[c]=b}}}function k(){var a=Q.viewport,b=Q.scissor_box;a[0]=a[1]=b[0]=b[1]=0;H.viewportWidth=H.framebufferWidth=H.drawingBufferWidth=a[2]=b[2]=l.drawingBufferWidth;H.viewportHeight=H.framebufferHeight=H.drawingBufferHeight=a[3]=b[3]=l.drawingBufferHeight}function u(){H.tick+=1;H.time=x();k();I.procs.poll()}function m(){A.refresh();k();I.procs.refresh();t&&t.update()}function x(){return(Cb()-
G)/1E3}a=Hb(a);if(!a)return null;var l=a.gl,g=l.getContextAttributes();l.isContextLost();var h=Ib(l,a);if(!h)return null;var r=Eb(),p={vaoCount:0,bufferCount:0,elementsCount:0,framebufferCount:0,shaderCount:0,textureCount:0,cubeCount:0,renderbufferCount:0,maxTextureUnits:0},w=h.extensions,t=$b(l,w),G=Cb(),C=l.drawingBufferWidth,J=l.drawingBufferHeight,H={tick:0,time:0,viewportWidth:C,viewportHeight:J,framebufferWidth:C,framebufferHeight:J,drawingBufferWidth:C,drawingBufferHeight:J,pixelRatio:a.pixelRatio},
C={elements:null,primitive:4,count:-1,offset:0,instances:-1},M=Yb(l,w),y=Jb(l,p,a,function(a){return K.destroyBuffer(a)}),T=Kb(l,w,y,p),K=Sb(l,w,M,p,y,T,C),F=Tb(l,r,p,a),A=Nb(l,w,M,function(){I.procs.poll()},H,p,a),O=Zb(l,w,M,p,a),S=Rb(l,w,M,A,O,p),I=Wb(l,r,w,M,y,T,A,S,{},K,F,C,H,t,a),r=Ub(l,S,I.procs.poll,H,g,w,M),Q=I.next,N=l.canvas,E=[],R=[],U=[],Z=[a.onDestroy],ca=null;N&&(N.addEventListener("webglcontextlost",f,!1),N.addEventListener("webglcontextrestored",d,!1));var aa=S.setFBO=q({framebuffer:Y.define.call(null,
1,"framebuffer")});m();g=L(q,{clear:function(a){if("framebuffer"in a)if(a.framebuffer&&"framebufferCube"===a.framebuffer_reglType)for(var b=0;6>b;++b)aa(L({framebuffer:a.framebuffer.faces[b]},a),n);else aa(a,n);else n(null,a)},prop:Y.define.bind(null,1),context:Y.define.bind(null,2),"this":Y.define.bind(null,3),draw:q({}),buffer:function(a){return y.create(a,34962,!1,!1)},elements:function(a){return T.create(a,!1)},texture:A.create2D,cube:A.createCube,renderbuffer:O.create,framebuffer:S.create,framebufferCube:S.createCube,
vao:K.createVAO,attributes:g,frame:v,on:function(a,b){var c;switch(a){case "frame":return v(b);case "lost":c=R;break;case "restore":c=U;break;case "destroy":c=Z}c.push(b);return{cancel:function(){for(var a=0;a<c.length;++a)if(c[a]===b){c[a]=c[c.length-1];c.pop();break}}}},limits:M,hasExtension:function(a){return 0<=M.extensions.indexOf(a.toLowerCase())},read:r,destroy:function(){E.length=0;e();N&&(N.removeEventListener("webglcontextlost",f),N.removeEventListener("webglcontextrestored",d));F.clear();
S.clear();O.clear();K.clear();A.clear();T.clear();y.clear();t&&t.clear();Z.forEach(function(a){a()})},_gl:l,_refresh:m,poll:function(){u();t&&t.update()},now:x,stats:p});a.onDone(null,g);return g}});

},{}],2:[function(require,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.TweakpaneLatexPlugin = {}));
})(this, (function (exports) { 'use strict';

    class BladeApi {
        constructor(controller) {
            this.controller_ = controller;
        }
        get element() {
            return this.controller_.view.element;
        }
        get disabled() {
            return this.controller_.viewProps.get('disabled');
        }
        set disabled(disabled) {
            this.controller_.viewProps.set('disabled', disabled);
        }
        get hidden() {
            return this.controller_.viewProps.get('hidden');
        }
        set hidden(hidden) {
            this.controller_.viewProps.set('hidden', hidden);
        }
        dispose() {
            this.controller_.viewProps.set('disposed', true);
        }
    }

    function forceCast(v) {
        return v;
    }
    function deepEqualsArray(a1, a2) {
        if (a1.length !== a2.length) {
            return false;
        }
        for (let i = 0; i < a1.length; i++) {
            if (a1[i] !== a2[i]) {
                return false;
            }
        }
        return true;
    }

    class Emitter {
        constructor() {
            this.observers_ = {};
        }
        on(eventName, handler) {
            let observers = this.observers_[eventName];
            if (!observers) {
                observers = this.observers_[eventName] = [];
            }
            observers.push({
                handler: handler,
            });
            return this;
        }
        off(eventName, handler) {
            const observers = this.observers_[eventName];
            if (observers) {
                this.observers_[eventName] = observers.filter((observer) => {
                    return observer.handler !== handler;
                });
            }
            return this;
        }
        emit(eventName, event) {
            const observers = this.observers_[eventName];
            if (!observers) {
                return;
            }
            observers.forEach((observer) => {
                observer.handler(event);
            });
        }
    }

    const PREFIX = 'tp';
    function ClassName(viewName) {
        const fn = (opt_elementName, opt_modifier) => {
            return [
                PREFIX,
                '-',
                viewName,
                'v',
                opt_elementName ? `_${opt_elementName}` : '',
                opt_modifier ? `-${opt_modifier}` : '',
            ].join('');
        };
        return fn;
    }

    function compose(h1, h2) {
        return (input) => h2(h1(input));
    }
    function extractValue(ev) {
        return ev.rawValue;
    }
    function bindValue(value, applyValue) {
        value.emitter.on('change', compose(extractValue, applyValue));
        applyValue(value.rawValue);
    }
    function bindValueMap(valueMap, key, applyValue) {
        bindValue(valueMap.value(key), applyValue);
    }

    function applyClass(elem, className, active) {
        if (active) {
            elem.classList.add(className);
        }
        else {
            elem.classList.remove(className);
        }
    }
    function valueToClassName(elem, className) {
        return (value) => {
            applyClass(elem, className, value);
        };
    }

    class BoundValue {
        constructor(initialValue, config) {
            var _a;
            this.constraint_ = config === null || config === void 0 ? void 0 : config.constraint;
            this.equals_ = (_a = config === null || config === void 0 ? void 0 : config.equals) !== null && _a !== void 0 ? _a : ((v1, v2) => v1 === v2);
            this.emitter = new Emitter();
            this.rawValue_ = initialValue;
        }
        get constraint() {
            return this.constraint_;
        }
        get rawValue() {
            return this.rawValue_;
        }
        set rawValue(rawValue) {
            this.setRawValue(rawValue, {
                forceEmit: false,
                last: true,
            });
        }
        setRawValue(rawValue, options) {
            const opts = options !== null && options !== void 0 ? options : {
                forceEmit: false,
                last: true,
            };
            const constrainedValue = this.constraint_
                ? this.constraint_.constrain(rawValue)
                : rawValue;
            const prevValue = this.rawValue_;
            const changed = !this.equals_(prevValue, constrainedValue);
            if (!changed && !opts.forceEmit) {
                return;
            }
            this.emitter.emit('beforechange', {
                sender: this,
            });
            this.rawValue_ = constrainedValue;
            this.emitter.emit('change', {
                options: opts,
                previousRawValue: prevValue,
                rawValue: constrainedValue,
                sender: this,
            });
        }
    }

    class PrimitiveValue {
        constructor(initialValue) {
            this.emitter = new Emitter();
            this.value_ = initialValue;
        }
        get rawValue() {
            return this.value_;
        }
        set rawValue(value) {
            this.setRawValue(value, {
                forceEmit: false,
                last: true,
            });
        }
        setRawValue(value, options) {
            const opts = options !== null && options !== void 0 ? options : {
                forceEmit: false,
                last: true,
            };
            const prevValue = this.value_;
            if (prevValue === value && !opts.forceEmit) {
                return;
            }
            this.emitter.emit('beforechange', {
                sender: this,
            });
            this.value_ = value;
            this.emitter.emit('change', {
                options: opts,
                previousRawValue: prevValue,
                rawValue: this.value_,
                sender: this,
            });
        }
    }

    function createValue(initialValue, config) {
        const constraint = config === null || config === void 0 ? void 0 : config.constraint;
        const equals = config === null || config === void 0 ? void 0 : config.equals;
        if (!constraint && !equals) {
            return new PrimitiveValue(initialValue);
        }
        return new BoundValue(initialValue, config);
    }

    class ValueMap {
        constructor(valueMap) {
            this.emitter = new Emitter();
            this.valMap_ = valueMap;
            for (const key in this.valMap_) {
                const v = this.valMap_[key];
                v.emitter.on('change', () => {
                    this.emitter.emit('change', {
                        key: key,
                        sender: this,
                    });
                });
            }
        }
        static createCore(initialValue) {
            const keys = Object.keys(initialValue);
            return keys.reduce((o, key) => {
                return Object.assign(o, {
                    [key]: createValue(initialValue[key]),
                });
            }, {});
        }
        static fromObject(initialValue) {
            const core = this.createCore(initialValue);
            return new ValueMap(core);
        }
        get(key) {
            return this.valMap_[key].rawValue;
        }
        set(key, value) {
            this.valMap_[key].rawValue = value;
        }
        value(key) {
            return this.valMap_[key];
        }
    }

    function parseObject(value, keyToParserMap) {
        const keys = Object.keys(keyToParserMap);
        const result = keys.reduce((tmp, key) => {
            if (tmp === undefined) {
                return undefined;
            }
            const parser = keyToParserMap[key];
            const result = parser(value[key]);
            return result.succeeded
                ? Object.assign(Object.assign({}, tmp), { [key]: result.value }) : undefined;
        }, {});
        return forceCast(result);
    }
    function parseArray$1(value, parseItem) {
        return value.reduce((tmp, item) => {
            if (tmp === undefined) {
                return undefined;
            }
            const result = parseItem(item);
            if (!result.succeeded || result.value === undefined) {
                return undefined;
            }
            return [...tmp, result.value];
        }, []);
    }
    function isObject(value) {
        if (value === null) {
            return false;
        }
        return typeof value === 'object';
    }
    function createParamsParserBuilder(parse) {
        return (optional) => (v) => {
            if (!optional && v === undefined) {
                return {
                    succeeded: false,
                    value: undefined,
                };
            }
            if (optional && v === undefined) {
                return {
                    succeeded: true,
                    value: undefined,
                };
            }
            const result = parse(v);
            return result !== undefined
                ? {
                    succeeded: true,
                    value: result,
                }
                : {
                    succeeded: false,
                    value: undefined,
                };
        };
    }
    function createParamsParserBuilders(optional) {
        return {
            custom: (parse) => createParamsParserBuilder(parse)(optional),
            boolean: createParamsParserBuilder((v) => typeof v === 'boolean' ? v : undefined)(optional),
            number: createParamsParserBuilder((v) => typeof v === 'number' ? v : undefined)(optional),
            string: createParamsParserBuilder((v) => typeof v === 'string' ? v : undefined)(optional),
            function: createParamsParserBuilder((v) =>
            typeof v === 'function' ? v : undefined)(optional),
            constant: (value) => createParamsParserBuilder((v) => (v === value ? value : undefined))(optional),
            raw: createParamsParserBuilder((v) => v)(optional),
            object: (keyToParserMap) => createParamsParserBuilder((v) => {
                if (!isObject(v)) {
                    return undefined;
                }
                return parseObject(v, keyToParserMap);
            })(optional),
            array: (itemParser) => createParamsParserBuilder((v) => {
                if (!Array.isArray(v)) {
                    return undefined;
                }
                return parseArray$1(v, itemParser);
            })(optional),
        };
    }
    const ParamsParsers = {
        optional: createParamsParserBuilders(true),
        required: createParamsParserBuilders(false),
    };
    function parseParams(value, keyToParserMap) {
        const result = ParamsParsers.required.object(keyToParserMap)(value);
        return result.succeeded ? result.value : undefined;
    }

    function warnMissing(info) {
        console.warn([
            `Missing '${info.key}' of ${info.target} in ${info.place}.`,
            'Please rebuild plugins with the latest core package.',
        ].join(' '));
    }

    function disposeElement(elem) {
        if (elem && elem.parentElement) {
            elem.parentElement.removeChild(elem);
        }
        return null;
    }

    class ReadonlyValue {
        constructor(value) {
            this.value_ = value;
        }
        static create(value) {
            return [
                new ReadonlyValue(value),
                (rawValue, options) => {
                    value.setRawValue(rawValue, options);
                },
            ];
        }
        get emitter() {
            return this.value_.emitter;
        }
        get rawValue() {
            return this.value_.rawValue;
        }
    }

    const className$2 = ClassName('');
    function valueToModifier(elem, modifier) {
        return valueToClassName(elem, className$2(undefined, modifier));
    }
    class ViewProps extends ValueMap {
        constructor(valueMap) {
            var _a;
            super(valueMap);
            this.onDisabledChange_ = this.onDisabledChange_.bind(this);
            this.onParentChange_ = this.onParentChange_.bind(this);
            this.onParentGlobalDisabledChange_ =
                this.onParentGlobalDisabledChange_.bind(this);
            [this.globalDisabled_, this.setGlobalDisabled_] = ReadonlyValue.create(createValue(this.getGlobalDisabled_()));
            this.value('disabled').emitter.on('change', this.onDisabledChange_);
            this.value('parent').emitter.on('change', this.onParentChange_);
            (_a = this.get('parent')) === null || _a === void 0 ? void 0 : _a.globalDisabled.emitter.on('change', this.onParentGlobalDisabledChange_);
        }
        static create(opt_initialValue) {
            var _a, _b, _c;
            const initialValue = opt_initialValue !== null && opt_initialValue !== void 0 ? opt_initialValue : {};
            return new ViewProps(ValueMap.createCore({
                disabled: (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
                disposed: false,
                hidden: (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false,
                parent: (_c = initialValue.parent) !== null && _c !== void 0 ? _c : null,
            }));
        }
        get globalDisabled() {
            return this.globalDisabled_;
        }
        bindClassModifiers(elem) {
            bindValue(this.globalDisabled_, valueToModifier(elem, 'disabled'));
            bindValueMap(this, 'hidden', valueToModifier(elem, 'hidden'));
        }
        bindDisabled(target) {
            bindValue(this.globalDisabled_, (disabled) => {
                target.disabled = disabled;
            });
        }
        bindTabIndex(elem) {
            bindValue(this.globalDisabled_, (disabled) => {
                elem.tabIndex = disabled ? -1 : 0;
            });
        }
        handleDispose(callback) {
            this.value('disposed').emitter.on('change', (disposed) => {
                if (disposed) {
                    callback();
                }
            });
        }
        getGlobalDisabled_() {
            const parent = this.get('parent');
            const parentDisabled = parent ? parent.globalDisabled.rawValue : false;
            return parentDisabled || this.get('disabled');
        }
        updateGlobalDisabled_() {
            this.setGlobalDisabled_(this.getGlobalDisabled_());
        }
        onDisabledChange_() {
            this.updateGlobalDisabled_();
        }
        onParentGlobalDisabledChange_() {
            this.updateGlobalDisabled_();
        }
        onParentChange_(ev) {
            var _a;
            const prevParent = ev.previousRawValue;
            prevParent === null || prevParent === void 0 ? void 0 : prevParent.globalDisabled.emitter.off('change', this.onParentGlobalDisabledChange_);
            (_a = this.get('parent')) === null || _a === void 0 ? void 0 : _a.globalDisabled.emitter.on('change', this.onParentGlobalDisabledChange_);
            this.updateGlobalDisabled_();
        }
    }

    function getAllBladePositions() {
        return ['veryfirst', 'first', 'last', 'verylast'];
    }

    const className$1 = ClassName('');
    const POS_TO_CLASS_NAME_MAP = {
        veryfirst: 'vfst',
        first: 'fst',
        last: 'lst',
        verylast: 'vlst',
    };
    class BladeController {
        constructor(config) {
            this.parent_ = null;
            this.blade = config.blade;
            this.view = config.view;
            this.viewProps = config.viewProps;
            const elem = this.view.element;
            this.blade.value('positions').emitter.on('change', () => {
                getAllBladePositions().forEach((pos) => {
                    elem.classList.remove(className$1(undefined, POS_TO_CLASS_NAME_MAP[pos]));
                });
                this.blade.get('positions').forEach((pos) => {
                    elem.classList.add(className$1(undefined, POS_TO_CLASS_NAME_MAP[pos]));
                });
            });
            this.viewProps.handleDispose(() => {
                disposeElement(elem);
            });
        }
        get parent() {
            return this.parent_;
        }
        set parent(parent) {
            this.parent_ = parent;
            if (!('parent' in this.viewProps.valMap_)) {
                warnMissing({
                    key: 'parent',
                    target: ViewProps.name,
                    place: 'BladeController.parent',
                });
                return;
            }
            this.viewProps.set('parent', this.parent_ ? this.parent_.viewProps : null);
        }
    }

    function createBlade() {
        return new ValueMap({
            positions: createValue([], {
                equals: deepEqualsArray,
            }),
        });
    }

    function createNumberFormatter(digits) {
        return (value) => {
            return value.toFixed(Math.max(Math.min(digits, 20), 0));
        };
    }

    const innerFormatter = createNumberFormatter(0);
    function formatPercentage(value) {
        return innerFormatter(value) + '%';
    }

    function constrainRange(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }

    function removeAlphaComponent(comps) {
        return [comps[0], comps[1], comps[2]];
    }

    function zerofill(comp) {
        const hex = constrainRange(Math.floor(comp), 0, 255).toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
    }
    function colorToHexRgbString(value, prefix = '#') {
        const hexes = removeAlphaComponent(value.getComponents('rgb'))
            .map(zerofill)
            .join('');
        return `${prefix}${hexes}`;
    }
    function colorToHexRgbaString(value, prefix = '#') {
        const rgbaComps = value.getComponents('rgb');
        const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255]
            .map(zerofill)
            .join('');
        return `${prefix}${hexes}`;
    }
    function colorToFunctionalRgbString(value, opt_type) {
        const formatter = createNumberFormatter(opt_type === 'float' ? 2 : 0);
        const comps = removeAlphaComponent(value.getComponents('rgb', opt_type)).map((comp) => formatter(comp));
        return `rgb(${comps.join(', ')})`;
    }
    function createFunctionalRgbColorFormatter(type) {
        return (value) => {
            return colorToFunctionalRgbString(value, type);
        };
    }
    function colorToFunctionalRgbaString(value, opt_type) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(opt_type === 'float' ? 2 : 0);
        const comps = value.getComponents('rgb', opt_type).map((comp, index) => {
            const formatter = index === 3 ? aFormatter : rgbFormatter;
            return formatter(comp);
        });
        return `rgba(${comps.join(', ')})`;
    }
    function createFunctionalRgbaColorFormatter(type) {
        return (value) => {
            return colorToFunctionalRgbaString(value, type);
        };
    }
    function colorToFunctionalHslString(value) {
        const formatters = [
            createNumberFormatter(0),
            formatPercentage,
            formatPercentage,
        ];
        const comps = removeAlphaComponent(value.getComponents('hsl')).map((comp, index) => formatters[index](comp));
        return `hsl(${comps.join(', ')})`;
    }
    function colorToFunctionalHslaString(value) {
        const formatters = [
            createNumberFormatter(0),
            formatPercentage,
            formatPercentage,
            createNumberFormatter(2),
        ];
        const comps = value
            .getComponents('hsl')
            .map((comp, index) => formatters[index](comp));
        return `hsla(${comps.join(', ')})`;
    }
    function colorToObjectRgbString(value, type) {
        const formatter = createNumberFormatter(type === 'float' ? 2 : 0);
        const names = ['r', 'g', 'b'];
        const comps = removeAlphaComponent(value.getComponents('rgb', type)).map((comp, index) => `${names[index]}: ${formatter(comp)}`);
        return `{${comps.join(', ')}}`;
    }
    function createObjectRgbColorFormatter(type) {
        return (value) => colorToObjectRgbString(value, type);
    }
    function colorToObjectRgbaString(value, type) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(type === 'float' ? 2 : 0);
        const names = ['r', 'g', 'b', 'a'];
        const comps = value.getComponents('rgb', type).map((comp, index) => {
            const formatter = index === 3 ? aFormatter : rgbFormatter;
            return `${names[index]}: ${formatter(comp)}`;
        });
        return `{${comps.join(', ')}}`;
    }
    function createObjectRgbaColorFormatter(type) {
        return (value) => colorToObjectRgbaString(value, type);
    }
    [
        {
            format: {
                alpha: false,
                mode: 'rgb',
                notation: 'hex',
                type: 'int',
            },
            stringifier: colorToHexRgbString,
        },
        {
            format: {
                alpha: true,
                mode: 'rgb',
                notation: 'hex',
                type: 'int',
            },
            stringifier: colorToHexRgbaString,
        },
        {
            format: {
                alpha: false,
                mode: 'hsl',
                notation: 'func',
                type: 'int',
            },
            stringifier: colorToFunctionalHslString,
        },
        {
            format: {
                alpha: true,
                mode: 'hsl',
                notation: 'func',
                type: 'int',
            },
            stringifier: colorToFunctionalHslaString,
        },
        ...['int', 'float'].reduce((prev, type) => {
            return [
                ...prev,
                {
                    format: {
                        alpha: false,
                        mode: 'rgb',
                        notation: 'func',
                        type: type,
                    },
                    stringifier: createFunctionalRgbColorFormatter(type),
                },
                {
                    format: {
                        alpha: true,
                        mode: 'rgb',
                        notation: 'func',
                        type: type,
                    },
                    stringifier: createFunctionalRgbaColorFormatter(type),
                },
                {
                    format: {
                        alpha: false,
                        mode: 'rgb',
                        notation: 'object',
                        type: type,
                    },
                    stringifier: createObjectRgbColorFormatter(type),
                },
                {
                    format: {
                        alpha: true,
                        mode: 'rgb',
                        notation: 'object',
                        type: type,
                    },
                    stringifier: createObjectRgbaColorFormatter(type),
                },
            ];
        }, []),
    ];

    class SourceLocation {
      constructor(lexer, start, end) {
        this.lexer = void 0;
        this.start = void 0;
        this.end = void 0;
        this.lexer = lexer;
        this.start = start;
        this.end = end;
      }
      static range(first, second) {
        if (!second) {
          return first && first.loc;
        } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
          return null;
        } else {
          return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
        }
      }
    }
    class Token {
      constructor(text,
      loc) {
        this.text = void 0;
        this.loc = void 0;
        this.noexpand = void 0;
        this.treatAsRelax = void 0;
        this.text = text;
        this.loc = loc;
      }
      range(endToken,
      text
      ) {
        return new Token(text, SourceLocation.range(this, endToken));
      }
    }
    class ParseError {
      constructor(message,
      token
      ) {
        this.position = void 0;
        var error = "KaTeX parse error: " + message;
        var start;
        var loc = token && token.loc;
        if (loc && loc.start <= loc.end) {
          var input = loc.lexer.input;
          start = loc.start;
          var end = loc.end;
          if (start === input.length) {
            error += " at end of input: ";
          } else {
            error += " at position " + (start + 1) + ": ";
          }
          var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");
          var left;
          if (start > 15) {
            left = "" + input.slice(start - 15, start);
          } else {
            left = input.slice(0, start);
          }
          var right;
          if (end + 15 < input.length) {
            right = input.slice(end, end + 15) + "";
          } else {
            right = input.slice(end);
          }
          error += left + underlined + right;
        }
        var self = new Error(error);
        self.name = "ParseError";
        self.__proto__ = ParseError.prototype;
        self.position = start;
        return self;
      }
    }
    ParseError.prototype.__proto__ = Error.prototype;
    var contains = function contains(list, elem) {
      return list.indexOf(elem) !== -1;
    };
    var deflt = function deflt(setting, defaultIfUndefined) {
      return setting === undefined ? defaultIfUndefined : setting;
    };
    var uppercase = /([A-Z])/g;
    var hyphenate = function hyphenate(str) {
      return str.replace(uppercase, "-$1").toLowerCase();
    };
    var ESCAPE_LOOKUP = {
      "&": "&amp;",
      ">": "&gt;",
      "<": "&lt;",
      "\"": "&quot;",
      "'": "&#x27;"
    };
    var ESCAPE_REGEX = /[&><"']/g;
    function escape$1(text) {
      return String(text).replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);
    }
    var getBaseElem = function getBaseElem(group) {
      if (group.type === "ordgroup") {
        if (group.body.length === 1) {
          return getBaseElem(group.body[0]);
        } else {
          return group;
        }
      } else if (group.type === "color") {
        if (group.body.length === 1) {
          return getBaseElem(group.body[0]);
        } else {
          return group;
        }
      } else if (group.type === "font") {
        return getBaseElem(group.body);
      } else {
        return group;
      }
    };
    var isCharacterBox = function isCharacterBox(group) {
      var baseElem = getBaseElem(group);
      return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
    };
    var assert = function assert(value) {
      if (!value) {
        throw new Error('Expected non-null, but got ' + String(value));
      }
      return value;
    };
    var protocolFromUrl = function protocolFromUrl(url) {
      var protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
      return protocol != null ? protocol[1] : "_relative";
    };
    var utils = {
      contains,
      deflt,
      escape: escape$1,
      hyphenate,
      getBaseElem,
      isCharacterBox,
      protocolFromUrl
    };
    var SETTINGS_SCHEMA = {
      displayMode: {
        type: "boolean",
        description: "Render math in display mode, which puts the math in " + "display style (so \\int and \\sum are large, for example), and " + "centers the math on the page on its own line.",
        cli: "-d, --display-mode"
      },
      output: {
        type: {
          enum: ["htmlAndMathml", "html", "mathml"]
        },
        description: "Determines the markup language of the output.",
        cli: "-F, --format <type>"
      },
      leqno: {
        type: "boolean",
        description: "Render display math in leqno style (left-justified tags)."
      },
      fleqn: {
        type: "boolean",
        description: "Render display math flush left."
      },
      throwOnError: {
        type: "boolean",
        default: true,
        cli: "-t, --no-throw-on-error",
        cliDescription: "Render errors (in the color given by --error-color) ins" + "tead of throwing a ParseError exception when encountering an error."
      },
      errorColor: {
        type: "string",
        default: "#cc0000",
        cli: "-c, --error-color <color>",
        cliDescription: "A color string given in the format 'rgb' or 'rrggbb' " + "(no #). This option determines the color of errors rendered by the " + "-t option.",
        cliProcessor: color => "#" + color
      },
      macros: {
        type: "object",
        cli: "-m, --macro <def>",
        cliDescription: "Define custom macro of the form '\\foo:expansion' (use " + "multiple -m arguments for multiple macros).",
        cliDefault: [],
        cliProcessor: (def, defs) => {
          defs.push(def);
          return defs;
        }
      },
      minRuleThickness: {
        type: "number",
        description: "Specifies a minimum thickness, in ems, for fraction lines," + " `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, " + "`\\hdashline`, `\\underline`, `\\overline`, and the borders of " + "`\\fbox`, `\\boxed`, and `\\fcolorbox`.",
        processor: t => Math.max(0, t),
        cli: "--min-rule-thickness <size>",
        cliProcessor: parseFloat
      },
      colorIsTextColor: {
        type: "boolean",
        description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, " + "instead of LaTeX's one-argument \\color mode change.",
        cli: "-b, --color-is-text-color"
      },
      strict: {
        type: [{
          enum: ["warn", "ignore", "error"]
        }, "boolean", "function"],
        description: "Turn on strict / LaTeX faithfulness mode, which throws an " + "error if the input uses features that are not supported by LaTeX.",
        cli: "-S, --strict",
        cliDefault: false
      },
      trust: {
        type: ["boolean", "function"],
        description: "Trust the input, enabling all HTML features such as \\url.",
        cli: "-T, --trust"
      },
      maxSize: {
        type: "number",
        default: Infinity,
        description: "If non-zero, all user-specified sizes, e.g. in " + "\\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, " + "elements and spaces can be arbitrarily large",
        processor: s => Math.max(0, s),
        cli: "-s, --max-size <n>",
        cliProcessor: parseInt
      },
      maxExpand: {
        type: "number",
        default: 1000,
        description: "Limit the number of macro expansions to the specified " + "number, to prevent e.g. infinite macro loops. If set to Infinity, " + "the macro expander will try to fully expand as in LaTeX.",
        processor: n => Math.max(0, n),
        cli: "-e, --max-expand <n>",
        cliProcessor: n => n === "Infinity" ? Infinity : parseInt(n)
      },
      globalGroup: {
        type: "boolean",
        cli: false
      }
    };
    function getDefaultValue(schema) {
      if (schema.default) {
        return schema.default;
      }
      var type = schema.type;
      var defaultType = Array.isArray(type) ? type[0] : type;
      if (typeof defaultType !== 'string') {
        return defaultType.enum[0];
      }
      switch (defaultType) {
        case 'boolean':
          return false;
        case 'string':
          return '';
        case 'number':
          return 0;
        case 'object':
          return {};
      }
    }
    class Settings {
      constructor(options) {
        this.displayMode = void 0;
        this.output = void 0;
        this.leqno = void 0;
        this.fleqn = void 0;
        this.throwOnError = void 0;
        this.errorColor = void 0;
        this.macros = void 0;
        this.minRuleThickness = void 0;
        this.colorIsTextColor = void 0;
        this.strict = void 0;
        this.trust = void 0;
        this.maxSize = void 0;
        this.maxExpand = void 0;
        this.globalGroup = void 0;
        options = options || {};
        for (var prop in SETTINGS_SCHEMA) {
          if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
            var schema = SETTINGS_SCHEMA[prop];
            this[prop] = options[prop] !== undefined ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
          }
        }
      }
      reportNonstrict(errorCode, errorMsg, token) {
        var strict = this.strict;
        if (typeof strict === "function") {
          strict = strict(errorCode, errorMsg, token);
        }
        if (!strict || strict === "ignore") {
          return;
        } else if (strict === true || strict === "error") {
          throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
        } else if (strict === "warn") {
          typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
        } else {
          typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
        }
      }
      useStrictBehavior(errorCode, errorMsg, token) {
        var strict = this.strict;
        if (typeof strict === "function") {
          try {
            strict = strict(errorCode, errorMsg, token);
          } catch (error) {
            strict = "error";
          }
        }
        if (!strict || strict === "ignore") {
          return false;
        } else if (strict === true || strict === "error") {
          return true;
        } else if (strict === "warn") {
          typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
          return false;
        } else {
          typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
          return false;
        }
      }
      isTrusted(context) {
        if (context.url && !context.protocol) {
          context.protocol = utils.protocolFromUrl(context.url);
        }
        var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
        return Boolean(trust);
      }
    }
    class Style {
      constructor(id, size, cramped) {
        this.id = void 0;
        this.size = void 0;
        this.cramped = void 0;
        this.id = id;
        this.size = size;
        this.cramped = cramped;
      }
      sup() {
        return styles[sup[this.id]];
      }
      sub() {
        return styles[sub[this.id]];
      }
      fracNum() {
        return styles[fracNum[this.id]];
      }
      fracDen() {
        return styles[fracDen[this.id]];
      }
      cramp() {
        return styles[cramp[this.id]];
      }
      text() {
        return styles[text$1[this.id]];
      }
      isTight() {
        return this.size >= 2;
      }
    }
    var D = 0;
    var Dc = 1;
    var T = 2;
    var Tc = 3;
    var S = 4;
    var Sc = 5;
    var SS = 6;
    var SSc = 7;
    var styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
    var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
    var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
    var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
    var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
    var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
    var text$1 = [D, Dc, T, Tc, T, Tc, T, Tc];
    var Style$1 = {
      DISPLAY: styles[D],
      TEXT: styles[T],
      SCRIPT: styles[S],
      SCRIPTSCRIPT: styles[SS]
    };
    var scriptData = [{
      name: 'latin',
      blocks: [[0x0100, 0x024f],
      [0x0300, 0x036f]
      ]
    }, {
      name: 'cyrillic',
      blocks: [[0x0400, 0x04ff]]
    }, {
      name: 'armenian',
      blocks: [[0x0530, 0x058F]]
    }, {
      name: 'brahmic',
      blocks: [[0x0900, 0x109F]]
    }, {
      name: 'georgian',
      blocks: [[0x10A0, 0x10ff]]
    }, {
      name: "cjk",
      blocks: [[0x3000, 0x30FF],
      [0x4E00, 0x9FAF],
      [0xFF00, 0xFF60]
      ]
    }, {
      name: 'hangul',
      blocks: [[0xAC00, 0xD7AF]]
    }];
    function scriptFromCodepoint(codepoint) {
      for (var i = 0; i < scriptData.length; i++) {
        var script = scriptData[i];
        for (var _i = 0; _i < script.blocks.length; _i++) {
          var block = script.blocks[_i];
          if (codepoint >= block[0] && codepoint <= block[1]) {
            return script.name;
          }
        }
      }
      return null;
    }
    var allBlocks = [];
    scriptData.forEach(s => s.blocks.forEach(b => allBlocks.push(...b)));
    function supportedCodepoint(codepoint) {
      for (var i = 0; i < allBlocks.length; i += 2) {
        if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
          return true;
        }
      }
      return false;
    }
    var hLinePad = 80;
    var sqrtMain = function sqrtMain(extraViniculum, hLinePad) {
      return "M95," + (622 + extraViniculum + hLinePad) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraViniculum / 2.075 + " -" + extraViniculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraViniculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraViniculum) + " " + hLinePad + "h400000v" + (40 + extraViniculum) + "h-400000z";
    };
    var sqrtSize1 = function sqrtSize1(extraViniculum, hLinePad) {
      return "M263," + (601 + extraViniculum + hLinePad) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraViniculum / 2.084 + " -" + extraViniculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraViniculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraViniculum) + " " + hLinePad + "h400000v" + (40 + extraViniculum) + "h-400000z";
    };
    var sqrtSize2 = function sqrtSize2(extraViniculum, hLinePad) {
      return "M983 " + (10 + extraViniculum + hLinePad) + "\nl" + extraViniculum / 3.13 + " -" + extraViniculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraViniculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraViniculum) + " " + hLinePad + "h400000v" + (40 + extraViniculum) + "h-400000z";
    };
    var sqrtSize3 = function sqrtSize3(extraViniculum, hLinePad) {
      return "M424," + (2398 + extraViniculum + hLinePad) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraViniculum / 4.223 + " -" + extraViniculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraViniculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraViniculum) + " " + hLinePad + "\nh400000v" + (40 + extraViniculum) + "h-400000z";
    };
    var sqrtSize4 = function sqrtSize4(extraViniculum, hLinePad) {
      return "M473," + (2713 + extraViniculum + hLinePad) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraViniculum / 5.298 + " -" + extraViniculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraViniculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraViniculum) + " " + hLinePad + "h400000v" + (40 + extraViniculum) + "H1017.7z";
    };
    var phasePath = function phasePath(y) {
      var x = y / 2;
      return "M400000 " + y + " H0 L" + x + " 0 l65 45 L145 " + (y - 80) + " H400000z";
    };
    var sqrtTall = function sqrtTall(extraViniculum, hLinePad, viewBoxHeight) {
      var vertSegment = viewBoxHeight - 54 - hLinePad - extraViniculum;
      return "M702 " + (extraViniculum + hLinePad) + "H400000" + (40 + extraViniculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad + "H400000v" + (40 + extraViniculum) + "H742z";
    };
    var sqrtPath = function sqrtPath(size, extraViniculum, viewBoxHeight) {
      extraViniculum = 1000 * extraViniculum;
      var path = "";
      switch (size) {
        case "sqrtMain":
          path = sqrtMain(extraViniculum, hLinePad);
          break;
        case "sqrtSize1":
          path = sqrtSize1(extraViniculum, hLinePad);
          break;
        case "sqrtSize2":
          path = sqrtSize2(extraViniculum, hLinePad);
          break;
        case "sqrtSize3":
          path = sqrtSize3(extraViniculum, hLinePad);
          break;
        case "sqrtSize4":
          path = sqrtSize4(extraViniculum, hLinePad);
          break;
        case "sqrtTall":
          path = sqrtTall(extraViniculum, hLinePad, viewBoxHeight);
      }
      return path;
    };
    var innerPath = function innerPath(name, height) {
      switch (name) {
        case "\u239c":
          return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
        case "\u2223":
          return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
        case "\u2225":
          return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
        case "\u239f":
          return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
        case "\u23a2":
          return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
        case "\u23a5":
          return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
        case "\u23aa":
          return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
        case "\u23d0":
          return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
        case "\u2016":
          return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
        default:
          return "";
      }
    };
    var path = {
      doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
      doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
      leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
      leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
      leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
      leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
      leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
      leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
      leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
      leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
      leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
      lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
      leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
      leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
      leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
      longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
      midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
      midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
      oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
      oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
      oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
      oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
      rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
      rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
      rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
      rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
      rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
      rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
      rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
      rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
      rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
      righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
      rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
      rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
      twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
      twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
      tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
      tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
      tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
      tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
      vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
      widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
      widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
      widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
      widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
      widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
      widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
      widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
      widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
      baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
      rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
      baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
      rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
      shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
      shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
    };
    var tallDelim = function tallDelim(label, midHeight) {
      switch (label) {
        case "lbrack":
          return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
        case "rbrack":
          return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
        case "vert":
          return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
        case "doublevert":
          return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
        case "lfloor":
          return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
        case "rfloor":
          return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
        case "lceil":
          return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
        case "rceil":
          return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
        case "lparen":
          return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
        case "rparen":
          return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
        default:
          throw new Error("Unknown stretchy delimiter.");
      }
    };
    class DocumentFragment {
      constructor(children) {
        this.children = void 0;
        this.classes = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.maxFontSize = void 0;
        this.style = void 0;
        this.children = children;
        this.classes = [];
        this.height = 0;
        this.depth = 0;
        this.maxFontSize = 0;
        this.style = {};
      }
      hasClass(className) {
        return utils.contains(this.classes, className);
      }
      toNode() {
        var frag = document.createDocumentFragment();
        for (var i = 0; i < this.children.length; i++) {
          frag.appendChild(this.children[i].toNode());
        }
        return frag;
      }
      toMarkup() {
        var markup = "";
        for (var i = 0; i < this.children.length; i++) {
          markup += this.children[i].toMarkup();
        }
        return markup;
      }
      toText() {
        var toText = child => child.toText();
        return this.children.map(toText).join("");
      }
    }
    var fontMetricsData = {
      "AMS-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "65": [0, 0.68889, 0, 0, 0.72222],
        "66": [0, 0.68889, 0, 0, 0.66667],
        "67": [0, 0.68889, 0, 0, 0.72222],
        "68": [0, 0.68889, 0, 0, 0.72222],
        "69": [0, 0.68889, 0, 0, 0.66667],
        "70": [0, 0.68889, 0, 0, 0.61111],
        "71": [0, 0.68889, 0, 0, 0.77778],
        "72": [0, 0.68889, 0, 0, 0.77778],
        "73": [0, 0.68889, 0, 0, 0.38889],
        "74": [0.16667, 0.68889, 0, 0, 0.5],
        "75": [0, 0.68889, 0, 0, 0.77778],
        "76": [0, 0.68889, 0, 0, 0.66667],
        "77": [0, 0.68889, 0, 0, 0.94445],
        "78": [0, 0.68889, 0, 0, 0.72222],
        "79": [0.16667, 0.68889, 0, 0, 0.77778],
        "80": [0, 0.68889, 0, 0, 0.61111],
        "81": [0.16667, 0.68889, 0, 0, 0.77778],
        "82": [0, 0.68889, 0, 0, 0.72222],
        "83": [0, 0.68889, 0, 0, 0.55556],
        "84": [0, 0.68889, 0, 0, 0.66667],
        "85": [0, 0.68889, 0, 0, 0.72222],
        "86": [0, 0.68889, 0, 0, 0.72222],
        "87": [0, 0.68889, 0, 0, 1.0],
        "88": [0, 0.68889, 0, 0, 0.72222],
        "89": [0, 0.68889, 0, 0, 0.72222],
        "90": [0, 0.68889, 0, 0, 0.66667],
        "107": [0, 0.68889, 0, 0, 0.55556],
        "160": [0, 0, 0, 0, 0.25],
        "165": [0, 0.675, 0.025, 0, 0.75],
        "174": [0.15559, 0.69224, 0, 0, 0.94666],
        "240": [0, 0.68889, 0, 0, 0.55556],
        "295": [0, 0.68889, 0, 0, 0.54028],
        "710": [0, 0.825, 0, 0, 2.33334],
        "732": [0, 0.9, 0, 0, 2.33334],
        "770": [0, 0.825, 0, 0, 2.33334],
        "771": [0, 0.9, 0, 0, 2.33334],
        "989": [0.08167, 0.58167, 0, 0, 0.77778],
        "1008": [0, 0.43056, 0.04028, 0, 0.66667],
        "8245": [0, 0.54986, 0, 0, 0.275],
        "8463": [0, 0.68889, 0, 0, 0.54028],
        "8487": [0, 0.68889, 0, 0, 0.72222],
        "8498": [0, 0.68889, 0, 0, 0.55556],
        "8502": [0, 0.68889, 0, 0, 0.66667],
        "8503": [0, 0.68889, 0, 0, 0.44445],
        "8504": [0, 0.68889, 0, 0, 0.66667],
        "8513": [0, 0.68889, 0, 0, 0.63889],
        "8592": [-0.03598, 0.46402, 0, 0, 0.5],
        "8594": [-0.03598, 0.46402, 0, 0, 0.5],
        "8602": [-0.13313, 0.36687, 0, 0, 1.0],
        "8603": [-0.13313, 0.36687, 0, 0, 1.0],
        "8606": [0.01354, 0.52239, 0, 0, 1.0],
        "8608": [0.01354, 0.52239, 0, 0, 1.0],
        "8610": [0.01354, 0.52239, 0, 0, 1.11111],
        "8611": [0.01354, 0.52239, 0, 0, 1.11111],
        "8619": [0, 0.54986, 0, 0, 1.0],
        "8620": [0, 0.54986, 0, 0, 1.0],
        "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
        "8622": [-0.13313, 0.36687, 0, 0, 1.0],
        "8624": [0, 0.69224, 0, 0, 0.5],
        "8625": [0, 0.69224, 0, 0, 0.5],
        "8630": [0, 0.43056, 0, 0, 1.0],
        "8631": [0, 0.43056, 0, 0, 1.0],
        "8634": [0.08198, 0.58198, 0, 0, 0.77778],
        "8635": [0.08198, 0.58198, 0, 0, 0.77778],
        "8638": [0.19444, 0.69224, 0, 0, 0.41667],
        "8639": [0.19444, 0.69224, 0, 0, 0.41667],
        "8642": [0.19444, 0.69224, 0, 0, 0.41667],
        "8643": [0.19444, 0.69224, 0, 0, 0.41667],
        "8644": [0.1808, 0.675, 0, 0, 1.0],
        "8646": [0.1808, 0.675, 0, 0, 1.0],
        "8647": [0.1808, 0.675, 0, 0, 1.0],
        "8648": [0.19444, 0.69224, 0, 0, 0.83334],
        "8649": [0.1808, 0.675, 0, 0, 1.0],
        "8650": [0.19444, 0.69224, 0, 0, 0.83334],
        "8651": [0.01354, 0.52239, 0, 0, 1.0],
        "8652": [0.01354, 0.52239, 0, 0, 1.0],
        "8653": [-0.13313, 0.36687, 0, 0, 1.0],
        "8654": [-0.13313, 0.36687, 0, 0, 1.0],
        "8655": [-0.13313, 0.36687, 0, 0, 1.0],
        "8666": [0.13667, 0.63667, 0, 0, 1.0],
        "8667": [0.13667, 0.63667, 0, 0, 1.0],
        "8669": [-0.13313, 0.37788, 0, 0, 1.0],
        "8672": [-0.064, 0.437, 0, 0, 1.334],
        "8674": [-0.064, 0.437, 0, 0, 1.334],
        "8705": [0, 0.825, 0, 0, 0.5],
        "8708": [0, 0.68889, 0, 0, 0.55556],
        "8709": [0.08167, 0.58167, 0, 0, 0.77778],
        "8717": [0, 0.43056, 0, 0, 0.42917],
        "8722": [-0.03598, 0.46402, 0, 0, 0.5],
        "8724": [0.08198, 0.69224, 0, 0, 0.77778],
        "8726": [0.08167, 0.58167, 0, 0, 0.77778],
        "8733": [0, 0.69224, 0, 0, 0.77778],
        "8736": [0, 0.69224, 0, 0, 0.72222],
        "8737": [0, 0.69224, 0, 0, 0.72222],
        "8738": [0.03517, 0.52239, 0, 0, 0.72222],
        "8739": [0.08167, 0.58167, 0, 0, 0.22222],
        "8740": [0.25142, 0.74111, 0, 0, 0.27778],
        "8741": [0.08167, 0.58167, 0, 0, 0.38889],
        "8742": [0.25142, 0.74111, 0, 0, 0.5],
        "8756": [0, 0.69224, 0, 0, 0.66667],
        "8757": [0, 0.69224, 0, 0, 0.66667],
        "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
        "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
        "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
        "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
        "8774": [0.30274, 0.79383, 0, 0, 0.77778],
        "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
        "8778": [0.08167, 0.58167, 0, 0, 0.77778],
        "8782": [0.06062, 0.54986, 0, 0, 0.77778],
        "8783": [0.06062, 0.54986, 0, 0, 0.77778],
        "8785": [0.08198, 0.58198, 0, 0, 0.77778],
        "8786": [0.08198, 0.58198, 0, 0, 0.77778],
        "8787": [0.08198, 0.58198, 0, 0, 0.77778],
        "8790": [0, 0.69224, 0, 0, 0.77778],
        "8791": [0.22958, 0.72958, 0, 0, 0.77778],
        "8796": [0.08198, 0.91667, 0, 0, 0.77778],
        "8806": [0.25583, 0.75583, 0, 0, 0.77778],
        "8807": [0.25583, 0.75583, 0, 0, 0.77778],
        "8808": [0.25142, 0.75726, 0, 0, 0.77778],
        "8809": [0.25142, 0.75726, 0, 0, 0.77778],
        "8812": [0.25583, 0.75583, 0, 0, 0.5],
        "8814": [0.20576, 0.70576, 0, 0, 0.77778],
        "8815": [0.20576, 0.70576, 0, 0, 0.77778],
        "8816": [0.30274, 0.79383, 0, 0, 0.77778],
        "8817": [0.30274, 0.79383, 0, 0, 0.77778],
        "8818": [0.22958, 0.72958, 0, 0, 0.77778],
        "8819": [0.22958, 0.72958, 0, 0, 0.77778],
        "8822": [0.1808, 0.675, 0, 0, 0.77778],
        "8823": [0.1808, 0.675, 0, 0, 0.77778],
        "8828": [0.13667, 0.63667, 0, 0, 0.77778],
        "8829": [0.13667, 0.63667, 0, 0, 0.77778],
        "8830": [0.22958, 0.72958, 0, 0, 0.77778],
        "8831": [0.22958, 0.72958, 0, 0, 0.77778],
        "8832": [0.20576, 0.70576, 0, 0, 0.77778],
        "8833": [0.20576, 0.70576, 0, 0, 0.77778],
        "8840": [0.30274, 0.79383, 0, 0, 0.77778],
        "8841": [0.30274, 0.79383, 0, 0, 0.77778],
        "8842": [0.13597, 0.63597, 0, 0, 0.77778],
        "8843": [0.13597, 0.63597, 0, 0, 0.77778],
        "8847": [0.03517, 0.54986, 0, 0, 0.77778],
        "8848": [0.03517, 0.54986, 0, 0, 0.77778],
        "8858": [0.08198, 0.58198, 0, 0, 0.77778],
        "8859": [0.08198, 0.58198, 0, 0, 0.77778],
        "8861": [0.08198, 0.58198, 0, 0, 0.77778],
        "8862": [0, 0.675, 0, 0, 0.77778],
        "8863": [0, 0.675, 0, 0, 0.77778],
        "8864": [0, 0.675, 0, 0, 0.77778],
        "8865": [0, 0.675, 0, 0, 0.77778],
        "8872": [0, 0.69224, 0, 0, 0.61111],
        "8873": [0, 0.69224, 0, 0, 0.72222],
        "8874": [0, 0.69224, 0, 0, 0.88889],
        "8876": [0, 0.68889, 0, 0, 0.61111],
        "8877": [0, 0.68889, 0, 0, 0.61111],
        "8878": [0, 0.68889, 0, 0, 0.72222],
        "8879": [0, 0.68889, 0, 0, 0.72222],
        "8882": [0.03517, 0.54986, 0, 0, 0.77778],
        "8883": [0.03517, 0.54986, 0, 0, 0.77778],
        "8884": [0.13667, 0.63667, 0, 0, 0.77778],
        "8885": [0.13667, 0.63667, 0, 0, 0.77778],
        "8888": [0, 0.54986, 0, 0, 1.11111],
        "8890": [0.19444, 0.43056, 0, 0, 0.55556],
        "8891": [0.19444, 0.69224, 0, 0, 0.61111],
        "8892": [0.19444, 0.69224, 0, 0, 0.61111],
        "8901": [0, 0.54986, 0, 0, 0.27778],
        "8903": [0.08167, 0.58167, 0, 0, 0.77778],
        "8905": [0.08167, 0.58167, 0, 0, 0.77778],
        "8906": [0.08167, 0.58167, 0, 0, 0.77778],
        "8907": [0, 0.69224, 0, 0, 0.77778],
        "8908": [0, 0.69224, 0, 0, 0.77778],
        "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
        "8910": [0, 0.54986, 0, 0, 0.76042],
        "8911": [0, 0.54986, 0, 0, 0.76042],
        "8912": [0.03517, 0.54986, 0, 0, 0.77778],
        "8913": [0.03517, 0.54986, 0, 0, 0.77778],
        "8914": [0, 0.54986, 0, 0, 0.66667],
        "8915": [0, 0.54986, 0, 0, 0.66667],
        "8916": [0, 0.69224, 0, 0, 0.66667],
        "8918": [0.0391, 0.5391, 0, 0, 0.77778],
        "8919": [0.0391, 0.5391, 0, 0, 0.77778],
        "8920": [0.03517, 0.54986, 0, 0, 1.33334],
        "8921": [0.03517, 0.54986, 0, 0, 1.33334],
        "8922": [0.38569, 0.88569, 0, 0, 0.77778],
        "8923": [0.38569, 0.88569, 0, 0, 0.77778],
        "8926": [0.13667, 0.63667, 0, 0, 0.77778],
        "8927": [0.13667, 0.63667, 0, 0, 0.77778],
        "8928": [0.30274, 0.79383, 0, 0, 0.77778],
        "8929": [0.30274, 0.79383, 0, 0, 0.77778],
        "8934": [0.23222, 0.74111, 0, 0, 0.77778],
        "8935": [0.23222, 0.74111, 0, 0, 0.77778],
        "8936": [0.23222, 0.74111, 0, 0, 0.77778],
        "8937": [0.23222, 0.74111, 0, 0, 0.77778],
        "8938": [0.20576, 0.70576, 0, 0, 0.77778],
        "8939": [0.20576, 0.70576, 0, 0, 0.77778],
        "8940": [0.30274, 0.79383, 0, 0, 0.77778],
        "8941": [0.30274, 0.79383, 0, 0, 0.77778],
        "8994": [0.19444, 0.69224, 0, 0, 0.77778],
        "8995": [0.19444, 0.69224, 0, 0, 0.77778],
        "9416": [0.15559, 0.69224, 0, 0, 0.90222],
        "9484": [0, 0.69224, 0, 0, 0.5],
        "9488": [0, 0.69224, 0, 0, 0.5],
        "9492": [0, 0.37788, 0, 0, 0.5],
        "9496": [0, 0.37788, 0, 0, 0.5],
        "9585": [0.19444, 0.68889, 0, 0, 0.88889],
        "9586": [0.19444, 0.74111, 0, 0, 0.88889],
        "9632": [0, 0.675, 0, 0, 0.77778],
        "9633": [0, 0.675, 0, 0, 0.77778],
        "9650": [0, 0.54986, 0, 0, 0.72222],
        "9651": [0, 0.54986, 0, 0, 0.72222],
        "9654": [0.03517, 0.54986, 0, 0, 0.77778],
        "9660": [0, 0.54986, 0, 0, 0.72222],
        "9661": [0, 0.54986, 0, 0, 0.72222],
        "9664": [0.03517, 0.54986, 0, 0, 0.77778],
        "9674": [0.11111, 0.69224, 0, 0, 0.66667],
        "9733": [0.19444, 0.69224, 0, 0, 0.94445],
        "10003": [0, 0.69224, 0, 0, 0.83334],
        "10016": [0, 0.69224, 0, 0, 0.83334],
        "10731": [0.11111, 0.69224, 0, 0, 0.66667],
        "10846": [0.19444, 0.75583, 0, 0, 0.61111],
        "10877": [0.13667, 0.63667, 0, 0, 0.77778],
        "10878": [0.13667, 0.63667, 0, 0, 0.77778],
        "10885": [0.25583, 0.75583, 0, 0, 0.77778],
        "10886": [0.25583, 0.75583, 0, 0, 0.77778],
        "10887": [0.13597, 0.63597, 0, 0, 0.77778],
        "10888": [0.13597, 0.63597, 0, 0, 0.77778],
        "10889": [0.26167, 0.75726, 0, 0, 0.77778],
        "10890": [0.26167, 0.75726, 0, 0, 0.77778],
        "10891": [0.48256, 0.98256, 0, 0, 0.77778],
        "10892": [0.48256, 0.98256, 0, 0, 0.77778],
        "10901": [0.13667, 0.63667, 0, 0, 0.77778],
        "10902": [0.13667, 0.63667, 0, 0, 0.77778],
        "10933": [0.25142, 0.75726, 0, 0, 0.77778],
        "10934": [0.25142, 0.75726, 0, 0, 0.77778],
        "10935": [0.26167, 0.75726, 0, 0, 0.77778],
        "10936": [0.26167, 0.75726, 0, 0, 0.77778],
        "10937": [0.26167, 0.75726, 0, 0, 0.77778],
        "10938": [0.26167, 0.75726, 0, 0, 0.77778],
        "10949": [0.25583, 0.75583, 0, 0, 0.77778],
        "10950": [0.25583, 0.75583, 0, 0, 0.77778],
        "10955": [0.28481, 0.79383, 0, 0, 0.77778],
        "10956": [0.28481, 0.79383, 0, 0, 0.77778],
        "57350": [0.08167, 0.58167, 0, 0, 0.22222],
        "57351": [0.08167, 0.58167, 0, 0, 0.38889],
        "57352": [0.08167, 0.58167, 0, 0, 0.77778],
        "57353": [0, 0.43056, 0.04028, 0, 0.66667],
        "57356": [0.25142, 0.75726, 0, 0, 0.77778],
        "57357": [0.25142, 0.75726, 0, 0, 0.77778],
        "57358": [0.41951, 0.91951, 0, 0, 0.77778],
        "57359": [0.30274, 0.79383, 0, 0, 0.77778],
        "57360": [0.30274, 0.79383, 0, 0, 0.77778],
        "57361": [0.41951, 0.91951, 0, 0, 0.77778],
        "57366": [0.25142, 0.75726, 0, 0, 0.77778],
        "57367": [0.25142, 0.75726, 0, 0, 0.77778],
        "57368": [0.25142, 0.75726, 0, 0, 0.77778],
        "57369": [0.25142, 0.75726, 0, 0, 0.77778],
        "57370": [0.13597, 0.63597, 0, 0, 0.77778],
        "57371": [0.13597, 0.63597, 0, 0, 0.77778]
      },
      "Caligraphic-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "65": [0, 0.68333, 0, 0.19445, 0.79847],
        "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
        "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
        "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
        "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
        "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
        "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
        "72": [0, 0.68333, 0.00965, 0.11111, 0.84452],
        "73": [0, 0.68333, 0.07382, 0, 0.54452],
        "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
        "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
        "76": [0, 0.68333, 0, 0.13889, 0.68972],
        "77": [0, 0.68333, 0, 0.13889, 1.2009],
        "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
        "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
        "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
        "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
        "82": [0, 0.68333, 0, 0.08334, 0.8475],
        "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
        "84": [0, 0.68333, 0.25417, 0, 0.54464],
        "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
        "86": [0, 0.68333, 0.08222, 0, 0.61278],
        "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
        "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
        "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
        "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
        "160": [0, 0, 0, 0, 0.25]
      },
      "Fraktur-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69141, 0, 0, 0.29574],
        "34": [0, 0.69141, 0, 0, 0.21471],
        "38": [0, 0.69141, 0, 0, 0.73786],
        "39": [0, 0.69141, 0, 0, 0.21201],
        "40": [0.24982, 0.74947, 0, 0, 0.38865],
        "41": [0.24982, 0.74947, 0, 0, 0.38865],
        "42": [0, 0.62119, 0, 0, 0.27764],
        "43": [0.08319, 0.58283, 0, 0, 0.75623],
        "44": [0, 0.10803, 0, 0, 0.27764],
        "45": [0.08319, 0.58283, 0, 0, 0.75623],
        "46": [0, 0.10803, 0, 0, 0.27764],
        "47": [0.24982, 0.74947, 0, 0, 0.50181],
        "48": [0, 0.47534, 0, 0, 0.50181],
        "49": [0, 0.47534, 0, 0, 0.50181],
        "50": [0, 0.47534, 0, 0, 0.50181],
        "51": [0.18906, 0.47534, 0, 0, 0.50181],
        "52": [0.18906, 0.47534, 0, 0, 0.50181],
        "53": [0.18906, 0.47534, 0, 0, 0.50181],
        "54": [0, 0.69141, 0, 0, 0.50181],
        "55": [0.18906, 0.47534, 0, 0, 0.50181],
        "56": [0, 0.69141, 0, 0, 0.50181],
        "57": [0.18906, 0.47534, 0, 0, 0.50181],
        "58": [0, 0.47534, 0, 0, 0.21606],
        "59": [0.12604, 0.47534, 0, 0, 0.21606],
        "61": [-0.13099, 0.36866, 0, 0, 0.75623],
        "63": [0, 0.69141, 0, 0, 0.36245],
        "65": [0, 0.69141, 0, 0, 0.7176],
        "66": [0, 0.69141, 0, 0, 0.88397],
        "67": [0, 0.69141, 0, 0, 0.61254],
        "68": [0, 0.69141, 0, 0, 0.83158],
        "69": [0, 0.69141, 0, 0, 0.66278],
        "70": [0.12604, 0.69141, 0, 0, 0.61119],
        "71": [0, 0.69141, 0, 0, 0.78539],
        "72": [0.06302, 0.69141, 0, 0, 0.7203],
        "73": [0, 0.69141, 0, 0, 0.55448],
        "74": [0.12604, 0.69141, 0, 0, 0.55231],
        "75": [0, 0.69141, 0, 0, 0.66845],
        "76": [0, 0.69141, 0, 0, 0.66602],
        "77": [0, 0.69141, 0, 0, 1.04953],
        "78": [0, 0.69141, 0, 0, 0.83212],
        "79": [0, 0.69141, 0, 0, 0.82699],
        "80": [0.18906, 0.69141, 0, 0, 0.82753],
        "81": [0.03781, 0.69141, 0, 0, 0.82699],
        "82": [0, 0.69141, 0, 0, 0.82807],
        "83": [0, 0.69141, 0, 0, 0.82861],
        "84": [0, 0.69141, 0, 0, 0.66899],
        "85": [0, 0.69141, 0, 0, 0.64576],
        "86": [0, 0.69141, 0, 0, 0.83131],
        "87": [0, 0.69141, 0, 0, 1.04602],
        "88": [0, 0.69141, 0, 0, 0.71922],
        "89": [0.18906, 0.69141, 0, 0, 0.83293],
        "90": [0.12604, 0.69141, 0, 0, 0.60201],
        "91": [0.24982, 0.74947, 0, 0, 0.27764],
        "93": [0.24982, 0.74947, 0, 0, 0.27764],
        "94": [0, 0.69141, 0, 0, 0.49965],
        "97": [0, 0.47534, 0, 0, 0.50046],
        "98": [0, 0.69141, 0, 0, 0.51315],
        "99": [0, 0.47534, 0, 0, 0.38946],
        "100": [0, 0.62119, 0, 0, 0.49857],
        "101": [0, 0.47534, 0, 0, 0.40053],
        "102": [0.18906, 0.69141, 0, 0, 0.32626],
        "103": [0.18906, 0.47534, 0, 0, 0.5037],
        "104": [0.18906, 0.69141, 0, 0, 0.52126],
        "105": [0, 0.69141, 0, 0, 0.27899],
        "106": [0, 0.69141, 0, 0, 0.28088],
        "107": [0, 0.69141, 0, 0, 0.38946],
        "108": [0, 0.69141, 0, 0, 0.27953],
        "109": [0, 0.47534, 0, 0, 0.76676],
        "110": [0, 0.47534, 0, 0, 0.52666],
        "111": [0, 0.47534, 0, 0, 0.48885],
        "112": [0.18906, 0.52396, 0, 0, 0.50046],
        "113": [0.18906, 0.47534, 0, 0, 0.48912],
        "114": [0, 0.47534, 0, 0, 0.38919],
        "115": [0, 0.47534, 0, 0, 0.44266],
        "116": [0, 0.62119, 0, 0, 0.33301],
        "117": [0, 0.47534, 0, 0, 0.5172],
        "118": [0, 0.52396, 0, 0, 0.5118],
        "119": [0, 0.52396, 0, 0, 0.77351],
        "120": [0.18906, 0.47534, 0, 0, 0.38865],
        "121": [0.18906, 0.47534, 0, 0, 0.49884],
        "122": [0.18906, 0.47534, 0, 0, 0.39054],
        "160": [0, 0, 0, 0, 0.25],
        "8216": [0, 0.69141, 0, 0, 0.21471],
        "8217": [0, 0.69141, 0, 0, 0.21471],
        "58112": [0, 0.62119, 0, 0, 0.49749],
        "58113": [0, 0.62119, 0, 0, 0.4983],
        "58114": [0.18906, 0.69141, 0, 0, 0.33328],
        "58115": [0.18906, 0.69141, 0, 0, 0.32923],
        "58116": [0.18906, 0.47534, 0, 0, 0.50343],
        "58117": [0, 0.69141, 0, 0, 0.33301],
        "58118": [0, 0.62119, 0, 0, 0.33409],
        "58119": [0, 0.47534, 0, 0, 0.50073]
      },
      "Main-Bold": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0, 0, 0.35],
        "34": [0, 0.69444, 0, 0, 0.60278],
        "35": [0.19444, 0.69444, 0, 0, 0.95833],
        "36": [0.05556, 0.75, 0, 0, 0.575],
        "37": [0.05556, 0.75, 0, 0, 0.95833],
        "38": [0, 0.69444, 0, 0, 0.89444],
        "39": [0, 0.69444, 0, 0, 0.31944],
        "40": [0.25, 0.75, 0, 0, 0.44722],
        "41": [0.25, 0.75, 0, 0, 0.44722],
        "42": [0, 0.75, 0, 0, 0.575],
        "43": [0.13333, 0.63333, 0, 0, 0.89444],
        "44": [0.19444, 0.15556, 0, 0, 0.31944],
        "45": [0, 0.44444, 0, 0, 0.38333],
        "46": [0, 0.15556, 0, 0, 0.31944],
        "47": [0.25, 0.75, 0, 0, 0.575],
        "48": [0, 0.64444, 0, 0, 0.575],
        "49": [0, 0.64444, 0, 0, 0.575],
        "50": [0, 0.64444, 0, 0, 0.575],
        "51": [0, 0.64444, 0, 0, 0.575],
        "52": [0, 0.64444, 0, 0, 0.575],
        "53": [0, 0.64444, 0, 0, 0.575],
        "54": [0, 0.64444, 0, 0, 0.575],
        "55": [0, 0.64444, 0, 0, 0.575],
        "56": [0, 0.64444, 0, 0, 0.575],
        "57": [0, 0.64444, 0, 0, 0.575],
        "58": [0, 0.44444, 0, 0, 0.31944],
        "59": [0.19444, 0.44444, 0, 0, 0.31944],
        "60": [0.08556, 0.58556, 0, 0, 0.89444],
        "61": [-0.10889, 0.39111, 0, 0, 0.89444],
        "62": [0.08556, 0.58556, 0, 0, 0.89444],
        "63": [0, 0.69444, 0, 0, 0.54305],
        "64": [0, 0.69444, 0, 0, 0.89444],
        "65": [0, 0.68611, 0, 0, 0.86944],
        "66": [0, 0.68611, 0, 0, 0.81805],
        "67": [0, 0.68611, 0, 0, 0.83055],
        "68": [0, 0.68611, 0, 0, 0.88194],
        "69": [0, 0.68611, 0, 0, 0.75555],
        "70": [0, 0.68611, 0, 0, 0.72361],
        "71": [0, 0.68611, 0, 0, 0.90416],
        "72": [0, 0.68611, 0, 0, 0.9],
        "73": [0, 0.68611, 0, 0, 0.43611],
        "74": [0, 0.68611, 0, 0, 0.59444],
        "75": [0, 0.68611, 0, 0, 0.90138],
        "76": [0, 0.68611, 0, 0, 0.69166],
        "77": [0, 0.68611, 0, 0, 1.09166],
        "78": [0, 0.68611, 0, 0, 0.9],
        "79": [0, 0.68611, 0, 0, 0.86388],
        "80": [0, 0.68611, 0, 0, 0.78611],
        "81": [0.19444, 0.68611, 0, 0, 0.86388],
        "82": [0, 0.68611, 0, 0, 0.8625],
        "83": [0, 0.68611, 0, 0, 0.63889],
        "84": [0, 0.68611, 0, 0, 0.8],
        "85": [0, 0.68611, 0, 0, 0.88472],
        "86": [0, 0.68611, 0.01597, 0, 0.86944],
        "87": [0, 0.68611, 0.01597, 0, 1.18888],
        "88": [0, 0.68611, 0, 0, 0.86944],
        "89": [0, 0.68611, 0.02875, 0, 0.86944],
        "90": [0, 0.68611, 0, 0, 0.70277],
        "91": [0.25, 0.75, 0, 0, 0.31944],
        "92": [0.25, 0.75, 0, 0, 0.575],
        "93": [0.25, 0.75, 0, 0, 0.31944],
        "94": [0, 0.69444, 0, 0, 0.575],
        "95": [0.31, 0.13444, 0.03194, 0, 0.575],
        "97": [0, 0.44444, 0, 0, 0.55902],
        "98": [0, 0.69444, 0, 0, 0.63889],
        "99": [0, 0.44444, 0, 0, 0.51111],
        "100": [0, 0.69444, 0, 0, 0.63889],
        "101": [0, 0.44444, 0, 0, 0.52708],
        "102": [0, 0.69444, 0.10903, 0, 0.35139],
        "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
        "104": [0, 0.69444, 0, 0, 0.63889],
        "105": [0, 0.69444, 0, 0, 0.31944],
        "106": [0.19444, 0.69444, 0, 0, 0.35139],
        "107": [0, 0.69444, 0, 0, 0.60694],
        "108": [0, 0.69444, 0, 0, 0.31944],
        "109": [0, 0.44444, 0, 0, 0.95833],
        "110": [0, 0.44444, 0, 0, 0.63889],
        "111": [0, 0.44444, 0, 0, 0.575],
        "112": [0.19444, 0.44444, 0, 0, 0.63889],
        "113": [0.19444, 0.44444, 0, 0, 0.60694],
        "114": [0, 0.44444, 0, 0, 0.47361],
        "115": [0, 0.44444, 0, 0, 0.45361],
        "116": [0, 0.63492, 0, 0, 0.44722],
        "117": [0, 0.44444, 0, 0, 0.63889],
        "118": [0, 0.44444, 0.01597, 0, 0.60694],
        "119": [0, 0.44444, 0.01597, 0, 0.83055],
        "120": [0, 0.44444, 0, 0, 0.60694],
        "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
        "122": [0, 0.44444, 0, 0, 0.51111],
        "123": [0.25, 0.75, 0, 0, 0.575],
        "124": [0.25, 0.75, 0, 0, 0.31944],
        "125": [0.25, 0.75, 0, 0, 0.575],
        "126": [0.35, 0.34444, 0, 0, 0.575],
        "160": [0, 0, 0, 0, 0.25],
        "163": [0, 0.69444, 0, 0, 0.86853],
        "168": [0, 0.69444, 0, 0, 0.575],
        "172": [0, 0.44444, 0, 0, 0.76666],
        "176": [0, 0.69444, 0, 0, 0.86944],
        "177": [0.13333, 0.63333, 0, 0, 0.89444],
        "184": [0.17014, 0, 0, 0, 0.51111],
        "198": [0, 0.68611, 0, 0, 1.04166],
        "215": [0.13333, 0.63333, 0, 0, 0.89444],
        "216": [0.04861, 0.73472, 0, 0, 0.89444],
        "223": [0, 0.69444, 0, 0, 0.59722],
        "230": [0, 0.44444, 0, 0, 0.83055],
        "247": [0.13333, 0.63333, 0, 0, 0.89444],
        "248": [0.09722, 0.54167, 0, 0, 0.575],
        "305": [0, 0.44444, 0, 0, 0.31944],
        "338": [0, 0.68611, 0, 0, 1.16944],
        "339": [0, 0.44444, 0, 0, 0.89444],
        "567": [0.19444, 0.44444, 0, 0, 0.35139],
        "710": [0, 0.69444, 0, 0, 0.575],
        "711": [0, 0.63194, 0, 0, 0.575],
        "713": [0, 0.59611, 0, 0, 0.575],
        "714": [0, 0.69444, 0, 0, 0.575],
        "715": [0, 0.69444, 0, 0, 0.575],
        "728": [0, 0.69444, 0, 0, 0.575],
        "729": [0, 0.69444, 0, 0, 0.31944],
        "730": [0, 0.69444, 0, 0, 0.86944],
        "732": [0, 0.69444, 0, 0, 0.575],
        "733": [0, 0.69444, 0, 0, 0.575],
        "915": [0, 0.68611, 0, 0, 0.69166],
        "916": [0, 0.68611, 0, 0, 0.95833],
        "920": [0, 0.68611, 0, 0, 0.89444],
        "923": [0, 0.68611, 0, 0, 0.80555],
        "926": [0, 0.68611, 0, 0, 0.76666],
        "928": [0, 0.68611, 0, 0, 0.9],
        "931": [0, 0.68611, 0, 0, 0.83055],
        "933": [0, 0.68611, 0, 0, 0.89444],
        "934": [0, 0.68611, 0, 0, 0.83055],
        "936": [0, 0.68611, 0, 0, 0.89444],
        "937": [0, 0.68611, 0, 0, 0.83055],
        "8211": [0, 0.44444, 0.03194, 0, 0.575],
        "8212": [0, 0.44444, 0.03194, 0, 1.14999],
        "8216": [0, 0.69444, 0, 0, 0.31944],
        "8217": [0, 0.69444, 0, 0, 0.31944],
        "8220": [0, 0.69444, 0, 0, 0.60278],
        "8221": [0, 0.69444, 0, 0, 0.60278],
        "8224": [0.19444, 0.69444, 0, 0, 0.51111],
        "8225": [0.19444, 0.69444, 0, 0, 0.51111],
        "8242": [0, 0.55556, 0, 0, 0.34444],
        "8407": [0, 0.72444, 0.15486, 0, 0.575],
        "8463": [0, 0.69444, 0, 0, 0.66759],
        "8465": [0, 0.69444, 0, 0, 0.83055],
        "8467": [0, 0.69444, 0, 0, 0.47361],
        "8472": [0.19444, 0.44444, 0, 0, 0.74027],
        "8476": [0, 0.69444, 0, 0, 0.83055],
        "8501": [0, 0.69444, 0, 0, 0.70277],
        "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8593": [0.19444, 0.69444, 0, 0, 0.575],
        "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8595": [0.19444, 0.69444, 0, 0, 0.575],
        "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8597": [0.25, 0.75, 0, 0, 0.575],
        "8598": [0.19444, 0.69444, 0, 0, 1.14999],
        "8599": [0.19444, 0.69444, 0, 0, 1.14999],
        "8600": [0.19444, 0.69444, 0, 0, 1.14999],
        "8601": [0.19444, 0.69444, 0, 0, 1.14999],
        "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8657": [0.19444, 0.69444, 0, 0, 0.70277],
        "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8659": [0.19444, 0.69444, 0, 0, 0.70277],
        "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8661": [0.25, 0.75, 0, 0, 0.70277],
        "8704": [0, 0.69444, 0, 0, 0.63889],
        "8706": [0, 0.69444, 0.06389, 0, 0.62847],
        "8707": [0, 0.69444, 0, 0, 0.63889],
        "8709": [0.05556, 0.75, 0, 0, 0.575],
        "8711": [0, 0.68611, 0, 0, 0.95833],
        "8712": [0.08556, 0.58556, 0, 0, 0.76666],
        "8715": [0.08556, 0.58556, 0, 0, 0.76666],
        "8722": [0.13333, 0.63333, 0, 0, 0.89444],
        "8723": [0.13333, 0.63333, 0, 0, 0.89444],
        "8725": [0.25, 0.75, 0, 0, 0.575],
        "8726": [0.25, 0.75, 0, 0, 0.575],
        "8727": [-0.02778, 0.47222, 0, 0, 0.575],
        "8728": [-0.02639, 0.47361, 0, 0, 0.575],
        "8729": [-0.02639, 0.47361, 0, 0, 0.575],
        "8730": [0.18, 0.82, 0, 0, 0.95833],
        "8733": [0, 0.44444, 0, 0, 0.89444],
        "8734": [0, 0.44444, 0, 0, 1.14999],
        "8736": [0, 0.69224, 0, 0, 0.72222],
        "8739": [0.25, 0.75, 0, 0, 0.31944],
        "8741": [0.25, 0.75, 0, 0, 0.575],
        "8743": [0, 0.55556, 0, 0, 0.76666],
        "8744": [0, 0.55556, 0, 0, 0.76666],
        "8745": [0, 0.55556, 0, 0, 0.76666],
        "8746": [0, 0.55556, 0, 0, 0.76666],
        "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
        "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
        "8768": [0.19444, 0.69444, 0, 0, 0.31944],
        "8771": [0.00222, 0.50222, 0, 0, 0.89444],
        "8773": [0.027, 0.638, 0, 0, 0.894],
        "8776": [0.02444, 0.52444, 0, 0, 0.89444],
        "8781": [0.00222, 0.50222, 0, 0, 0.89444],
        "8801": [0.00222, 0.50222, 0, 0, 0.89444],
        "8804": [0.19667, 0.69667, 0, 0, 0.89444],
        "8805": [0.19667, 0.69667, 0, 0, 0.89444],
        "8810": [0.08556, 0.58556, 0, 0, 1.14999],
        "8811": [0.08556, 0.58556, 0, 0, 1.14999],
        "8826": [0.08556, 0.58556, 0, 0, 0.89444],
        "8827": [0.08556, 0.58556, 0, 0, 0.89444],
        "8834": [0.08556, 0.58556, 0, 0, 0.89444],
        "8835": [0.08556, 0.58556, 0, 0, 0.89444],
        "8838": [0.19667, 0.69667, 0, 0, 0.89444],
        "8839": [0.19667, 0.69667, 0, 0, 0.89444],
        "8846": [0, 0.55556, 0, 0, 0.76666],
        "8849": [0.19667, 0.69667, 0, 0, 0.89444],
        "8850": [0.19667, 0.69667, 0, 0, 0.89444],
        "8851": [0, 0.55556, 0, 0, 0.76666],
        "8852": [0, 0.55556, 0, 0, 0.76666],
        "8853": [0.13333, 0.63333, 0, 0, 0.89444],
        "8854": [0.13333, 0.63333, 0, 0, 0.89444],
        "8855": [0.13333, 0.63333, 0, 0, 0.89444],
        "8856": [0.13333, 0.63333, 0, 0, 0.89444],
        "8857": [0.13333, 0.63333, 0, 0, 0.89444],
        "8866": [0, 0.69444, 0, 0, 0.70277],
        "8867": [0, 0.69444, 0, 0, 0.70277],
        "8868": [0, 0.69444, 0, 0, 0.89444],
        "8869": [0, 0.69444, 0, 0, 0.89444],
        "8900": [-0.02639, 0.47361, 0, 0, 0.575],
        "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
        "8902": [-0.02778, 0.47222, 0, 0, 0.575],
        "8968": [0.25, 0.75, 0, 0, 0.51111],
        "8969": [0.25, 0.75, 0, 0, 0.51111],
        "8970": [0.25, 0.75, 0, 0, 0.51111],
        "8971": [0.25, 0.75, 0, 0, 0.51111],
        "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
        "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
        "9651": [0.19444, 0.69444, 0, 0, 1.02222],
        "9657": [-0.02778, 0.47222, 0, 0, 0.575],
        "9661": [0.19444, 0.69444, 0, 0, 1.02222],
        "9667": [-0.02778, 0.47222, 0, 0, 0.575],
        "9711": [0.19444, 0.69444, 0, 0, 1.14999],
        "9824": [0.12963, 0.69444, 0, 0, 0.89444],
        "9825": [0.12963, 0.69444, 0, 0, 0.89444],
        "9826": [0.12963, 0.69444, 0, 0, 0.89444],
        "9827": [0.12963, 0.69444, 0, 0, 0.89444],
        "9837": [0, 0.75, 0, 0, 0.44722],
        "9838": [0.19444, 0.69444, 0, 0, 0.44722],
        "9839": [0.19444, 0.69444, 0, 0, 0.44722],
        "10216": [0.25, 0.75, 0, 0, 0.44722],
        "10217": [0.25, 0.75, 0, 0, 0.44722],
        "10815": [0, 0.68611, 0, 0, 0.9],
        "10927": [0.19667, 0.69667, 0, 0, 0.89444],
        "10928": [0.19667, 0.69667, 0, 0, 0.89444],
        "57376": [0.19444, 0.69444, 0, 0, 0]
      },
      "Main-BoldItalic": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0.11417, 0, 0.38611],
        "34": [0, 0.69444, 0.07939, 0, 0.62055],
        "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
        "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
        "38": [0, 0.69444, 0.08528, 0, 0.88555],
        "39": [0, 0.69444, 0.12945, 0, 0.35555],
        "40": [0.25, 0.75, 0.15806, 0, 0.47333],
        "41": [0.25, 0.75, 0.03306, 0, 0.47333],
        "42": [0, 0.75, 0.14333, 0, 0.59111],
        "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
        "44": [0.19444, 0.14722, 0, 0, 0.35555],
        "45": [0, 0.44444, 0.02611, 0, 0.41444],
        "46": [0, 0.14722, 0, 0, 0.35555],
        "47": [0.25, 0.75, 0.15806, 0, 0.59111],
        "48": [0, 0.64444, 0.13167, 0, 0.59111],
        "49": [0, 0.64444, 0.13167, 0, 0.59111],
        "50": [0, 0.64444, 0.13167, 0, 0.59111],
        "51": [0, 0.64444, 0.13167, 0, 0.59111],
        "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
        "53": [0, 0.64444, 0.13167, 0, 0.59111],
        "54": [0, 0.64444, 0.13167, 0, 0.59111],
        "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
        "56": [0, 0.64444, 0.13167, 0, 0.59111],
        "57": [0, 0.64444, 0.13167, 0, 0.59111],
        "58": [0, 0.44444, 0.06695, 0, 0.35555],
        "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
        "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
        "63": [0, 0.69444, 0.11472, 0, 0.59111],
        "64": [0, 0.69444, 0.09208, 0, 0.88555],
        "65": [0, 0.68611, 0, 0, 0.86555],
        "66": [0, 0.68611, 0.0992, 0, 0.81666],
        "67": [0, 0.68611, 0.14208, 0, 0.82666],
        "68": [0, 0.68611, 0.09062, 0, 0.87555],
        "69": [0, 0.68611, 0.11431, 0, 0.75666],
        "70": [0, 0.68611, 0.12903, 0, 0.72722],
        "71": [0, 0.68611, 0.07347, 0, 0.89527],
        "72": [0, 0.68611, 0.17208, 0, 0.8961],
        "73": [0, 0.68611, 0.15681, 0, 0.47166],
        "74": [0, 0.68611, 0.145, 0, 0.61055],
        "75": [0, 0.68611, 0.14208, 0, 0.89499],
        "76": [0, 0.68611, 0, 0, 0.69777],
        "77": [0, 0.68611, 0.17208, 0, 1.07277],
        "78": [0, 0.68611, 0.17208, 0, 0.8961],
        "79": [0, 0.68611, 0.09062, 0, 0.85499],
        "80": [0, 0.68611, 0.0992, 0, 0.78721],
        "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
        "82": [0, 0.68611, 0.02559, 0, 0.85944],
        "83": [0, 0.68611, 0.11264, 0, 0.64999],
        "84": [0, 0.68611, 0.12903, 0, 0.7961],
        "85": [0, 0.68611, 0.17208, 0, 0.88083],
        "86": [0, 0.68611, 0.18625, 0, 0.86555],
        "87": [0, 0.68611, 0.18625, 0, 1.15999],
        "88": [0, 0.68611, 0.15681, 0, 0.86555],
        "89": [0, 0.68611, 0.19803, 0, 0.86555],
        "90": [0, 0.68611, 0.14208, 0, 0.70888],
        "91": [0.25, 0.75, 0.1875, 0, 0.35611],
        "93": [0.25, 0.75, 0.09972, 0, 0.35611],
        "94": [0, 0.69444, 0.06709, 0, 0.59111],
        "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
        "97": [0, 0.44444, 0.09426, 0, 0.59111],
        "98": [0, 0.69444, 0.07861, 0, 0.53222],
        "99": [0, 0.44444, 0.05222, 0, 0.53222],
        "100": [0, 0.69444, 0.10861, 0, 0.59111],
        "101": [0, 0.44444, 0.085, 0, 0.53222],
        "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
        "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
        "104": [0, 0.69444, 0.09426, 0, 0.59111],
        "105": [0, 0.69326, 0.11387, 0, 0.35555],
        "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
        "107": [0, 0.69444, 0.11111, 0, 0.53222],
        "108": [0, 0.69444, 0.10861, 0, 0.29666],
        "109": [0, 0.44444, 0.09426, 0, 0.94444],
        "110": [0, 0.44444, 0.09426, 0, 0.64999],
        "111": [0, 0.44444, 0.07861, 0, 0.59111],
        "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
        "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
        "114": [0, 0.44444, 0.11111, 0, 0.50167],
        "115": [0, 0.44444, 0.08167, 0, 0.48694],
        "116": [0, 0.63492, 0.09639, 0, 0.385],
        "117": [0, 0.44444, 0.09426, 0, 0.62055],
        "118": [0, 0.44444, 0.11111, 0, 0.53222],
        "119": [0, 0.44444, 0.11111, 0, 0.76777],
        "120": [0, 0.44444, 0.12583, 0, 0.56055],
        "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
        "122": [0, 0.44444, 0.13889, 0, 0.49055],
        "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
        "160": [0, 0, 0, 0, 0.25],
        "168": [0, 0.69444, 0.11473, 0, 0.59111],
        "176": [0, 0.69444, 0, 0, 0.94888],
        "184": [0.17014, 0, 0, 0, 0.53222],
        "198": [0, 0.68611, 0.11431, 0, 1.02277],
        "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
        "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
        "230": [0, 0.44444, 0.085, 0, 0.82666],
        "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
        "305": [0, 0.44444, 0.09426, 0, 0.35555],
        "338": [0, 0.68611, 0.11431, 0, 1.14054],
        "339": [0, 0.44444, 0.085, 0, 0.82666],
        "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
        "710": [0, 0.69444, 0.06709, 0, 0.59111],
        "711": [0, 0.63194, 0.08271, 0, 0.59111],
        "713": [0, 0.59444, 0.10444, 0, 0.59111],
        "714": [0, 0.69444, 0.08528, 0, 0.59111],
        "715": [0, 0.69444, 0, 0, 0.59111],
        "728": [0, 0.69444, 0.10333, 0, 0.59111],
        "729": [0, 0.69444, 0.12945, 0, 0.35555],
        "730": [0, 0.69444, 0, 0, 0.94888],
        "732": [0, 0.69444, 0.11472, 0, 0.59111],
        "733": [0, 0.69444, 0.11472, 0, 0.59111],
        "915": [0, 0.68611, 0.12903, 0, 0.69777],
        "916": [0, 0.68611, 0, 0, 0.94444],
        "920": [0, 0.68611, 0.09062, 0, 0.88555],
        "923": [0, 0.68611, 0, 0, 0.80666],
        "926": [0, 0.68611, 0.15092, 0, 0.76777],
        "928": [0, 0.68611, 0.17208, 0, 0.8961],
        "931": [0, 0.68611, 0.11431, 0, 0.82666],
        "933": [0, 0.68611, 0.10778, 0, 0.88555],
        "934": [0, 0.68611, 0.05632, 0, 0.82666],
        "936": [0, 0.68611, 0.10778, 0, 0.88555],
        "937": [0, 0.68611, 0.0992, 0, 0.82666],
        "8211": [0, 0.44444, 0.09811, 0, 0.59111],
        "8212": [0, 0.44444, 0.09811, 0, 1.18221],
        "8216": [0, 0.69444, 0.12945, 0, 0.35555],
        "8217": [0, 0.69444, 0.12945, 0, 0.35555],
        "8220": [0, 0.69444, 0.16772, 0, 0.62055],
        "8221": [0, 0.69444, 0.07939, 0, 0.62055]
      },
      "Main-Italic": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0.12417, 0, 0.30667],
        "34": [0, 0.69444, 0.06961, 0, 0.51444],
        "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
        "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
        "38": [0, 0.69444, 0.09694, 0, 0.76666],
        "39": [0, 0.69444, 0.12417, 0, 0.30667],
        "40": [0.25, 0.75, 0.16194, 0, 0.40889],
        "41": [0.25, 0.75, 0.03694, 0, 0.40889],
        "42": [0, 0.75, 0.14917, 0, 0.51111],
        "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
        "44": [0.19444, 0.10556, 0, 0, 0.30667],
        "45": [0, 0.43056, 0.02826, 0, 0.35778],
        "46": [0, 0.10556, 0, 0, 0.30667],
        "47": [0.25, 0.75, 0.16194, 0, 0.51111],
        "48": [0, 0.64444, 0.13556, 0, 0.51111],
        "49": [0, 0.64444, 0.13556, 0, 0.51111],
        "50": [0, 0.64444, 0.13556, 0, 0.51111],
        "51": [0, 0.64444, 0.13556, 0, 0.51111],
        "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
        "53": [0, 0.64444, 0.13556, 0, 0.51111],
        "54": [0, 0.64444, 0.13556, 0, 0.51111],
        "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
        "56": [0, 0.64444, 0.13556, 0, 0.51111],
        "57": [0, 0.64444, 0.13556, 0, 0.51111],
        "58": [0, 0.43056, 0.0582, 0, 0.30667],
        "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
        "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
        "63": [0, 0.69444, 0.1225, 0, 0.51111],
        "64": [0, 0.69444, 0.09597, 0, 0.76666],
        "65": [0, 0.68333, 0, 0, 0.74333],
        "66": [0, 0.68333, 0.10257, 0, 0.70389],
        "67": [0, 0.68333, 0.14528, 0, 0.71555],
        "68": [0, 0.68333, 0.09403, 0, 0.755],
        "69": [0, 0.68333, 0.12028, 0, 0.67833],
        "70": [0, 0.68333, 0.13305, 0, 0.65277],
        "71": [0, 0.68333, 0.08722, 0, 0.77361],
        "72": [0, 0.68333, 0.16389, 0, 0.74333],
        "73": [0, 0.68333, 0.15806, 0, 0.38555],
        "74": [0, 0.68333, 0.14028, 0, 0.525],
        "75": [0, 0.68333, 0.14528, 0, 0.76888],
        "76": [0, 0.68333, 0, 0, 0.62722],
        "77": [0, 0.68333, 0.16389, 0, 0.89666],
        "78": [0, 0.68333, 0.16389, 0, 0.74333],
        "79": [0, 0.68333, 0.09403, 0, 0.76666],
        "80": [0, 0.68333, 0.10257, 0, 0.67833],
        "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
        "82": [0, 0.68333, 0.03868, 0, 0.72944],
        "83": [0, 0.68333, 0.11972, 0, 0.56222],
        "84": [0, 0.68333, 0.13305, 0, 0.71555],
        "85": [0, 0.68333, 0.16389, 0, 0.74333],
        "86": [0, 0.68333, 0.18361, 0, 0.74333],
        "87": [0, 0.68333, 0.18361, 0, 0.99888],
        "88": [0, 0.68333, 0.15806, 0, 0.74333],
        "89": [0, 0.68333, 0.19383, 0, 0.74333],
        "90": [0, 0.68333, 0.14528, 0, 0.61333],
        "91": [0.25, 0.75, 0.1875, 0, 0.30667],
        "93": [0.25, 0.75, 0.10528, 0, 0.30667],
        "94": [0, 0.69444, 0.06646, 0, 0.51111],
        "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
        "97": [0, 0.43056, 0.07671, 0, 0.51111],
        "98": [0, 0.69444, 0.06312, 0, 0.46],
        "99": [0, 0.43056, 0.05653, 0, 0.46],
        "100": [0, 0.69444, 0.10333, 0, 0.51111],
        "101": [0, 0.43056, 0.07514, 0, 0.46],
        "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
        "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
        "104": [0, 0.69444, 0.07671, 0, 0.51111],
        "105": [0, 0.65536, 0.1019, 0, 0.30667],
        "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
        "107": [0, 0.69444, 0.10764, 0, 0.46],
        "108": [0, 0.69444, 0.10333, 0, 0.25555],
        "109": [0, 0.43056, 0.07671, 0, 0.81777],
        "110": [0, 0.43056, 0.07671, 0, 0.56222],
        "111": [0, 0.43056, 0.06312, 0, 0.51111],
        "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
        "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
        "114": [0, 0.43056, 0.10764, 0, 0.42166],
        "115": [0, 0.43056, 0.08208, 0, 0.40889],
        "116": [0, 0.61508, 0.09486, 0, 0.33222],
        "117": [0, 0.43056, 0.07671, 0, 0.53666],
        "118": [0, 0.43056, 0.10764, 0, 0.46],
        "119": [0, 0.43056, 0.10764, 0, 0.66444],
        "120": [0, 0.43056, 0.12042, 0, 0.46389],
        "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
        "122": [0, 0.43056, 0.12292, 0, 0.40889],
        "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
        "160": [0, 0, 0, 0, 0.25],
        "168": [0, 0.66786, 0.10474, 0, 0.51111],
        "176": [0, 0.69444, 0, 0, 0.83129],
        "184": [0.17014, 0, 0, 0, 0.46],
        "198": [0, 0.68333, 0.12028, 0, 0.88277],
        "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
        "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
        "230": [0, 0.43056, 0.07514, 0, 0.71555],
        "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
        "338": [0, 0.68333, 0.12028, 0, 0.98499],
        "339": [0, 0.43056, 0.07514, 0, 0.71555],
        "710": [0, 0.69444, 0.06646, 0, 0.51111],
        "711": [0, 0.62847, 0.08295, 0, 0.51111],
        "713": [0, 0.56167, 0.10333, 0, 0.51111],
        "714": [0, 0.69444, 0.09694, 0, 0.51111],
        "715": [0, 0.69444, 0, 0, 0.51111],
        "728": [0, 0.69444, 0.10806, 0, 0.51111],
        "729": [0, 0.66786, 0.11752, 0, 0.30667],
        "730": [0, 0.69444, 0, 0, 0.83129],
        "732": [0, 0.66786, 0.11585, 0, 0.51111],
        "733": [0, 0.69444, 0.1225, 0, 0.51111],
        "915": [0, 0.68333, 0.13305, 0, 0.62722],
        "916": [0, 0.68333, 0, 0, 0.81777],
        "920": [0, 0.68333, 0.09403, 0, 0.76666],
        "923": [0, 0.68333, 0, 0, 0.69222],
        "926": [0, 0.68333, 0.15294, 0, 0.66444],
        "928": [0, 0.68333, 0.16389, 0, 0.74333],
        "931": [0, 0.68333, 0.12028, 0, 0.71555],
        "933": [0, 0.68333, 0.11111, 0, 0.76666],
        "934": [0, 0.68333, 0.05986, 0, 0.71555],
        "936": [0, 0.68333, 0.11111, 0, 0.76666],
        "937": [0, 0.68333, 0.10257, 0, 0.71555],
        "8211": [0, 0.43056, 0.09208, 0, 0.51111],
        "8212": [0, 0.43056, 0.09208, 0, 1.02222],
        "8216": [0, 0.69444, 0.12417, 0, 0.30667],
        "8217": [0, 0.69444, 0.12417, 0, 0.30667],
        "8220": [0, 0.69444, 0.1685, 0, 0.51444],
        "8221": [0, 0.69444, 0.06961, 0, 0.51444],
        "8463": [0, 0.68889, 0, 0, 0.54028]
      },
      "Main-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0, 0, 0.27778],
        "34": [0, 0.69444, 0, 0, 0.5],
        "35": [0.19444, 0.69444, 0, 0, 0.83334],
        "36": [0.05556, 0.75, 0, 0, 0.5],
        "37": [0.05556, 0.75, 0, 0, 0.83334],
        "38": [0, 0.69444, 0, 0, 0.77778],
        "39": [0, 0.69444, 0, 0, 0.27778],
        "40": [0.25, 0.75, 0, 0, 0.38889],
        "41": [0.25, 0.75, 0, 0, 0.38889],
        "42": [0, 0.75, 0, 0, 0.5],
        "43": [0.08333, 0.58333, 0, 0, 0.77778],
        "44": [0.19444, 0.10556, 0, 0, 0.27778],
        "45": [0, 0.43056, 0, 0, 0.33333],
        "46": [0, 0.10556, 0, 0, 0.27778],
        "47": [0.25, 0.75, 0, 0, 0.5],
        "48": [0, 0.64444, 0, 0, 0.5],
        "49": [0, 0.64444, 0, 0, 0.5],
        "50": [0, 0.64444, 0, 0, 0.5],
        "51": [0, 0.64444, 0, 0, 0.5],
        "52": [0, 0.64444, 0, 0, 0.5],
        "53": [0, 0.64444, 0, 0, 0.5],
        "54": [0, 0.64444, 0, 0, 0.5],
        "55": [0, 0.64444, 0, 0, 0.5],
        "56": [0, 0.64444, 0, 0, 0.5],
        "57": [0, 0.64444, 0, 0, 0.5],
        "58": [0, 0.43056, 0, 0, 0.27778],
        "59": [0.19444, 0.43056, 0, 0, 0.27778],
        "60": [0.0391, 0.5391, 0, 0, 0.77778],
        "61": [-0.13313, 0.36687, 0, 0, 0.77778],
        "62": [0.0391, 0.5391, 0, 0, 0.77778],
        "63": [0, 0.69444, 0, 0, 0.47222],
        "64": [0, 0.69444, 0, 0, 0.77778],
        "65": [0, 0.68333, 0, 0, 0.75],
        "66": [0, 0.68333, 0, 0, 0.70834],
        "67": [0, 0.68333, 0, 0, 0.72222],
        "68": [0, 0.68333, 0, 0, 0.76389],
        "69": [0, 0.68333, 0, 0, 0.68056],
        "70": [0, 0.68333, 0, 0, 0.65278],
        "71": [0, 0.68333, 0, 0, 0.78472],
        "72": [0, 0.68333, 0, 0, 0.75],
        "73": [0, 0.68333, 0, 0, 0.36111],
        "74": [0, 0.68333, 0, 0, 0.51389],
        "75": [0, 0.68333, 0, 0, 0.77778],
        "76": [0, 0.68333, 0, 0, 0.625],
        "77": [0, 0.68333, 0, 0, 0.91667],
        "78": [0, 0.68333, 0, 0, 0.75],
        "79": [0, 0.68333, 0, 0, 0.77778],
        "80": [0, 0.68333, 0, 0, 0.68056],
        "81": [0.19444, 0.68333, 0, 0, 0.77778],
        "82": [0, 0.68333, 0, 0, 0.73611],
        "83": [0, 0.68333, 0, 0, 0.55556],
        "84": [0, 0.68333, 0, 0, 0.72222],
        "85": [0, 0.68333, 0, 0, 0.75],
        "86": [0, 0.68333, 0.01389, 0, 0.75],
        "87": [0, 0.68333, 0.01389, 0, 1.02778],
        "88": [0, 0.68333, 0, 0, 0.75],
        "89": [0, 0.68333, 0.025, 0, 0.75],
        "90": [0, 0.68333, 0, 0, 0.61111],
        "91": [0.25, 0.75, 0, 0, 0.27778],
        "92": [0.25, 0.75, 0, 0, 0.5],
        "93": [0.25, 0.75, 0, 0, 0.27778],
        "94": [0, 0.69444, 0, 0, 0.5],
        "95": [0.31, 0.12056, 0.02778, 0, 0.5],
        "97": [0, 0.43056, 0, 0, 0.5],
        "98": [0, 0.69444, 0, 0, 0.55556],
        "99": [0, 0.43056, 0, 0, 0.44445],
        "100": [0, 0.69444, 0, 0, 0.55556],
        "101": [0, 0.43056, 0, 0, 0.44445],
        "102": [0, 0.69444, 0.07778, 0, 0.30556],
        "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
        "104": [0, 0.69444, 0, 0, 0.55556],
        "105": [0, 0.66786, 0, 0, 0.27778],
        "106": [0.19444, 0.66786, 0, 0, 0.30556],
        "107": [0, 0.69444, 0, 0, 0.52778],
        "108": [0, 0.69444, 0, 0, 0.27778],
        "109": [0, 0.43056, 0, 0, 0.83334],
        "110": [0, 0.43056, 0, 0, 0.55556],
        "111": [0, 0.43056, 0, 0, 0.5],
        "112": [0.19444, 0.43056, 0, 0, 0.55556],
        "113": [0.19444, 0.43056, 0, 0, 0.52778],
        "114": [0, 0.43056, 0, 0, 0.39167],
        "115": [0, 0.43056, 0, 0, 0.39445],
        "116": [0, 0.61508, 0, 0, 0.38889],
        "117": [0, 0.43056, 0, 0, 0.55556],
        "118": [0, 0.43056, 0.01389, 0, 0.52778],
        "119": [0, 0.43056, 0.01389, 0, 0.72222],
        "120": [0, 0.43056, 0, 0, 0.52778],
        "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
        "122": [0, 0.43056, 0, 0, 0.44445],
        "123": [0.25, 0.75, 0, 0, 0.5],
        "124": [0.25, 0.75, 0, 0, 0.27778],
        "125": [0.25, 0.75, 0, 0, 0.5],
        "126": [0.35, 0.31786, 0, 0, 0.5],
        "160": [0, 0, 0, 0, 0.25],
        "163": [0, 0.69444, 0, 0, 0.76909],
        "167": [0.19444, 0.69444, 0, 0, 0.44445],
        "168": [0, 0.66786, 0, 0, 0.5],
        "172": [0, 0.43056, 0, 0, 0.66667],
        "176": [0, 0.69444, 0, 0, 0.75],
        "177": [0.08333, 0.58333, 0, 0, 0.77778],
        "182": [0.19444, 0.69444, 0, 0, 0.61111],
        "184": [0.17014, 0, 0, 0, 0.44445],
        "198": [0, 0.68333, 0, 0, 0.90278],
        "215": [0.08333, 0.58333, 0, 0, 0.77778],
        "216": [0.04861, 0.73194, 0, 0, 0.77778],
        "223": [0, 0.69444, 0, 0, 0.5],
        "230": [0, 0.43056, 0, 0, 0.72222],
        "247": [0.08333, 0.58333, 0, 0, 0.77778],
        "248": [0.09722, 0.52778, 0, 0, 0.5],
        "305": [0, 0.43056, 0, 0, 0.27778],
        "338": [0, 0.68333, 0, 0, 1.01389],
        "339": [0, 0.43056, 0, 0, 0.77778],
        "567": [0.19444, 0.43056, 0, 0, 0.30556],
        "710": [0, 0.69444, 0, 0, 0.5],
        "711": [0, 0.62847, 0, 0, 0.5],
        "713": [0, 0.56778, 0, 0, 0.5],
        "714": [0, 0.69444, 0, 0, 0.5],
        "715": [0, 0.69444, 0, 0, 0.5],
        "728": [0, 0.69444, 0, 0, 0.5],
        "729": [0, 0.66786, 0, 0, 0.27778],
        "730": [0, 0.69444, 0, 0, 0.75],
        "732": [0, 0.66786, 0, 0, 0.5],
        "733": [0, 0.69444, 0, 0, 0.5],
        "915": [0, 0.68333, 0, 0, 0.625],
        "916": [0, 0.68333, 0, 0, 0.83334],
        "920": [0, 0.68333, 0, 0, 0.77778],
        "923": [0, 0.68333, 0, 0, 0.69445],
        "926": [0, 0.68333, 0, 0, 0.66667],
        "928": [0, 0.68333, 0, 0, 0.75],
        "931": [0, 0.68333, 0, 0, 0.72222],
        "933": [0, 0.68333, 0, 0, 0.77778],
        "934": [0, 0.68333, 0, 0, 0.72222],
        "936": [0, 0.68333, 0, 0, 0.77778],
        "937": [0, 0.68333, 0, 0, 0.72222],
        "8211": [0, 0.43056, 0.02778, 0, 0.5],
        "8212": [0, 0.43056, 0.02778, 0, 1.0],
        "8216": [0, 0.69444, 0, 0, 0.27778],
        "8217": [0, 0.69444, 0, 0, 0.27778],
        "8220": [0, 0.69444, 0, 0, 0.5],
        "8221": [0, 0.69444, 0, 0, 0.5],
        "8224": [0.19444, 0.69444, 0, 0, 0.44445],
        "8225": [0.19444, 0.69444, 0, 0, 0.44445],
        "8230": [0, 0.123, 0, 0, 1.172],
        "8242": [0, 0.55556, 0, 0, 0.275],
        "8407": [0, 0.71444, 0.15382, 0, 0.5],
        "8463": [0, 0.68889, 0, 0, 0.54028],
        "8465": [0, 0.69444, 0, 0, 0.72222],
        "8467": [0, 0.69444, 0, 0.11111, 0.41667],
        "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
        "8476": [0, 0.69444, 0, 0, 0.72222],
        "8501": [0, 0.69444, 0, 0, 0.61111],
        "8592": [-0.13313, 0.36687, 0, 0, 1.0],
        "8593": [0.19444, 0.69444, 0, 0, 0.5],
        "8594": [-0.13313, 0.36687, 0, 0, 1.0],
        "8595": [0.19444, 0.69444, 0, 0, 0.5],
        "8596": [-0.13313, 0.36687, 0, 0, 1.0],
        "8597": [0.25, 0.75, 0, 0, 0.5],
        "8598": [0.19444, 0.69444, 0, 0, 1.0],
        "8599": [0.19444, 0.69444, 0, 0, 1.0],
        "8600": [0.19444, 0.69444, 0, 0, 1.0],
        "8601": [0.19444, 0.69444, 0, 0, 1.0],
        "8614": [0.011, 0.511, 0, 0, 1.0],
        "8617": [0.011, 0.511, 0, 0, 1.126],
        "8618": [0.011, 0.511, 0, 0, 1.126],
        "8636": [-0.13313, 0.36687, 0, 0, 1.0],
        "8637": [-0.13313, 0.36687, 0, 0, 1.0],
        "8640": [-0.13313, 0.36687, 0, 0, 1.0],
        "8641": [-0.13313, 0.36687, 0, 0, 1.0],
        "8652": [0.011, 0.671, 0, 0, 1.0],
        "8656": [-0.13313, 0.36687, 0, 0, 1.0],
        "8657": [0.19444, 0.69444, 0, 0, 0.61111],
        "8658": [-0.13313, 0.36687, 0, 0, 1.0],
        "8659": [0.19444, 0.69444, 0, 0, 0.61111],
        "8660": [-0.13313, 0.36687, 0, 0, 1.0],
        "8661": [0.25, 0.75, 0, 0, 0.61111],
        "8704": [0, 0.69444, 0, 0, 0.55556],
        "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
        "8707": [0, 0.69444, 0, 0, 0.55556],
        "8709": [0.05556, 0.75, 0, 0, 0.5],
        "8711": [0, 0.68333, 0, 0, 0.83334],
        "8712": [0.0391, 0.5391, 0, 0, 0.66667],
        "8715": [0.0391, 0.5391, 0, 0, 0.66667],
        "8722": [0.08333, 0.58333, 0, 0, 0.77778],
        "8723": [0.08333, 0.58333, 0, 0, 0.77778],
        "8725": [0.25, 0.75, 0, 0, 0.5],
        "8726": [0.25, 0.75, 0, 0, 0.5],
        "8727": [-0.03472, 0.46528, 0, 0, 0.5],
        "8728": [-0.05555, 0.44445, 0, 0, 0.5],
        "8729": [-0.05555, 0.44445, 0, 0, 0.5],
        "8730": [0.2, 0.8, 0, 0, 0.83334],
        "8733": [0, 0.43056, 0, 0, 0.77778],
        "8734": [0, 0.43056, 0, 0, 1.0],
        "8736": [0, 0.69224, 0, 0, 0.72222],
        "8739": [0.25, 0.75, 0, 0, 0.27778],
        "8741": [0.25, 0.75, 0, 0, 0.5],
        "8743": [0, 0.55556, 0, 0, 0.66667],
        "8744": [0, 0.55556, 0, 0, 0.66667],
        "8745": [0, 0.55556, 0, 0, 0.66667],
        "8746": [0, 0.55556, 0, 0, 0.66667],
        "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
        "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
        "8768": [0.19444, 0.69444, 0, 0, 0.27778],
        "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
        "8773": [-0.022, 0.589, 0, 0, 0.778],
        "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
        "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
        "8784": [-0.133, 0.673, 0, 0, 0.778],
        "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
        "8804": [0.13597, 0.63597, 0, 0, 0.77778],
        "8805": [0.13597, 0.63597, 0, 0, 0.77778],
        "8810": [0.0391, 0.5391, 0, 0, 1.0],
        "8811": [0.0391, 0.5391, 0, 0, 1.0],
        "8826": [0.0391, 0.5391, 0, 0, 0.77778],
        "8827": [0.0391, 0.5391, 0, 0, 0.77778],
        "8834": [0.0391, 0.5391, 0, 0, 0.77778],
        "8835": [0.0391, 0.5391, 0, 0, 0.77778],
        "8838": [0.13597, 0.63597, 0, 0, 0.77778],
        "8839": [0.13597, 0.63597, 0, 0, 0.77778],
        "8846": [0, 0.55556, 0, 0, 0.66667],
        "8849": [0.13597, 0.63597, 0, 0, 0.77778],
        "8850": [0.13597, 0.63597, 0, 0, 0.77778],
        "8851": [0, 0.55556, 0, 0, 0.66667],
        "8852": [0, 0.55556, 0, 0, 0.66667],
        "8853": [0.08333, 0.58333, 0, 0, 0.77778],
        "8854": [0.08333, 0.58333, 0, 0, 0.77778],
        "8855": [0.08333, 0.58333, 0, 0, 0.77778],
        "8856": [0.08333, 0.58333, 0, 0, 0.77778],
        "8857": [0.08333, 0.58333, 0, 0, 0.77778],
        "8866": [0, 0.69444, 0, 0, 0.61111],
        "8867": [0, 0.69444, 0, 0, 0.61111],
        "8868": [0, 0.69444, 0, 0, 0.77778],
        "8869": [0, 0.69444, 0, 0, 0.77778],
        "8872": [0.249, 0.75, 0, 0, 0.867],
        "8900": [-0.05555, 0.44445, 0, 0, 0.5],
        "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
        "8902": [-0.03472, 0.46528, 0, 0, 0.5],
        "8904": [0.005, 0.505, 0, 0, 0.9],
        "8942": [0.03, 0.903, 0, 0, 0.278],
        "8943": [-0.19, 0.313, 0, 0, 1.172],
        "8945": [-0.1, 0.823, 0, 0, 1.282],
        "8968": [0.25, 0.75, 0, 0, 0.44445],
        "8969": [0.25, 0.75, 0, 0, 0.44445],
        "8970": [0.25, 0.75, 0, 0, 0.44445],
        "8971": [0.25, 0.75, 0, 0, 0.44445],
        "8994": [-0.14236, 0.35764, 0, 0, 1.0],
        "8995": [-0.14236, 0.35764, 0, 0, 1.0],
        "9136": [0.244, 0.744, 0, 0, 0.412],
        "9137": [0.244, 0.745, 0, 0, 0.412],
        "9651": [0.19444, 0.69444, 0, 0, 0.88889],
        "9657": [-0.03472, 0.46528, 0, 0, 0.5],
        "9661": [0.19444, 0.69444, 0, 0, 0.88889],
        "9667": [-0.03472, 0.46528, 0, 0, 0.5],
        "9711": [0.19444, 0.69444, 0, 0, 1.0],
        "9824": [0.12963, 0.69444, 0, 0, 0.77778],
        "9825": [0.12963, 0.69444, 0, 0, 0.77778],
        "9826": [0.12963, 0.69444, 0, 0, 0.77778],
        "9827": [0.12963, 0.69444, 0, 0, 0.77778],
        "9837": [0, 0.75, 0, 0, 0.38889],
        "9838": [0.19444, 0.69444, 0, 0, 0.38889],
        "9839": [0.19444, 0.69444, 0, 0, 0.38889],
        "10216": [0.25, 0.75, 0, 0, 0.38889],
        "10217": [0.25, 0.75, 0, 0, 0.38889],
        "10222": [0.244, 0.744, 0, 0, 0.412],
        "10223": [0.244, 0.745, 0, 0, 0.412],
        "10229": [0.011, 0.511, 0, 0, 1.609],
        "10230": [0.011, 0.511, 0, 0, 1.638],
        "10231": [0.011, 0.511, 0, 0, 1.859],
        "10232": [0.024, 0.525, 0, 0, 1.609],
        "10233": [0.024, 0.525, 0, 0, 1.638],
        "10234": [0.024, 0.525, 0, 0, 1.858],
        "10236": [0.011, 0.511, 0, 0, 1.638],
        "10815": [0, 0.68333, 0, 0, 0.75],
        "10927": [0.13597, 0.63597, 0, 0, 0.77778],
        "10928": [0.13597, 0.63597, 0, 0, 0.77778],
        "57376": [0.19444, 0.69444, 0, 0, 0]
      },
      "Math-BoldItalic": {
        "32": [0, 0, 0, 0, 0.25],
        "48": [0, 0.44444, 0, 0, 0.575],
        "49": [0, 0.44444, 0, 0, 0.575],
        "50": [0, 0.44444, 0, 0, 0.575],
        "51": [0.19444, 0.44444, 0, 0, 0.575],
        "52": [0.19444, 0.44444, 0, 0, 0.575],
        "53": [0.19444, 0.44444, 0, 0, 0.575],
        "54": [0, 0.64444, 0, 0, 0.575],
        "55": [0.19444, 0.44444, 0, 0, 0.575],
        "56": [0, 0.64444, 0, 0, 0.575],
        "57": [0.19444, 0.44444, 0, 0, 0.575],
        "65": [0, 0.68611, 0, 0, 0.86944],
        "66": [0, 0.68611, 0.04835, 0, 0.8664],
        "67": [0, 0.68611, 0.06979, 0, 0.81694],
        "68": [0, 0.68611, 0.03194, 0, 0.93812],
        "69": [0, 0.68611, 0.05451, 0, 0.81007],
        "70": [0, 0.68611, 0.15972, 0, 0.68889],
        "71": [0, 0.68611, 0, 0, 0.88673],
        "72": [0, 0.68611, 0.08229, 0, 0.98229],
        "73": [0, 0.68611, 0.07778, 0, 0.51111],
        "74": [0, 0.68611, 0.10069, 0, 0.63125],
        "75": [0, 0.68611, 0.06979, 0, 0.97118],
        "76": [0, 0.68611, 0, 0, 0.75555],
        "77": [0, 0.68611, 0.11424, 0, 1.14201],
        "78": [0, 0.68611, 0.11424, 0, 0.95034],
        "79": [0, 0.68611, 0.03194, 0, 0.83666],
        "80": [0, 0.68611, 0.15972, 0, 0.72309],
        "81": [0.19444, 0.68611, 0, 0, 0.86861],
        "82": [0, 0.68611, 0.00421, 0, 0.87235],
        "83": [0, 0.68611, 0.05382, 0, 0.69271],
        "84": [0, 0.68611, 0.15972, 0, 0.63663],
        "85": [0, 0.68611, 0.11424, 0, 0.80027],
        "86": [0, 0.68611, 0.25555, 0, 0.67778],
        "87": [0, 0.68611, 0.15972, 0, 1.09305],
        "88": [0, 0.68611, 0.07778, 0, 0.94722],
        "89": [0, 0.68611, 0.25555, 0, 0.67458],
        "90": [0, 0.68611, 0.06979, 0, 0.77257],
        "97": [0, 0.44444, 0, 0, 0.63287],
        "98": [0, 0.69444, 0, 0, 0.52083],
        "99": [0, 0.44444, 0, 0, 0.51342],
        "100": [0, 0.69444, 0, 0, 0.60972],
        "101": [0, 0.44444, 0, 0, 0.55361],
        "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
        "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
        "104": [0, 0.69444, 0, 0, 0.66759],
        "105": [0, 0.69326, 0, 0, 0.4048],
        "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
        "107": [0, 0.69444, 0.01852, 0, 0.6037],
        "108": [0, 0.69444, 0.0088, 0, 0.34815],
        "109": [0, 0.44444, 0, 0, 1.0324],
        "110": [0, 0.44444, 0, 0, 0.71296],
        "111": [0, 0.44444, 0, 0, 0.58472],
        "112": [0.19444, 0.44444, 0, 0, 0.60092],
        "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
        "114": [0, 0.44444, 0.03194, 0, 0.5287],
        "115": [0, 0.44444, 0, 0, 0.53125],
        "116": [0, 0.63492, 0, 0, 0.41528],
        "117": [0, 0.44444, 0, 0, 0.68102],
        "118": [0, 0.44444, 0.03704, 0, 0.56666],
        "119": [0, 0.44444, 0.02778, 0, 0.83148],
        "120": [0, 0.44444, 0, 0, 0.65903],
        "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
        "122": [0, 0.44444, 0.04213, 0, 0.55509],
        "160": [0, 0, 0, 0, 0.25],
        "915": [0, 0.68611, 0.15972, 0, 0.65694],
        "916": [0, 0.68611, 0, 0, 0.95833],
        "920": [0, 0.68611, 0.03194, 0, 0.86722],
        "923": [0, 0.68611, 0, 0, 0.80555],
        "926": [0, 0.68611, 0.07458, 0, 0.84125],
        "928": [0, 0.68611, 0.08229, 0, 0.98229],
        "931": [0, 0.68611, 0.05451, 0, 0.88507],
        "933": [0, 0.68611, 0.15972, 0, 0.67083],
        "934": [0, 0.68611, 0, 0, 0.76666],
        "936": [0, 0.68611, 0.11653, 0, 0.71402],
        "937": [0, 0.68611, 0.04835, 0, 0.8789],
        "945": [0, 0.44444, 0, 0, 0.76064],
        "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
        "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
        "948": [0, 0.69444, 0.03819, 0, 0.52222],
        "949": [0, 0.44444, 0, 0, 0.52882],
        "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
        "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
        "952": [0, 0.69444, 0.03194, 0, 0.5618],
        "953": [0, 0.44444, 0, 0, 0.41204],
        "954": [0, 0.44444, 0, 0, 0.66759],
        "955": [0, 0.69444, 0, 0, 0.67083],
        "956": [0.19444, 0.44444, 0, 0, 0.70787],
        "957": [0, 0.44444, 0.06898, 0, 0.57685],
        "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
        "959": [0, 0.44444, 0, 0, 0.58472],
        "960": [0, 0.44444, 0.03704, 0, 0.68241],
        "961": [0.19444, 0.44444, 0, 0, 0.6118],
        "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
        "963": [0, 0.44444, 0.03704, 0, 0.68588],
        "964": [0, 0.44444, 0.13472, 0, 0.52083],
        "965": [0, 0.44444, 0.03704, 0, 0.63055],
        "966": [0.19444, 0.44444, 0, 0, 0.74722],
        "967": [0.19444, 0.44444, 0, 0, 0.71805],
        "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
        "969": [0, 0.44444, 0.03704, 0, 0.71782],
        "977": [0, 0.69444, 0, 0, 0.69155],
        "981": [0.19444, 0.69444, 0, 0, 0.7125],
        "982": [0, 0.44444, 0.03194, 0, 0.975],
        "1009": [0.19444, 0.44444, 0, 0, 0.6118],
        "1013": [0, 0.44444, 0, 0, 0.48333],
        "57649": [0, 0.44444, 0, 0, 0.39352],
        "57911": [0.19444, 0.44444, 0, 0, 0.43889]
      },
      "Math-Italic": {
        "32": [0, 0, 0, 0, 0.25],
        "48": [0, 0.43056, 0, 0, 0.5],
        "49": [0, 0.43056, 0, 0, 0.5],
        "50": [0, 0.43056, 0, 0, 0.5],
        "51": [0.19444, 0.43056, 0, 0, 0.5],
        "52": [0.19444, 0.43056, 0, 0, 0.5],
        "53": [0.19444, 0.43056, 0, 0, 0.5],
        "54": [0, 0.64444, 0, 0, 0.5],
        "55": [0.19444, 0.43056, 0, 0, 0.5],
        "56": [0, 0.64444, 0, 0, 0.5],
        "57": [0.19444, 0.43056, 0, 0, 0.5],
        "65": [0, 0.68333, 0, 0.13889, 0.75],
        "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
        "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
        "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
        "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
        "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
        "71": [0, 0.68333, 0, 0.08334, 0.78625],
        "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
        "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
        "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
        "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
        "76": [0, 0.68333, 0, 0.02778, 0.68056],
        "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
        "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
        "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
        "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
        "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
        "82": [0, 0.68333, 0.00773, 0.08334, 0.75929],
        "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
        "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
        "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
        "86": [0, 0.68333, 0.22222, 0, 0.58333],
        "87": [0, 0.68333, 0.13889, 0, 0.94445],
        "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
        "89": [0, 0.68333, 0.22222, 0, 0.58056],
        "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
        "97": [0, 0.43056, 0, 0, 0.52859],
        "98": [0, 0.69444, 0, 0, 0.42917],
        "99": [0, 0.43056, 0, 0.05556, 0.43276],
        "100": [0, 0.69444, 0, 0.16667, 0.52049],
        "101": [0, 0.43056, 0, 0.05556, 0.46563],
        "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
        "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
        "104": [0, 0.69444, 0, 0, 0.57616],
        "105": [0, 0.65952, 0, 0, 0.34451],
        "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
        "107": [0, 0.69444, 0.03148, 0, 0.5206],
        "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
        "109": [0, 0.43056, 0, 0, 0.87801],
        "110": [0, 0.43056, 0, 0, 0.60023],
        "111": [0, 0.43056, 0, 0.05556, 0.48472],
        "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
        "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
        "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
        "115": [0, 0.43056, 0, 0.05556, 0.46875],
        "116": [0, 0.61508, 0, 0.08334, 0.36111],
        "117": [0, 0.43056, 0, 0.02778, 0.57246],
        "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
        "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
        "120": [0, 0.43056, 0, 0.02778, 0.57153],
        "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
        "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
        "160": [0, 0, 0, 0, 0.25],
        "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
        "916": [0, 0.68333, 0, 0.16667, 0.83334],
        "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
        "923": [0, 0.68333, 0, 0.16667, 0.69445],
        "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
        "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
        "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
        "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
        "934": [0, 0.68333, 0, 0.08334, 0.66667],
        "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
        "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
        "945": [0, 0.43056, 0.0037, 0.02778, 0.6397],
        "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
        "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
        "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
        "949": [0, 0.43056, 0, 0.08334, 0.46632],
        "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
        "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
        "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
        "953": [0, 0.43056, 0, 0.05556, 0.35394],
        "954": [0, 0.43056, 0, 0, 0.57616],
        "955": [0, 0.69444, 0, 0, 0.58334],
        "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
        "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
        "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
        "959": [0, 0.43056, 0, 0.05556, 0.48472],
        "960": [0, 0.43056, 0.03588, 0, 0.57003],
        "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
        "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
        "963": [0, 0.43056, 0.03588, 0, 0.57141],
        "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
        "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
        "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
        "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
        "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
        "969": [0, 0.43056, 0.03588, 0, 0.62245],
        "977": [0, 0.69444, 0, 0.08334, 0.59144],
        "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
        "982": [0, 0.43056, 0.02778, 0, 0.82813],
        "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
        "1013": [0, 0.43056, 0, 0.05556, 0.4059],
        "57649": [0, 0.43056, 0, 0.02778, 0.32246],
        "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
      },
      "SansSerif-Bold": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0, 0, 0.36667],
        "34": [0, 0.69444, 0, 0, 0.55834],
        "35": [0.19444, 0.69444, 0, 0, 0.91667],
        "36": [0.05556, 0.75, 0, 0, 0.55],
        "37": [0.05556, 0.75, 0, 0, 1.02912],
        "38": [0, 0.69444, 0, 0, 0.83056],
        "39": [0, 0.69444, 0, 0, 0.30556],
        "40": [0.25, 0.75, 0, 0, 0.42778],
        "41": [0.25, 0.75, 0, 0, 0.42778],
        "42": [0, 0.75, 0, 0, 0.55],
        "43": [0.11667, 0.61667, 0, 0, 0.85556],
        "44": [0.10556, 0.13056, 0, 0, 0.30556],
        "45": [0, 0.45833, 0, 0, 0.36667],
        "46": [0, 0.13056, 0, 0, 0.30556],
        "47": [0.25, 0.75, 0, 0, 0.55],
        "48": [0, 0.69444, 0, 0, 0.55],
        "49": [0, 0.69444, 0, 0, 0.55],
        "50": [0, 0.69444, 0, 0, 0.55],
        "51": [0, 0.69444, 0, 0, 0.55],
        "52": [0, 0.69444, 0, 0, 0.55],
        "53": [0, 0.69444, 0, 0, 0.55],
        "54": [0, 0.69444, 0, 0, 0.55],
        "55": [0, 0.69444, 0, 0, 0.55],
        "56": [0, 0.69444, 0, 0, 0.55],
        "57": [0, 0.69444, 0, 0, 0.55],
        "58": [0, 0.45833, 0, 0, 0.30556],
        "59": [0.10556, 0.45833, 0, 0, 0.30556],
        "61": [-0.09375, 0.40625, 0, 0, 0.85556],
        "63": [0, 0.69444, 0, 0, 0.51945],
        "64": [0, 0.69444, 0, 0, 0.73334],
        "65": [0, 0.69444, 0, 0, 0.73334],
        "66": [0, 0.69444, 0, 0, 0.73334],
        "67": [0, 0.69444, 0, 0, 0.70278],
        "68": [0, 0.69444, 0, 0, 0.79445],
        "69": [0, 0.69444, 0, 0, 0.64167],
        "70": [0, 0.69444, 0, 0, 0.61111],
        "71": [0, 0.69444, 0, 0, 0.73334],
        "72": [0, 0.69444, 0, 0, 0.79445],
        "73": [0, 0.69444, 0, 0, 0.33056],
        "74": [0, 0.69444, 0, 0, 0.51945],
        "75": [0, 0.69444, 0, 0, 0.76389],
        "76": [0, 0.69444, 0, 0, 0.58056],
        "77": [0, 0.69444, 0, 0, 0.97778],
        "78": [0, 0.69444, 0, 0, 0.79445],
        "79": [0, 0.69444, 0, 0, 0.79445],
        "80": [0, 0.69444, 0, 0, 0.70278],
        "81": [0.10556, 0.69444, 0, 0, 0.79445],
        "82": [0, 0.69444, 0, 0, 0.70278],
        "83": [0, 0.69444, 0, 0, 0.61111],
        "84": [0, 0.69444, 0, 0, 0.73334],
        "85": [0, 0.69444, 0, 0, 0.76389],
        "86": [0, 0.69444, 0.01528, 0, 0.73334],
        "87": [0, 0.69444, 0.01528, 0, 1.03889],
        "88": [0, 0.69444, 0, 0, 0.73334],
        "89": [0, 0.69444, 0.0275, 0, 0.73334],
        "90": [0, 0.69444, 0, 0, 0.67223],
        "91": [0.25, 0.75, 0, 0, 0.34306],
        "93": [0.25, 0.75, 0, 0, 0.34306],
        "94": [0, 0.69444, 0, 0, 0.55],
        "95": [0.35, 0.10833, 0.03056, 0, 0.55],
        "97": [0, 0.45833, 0, 0, 0.525],
        "98": [0, 0.69444, 0, 0, 0.56111],
        "99": [0, 0.45833, 0, 0, 0.48889],
        "100": [0, 0.69444, 0, 0, 0.56111],
        "101": [0, 0.45833, 0, 0, 0.51111],
        "102": [0, 0.69444, 0.07639, 0, 0.33611],
        "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
        "104": [0, 0.69444, 0, 0, 0.56111],
        "105": [0, 0.69444, 0, 0, 0.25556],
        "106": [0.19444, 0.69444, 0, 0, 0.28611],
        "107": [0, 0.69444, 0, 0, 0.53056],
        "108": [0, 0.69444, 0, 0, 0.25556],
        "109": [0, 0.45833, 0, 0, 0.86667],
        "110": [0, 0.45833, 0, 0, 0.56111],
        "111": [0, 0.45833, 0, 0, 0.55],
        "112": [0.19444, 0.45833, 0, 0, 0.56111],
        "113": [0.19444, 0.45833, 0, 0, 0.56111],
        "114": [0, 0.45833, 0.01528, 0, 0.37222],
        "115": [0, 0.45833, 0, 0, 0.42167],
        "116": [0, 0.58929, 0, 0, 0.40417],
        "117": [0, 0.45833, 0, 0, 0.56111],
        "118": [0, 0.45833, 0.01528, 0, 0.5],
        "119": [0, 0.45833, 0.01528, 0, 0.74445],
        "120": [0, 0.45833, 0, 0, 0.5],
        "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
        "122": [0, 0.45833, 0, 0, 0.47639],
        "126": [0.35, 0.34444, 0, 0, 0.55],
        "160": [0, 0, 0, 0, 0.25],
        "168": [0, 0.69444, 0, 0, 0.55],
        "176": [0, 0.69444, 0, 0, 0.73334],
        "180": [0, 0.69444, 0, 0, 0.55],
        "184": [0.17014, 0, 0, 0, 0.48889],
        "305": [0, 0.45833, 0, 0, 0.25556],
        "567": [0.19444, 0.45833, 0, 0, 0.28611],
        "710": [0, 0.69444, 0, 0, 0.55],
        "711": [0, 0.63542, 0, 0, 0.55],
        "713": [0, 0.63778, 0, 0, 0.55],
        "728": [0, 0.69444, 0, 0, 0.55],
        "729": [0, 0.69444, 0, 0, 0.30556],
        "730": [0, 0.69444, 0, 0, 0.73334],
        "732": [0, 0.69444, 0, 0, 0.55],
        "733": [0, 0.69444, 0, 0, 0.55],
        "915": [0, 0.69444, 0, 0, 0.58056],
        "916": [0, 0.69444, 0, 0, 0.91667],
        "920": [0, 0.69444, 0, 0, 0.85556],
        "923": [0, 0.69444, 0, 0, 0.67223],
        "926": [0, 0.69444, 0, 0, 0.73334],
        "928": [0, 0.69444, 0, 0, 0.79445],
        "931": [0, 0.69444, 0, 0, 0.79445],
        "933": [0, 0.69444, 0, 0, 0.85556],
        "934": [0, 0.69444, 0, 0, 0.79445],
        "936": [0, 0.69444, 0, 0, 0.85556],
        "937": [0, 0.69444, 0, 0, 0.79445],
        "8211": [0, 0.45833, 0.03056, 0, 0.55],
        "8212": [0, 0.45833, 0.03056, 0, 1.10001],
        "8216": [0, 0.69444, 0, 0, 0.30556],
        "8217": [0, 0.69444, 0, 0, 0.30556],
        "8220": [0, 0.69444, 0, 0, 0.55834],
        "8221": [0, 0.69444, 0, 0, 0.55834]
      },
      "SansSerif-Italic": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0.05733, 0, 0.31945],
        "34": [0, 0.69444, 0.00316, 0, 0.5],
        "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
        "36": [0.05556, 0.75, 0.11156, 0, 0.5],
        "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
        "38": [0, 0.69444, 0.03058, 0, 0.75834],
        "39": [0, 0.69444, 0.07816, 0, 0.27778],
        "40": [0.25, 0.75, 0.13164, 0, 0.38889],
        "41": [0.25, 0.75, 0.02536, 0, 0.38889],
        "42": [0, 0.75, 0.11775, 0, 0.5],
        "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
        "44": [0.125, 0.08333, 0, 0, 0.27778],
        "45": [0, 0.44444, 0.01946, 0, 0.33333],
        "46": [0, 0.08333, 0, 0, 0.27778],
        "47": [0.25, 0.75, 0.13164, 0, 0.5],
        "48": [0, 0.65556, 0.11156, 0, 0.5],
        "49": [0, 0.65556, 0.11156, 0, 0.5],
        "50": [0, 0.65556, 0.11156, 0, 0.5],
        "51": [0, 0.65556, 0.11156, 0, 0.5],
        "52": [0, 0.65556, 0.11156, 0, 0.5],
        "53": [0, 0.65556, 0.11156, 0, 0.5],
        "54": [0, 0.65556, 0.11156, 0, 0.5],
        "55": [0, 0.65556, 0.11156, 0, 0.5],
        "56": [0, 0.65556, 0.11156, 0, 0.5],
        "57": [0, 0.65556, 0.11156, 0, 0.5],
        "58": [0, 0.44444, 0.02502, 0, 0.27778],
        "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
        "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
        "63": [0, 0.69444, 0.11809, 0, 0.47222],
        "64": [0, 0.69444, 0.07555, 0, 0.66667],
        "65": [0, 0.69444, 0, 0, 0.66667],
        "66": [0, 0.69444, 0.08293, 0, 0.66667],
        "67": [0, 0.69444, 0.11983, 0, 0.63889],
        "68": [0, 0.69444, 0.07555, 0, 0.72223],
        "69": [0, 0.69444, 0.11983, 0, 0.59722],
        "70": [0, 0.69444, 0.13372, 0, 0.56945],
        "71": [0, 0.69444, 0.11983, 0, 0.66667],
        "72": [0, 0.69444, 0.08094, 0, 0.70834],
        "73": [0, 0.69444, 0.13372, 0, 0.27778],
        "74": [0, 0.69444, 0.08094, 0, 0.47222],
        "75": [0, 0.69444, 0.11983, 0, 0.69445],
        "76": [0, 0.69444, 0, 0, 0.54167],
        "77": [0, 0.69444, 0.08094, 0, 0.875],
        "78": [0, 0.69444, 0.08094, 0, 0.70834],
        "79": [0, 0.69444, 0.07555, 0, 0.73611],
        "80": [0, 0.69444, 0.08293, 0, 0.63889],
        "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
        "82": [0, 0.69444, 0.08293, 0, 0.64584],
        "83": [0, 0.69444, 0.09205, 0, 0.55556],
        "84": [0, 0.69444, 0.13372, 0, 0.68056],
        "85": [0, 0.69444, 0.08094, 0, 0.6875],
        "86": [0, 0.69444, 0.1615, 0, 0.66667],
        "87": [0, 0.69444, 0.1615, 0, 0.94445],
        "88": [0, 0.69444, 0.13372, 0, 0.66667],
        "89": [0, 0.69444, 0.17261, 0, 0.66667],
        "90": [0, 0.69444, 0.11983, 0, 0.61111],
        "91": [0.25, 0.75, 0.15942, 0, 0.28889],
        "93": [0.25, 0.75, 0.08719, 0, 0.28889],
        "94": [0, 0.69444, 0.0799, 0, 0.5],
        "95": [0.35, 0.09444, 0.08616, 0, 0.5],
        "97": [0, 0.44444, 0.00981, 0, 0.48056],
        "98": [0, 0.69444, 0.03057, 0, 0.51667],
        "99": [0, 0.44444, 0.08336, 0, 0.44445],
        "100": [0, 0.69444, 0.09483, 0, 0.51667],
        "101": [0, 0.44444, 0.06778, 0, 0.44445],
        "102": [0, 0.69444, 0.21705, 0, 0.30556],
        "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
        "104": [0, 0.69444, 0.01778, 0, 0.51667],
        "105": [0, 0.67937, 0.09718, 0, 0.23889],
        "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
        "107": [0, 0.69444, 0.08336, 0, 0.48889],
        "108": [0, 0.69444, 0.09483, 0, 0.23889],
        "109": [0, 0.44444, 0.01778, 0, 0.79445],
        "110": [0, 0.44444, 0.01778, 0, 0.51667],
        "111": [0, 0.44444, 0.06613, 0, 0.5],
        "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
        "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
        "114": [0, 0.44444, 0.10836, 0, 0.34167],
        "115": [0, 0.44444, 0.0778, 0, 0.38333],
        "116": [0, 0.57143, 0.07225, 0, 0.36111],
        "117": [0, 0.44444, 0.04169, 0, 0.51667],
        "118": [0, 0.44444, 0.10836, 0, 0.46111],
        "119": [0, 0.44444, 0.10836, 0, 0.68334],
        "120": [0, 0.44444, 0.09169, 0, 0.46111],
        "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
        "122": [0, 0.44444, 0.08752, 0, 0.43472],
        "126": [0.35, 0.32659, 0.08826, 0, 0.5],
        "160": [0, 0, 0, 0, 0.25],
        "168": [0, 0.67937, 0.06385, 0, 0.5],
        "176": [0, 0.69444, 0, 0, 0.73752],
        "184": [0.17014, 0, 0, 0, 0.44445],
        "305": [0, 0.44444, 0.04169, 0, 0.23889],
        "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
        "710": [0, 0.69444, 0.0799, 0, 0.5],
        "711": [0, 0.63194, 0.08432, 0, 0.5],
        "713": [0, 0.60889, 0.08776, 0, 0.5],
        "714": [0, 0.69444, 0.09205, 0, 0.5],
        "715": [0, 0.69444, 0, 0, 0.5],
        "728": [0, 0.69444, 0.09483, 0, 0.5],
        "729": [0, 0.67937, 0.07774, 0, 0.27778],
        "730": [0, 0.69444, 0, 0, 0.73752],
        "732": [0, 0.67659, 0.08826, 0, 0.5],
        "733": [0, 0.69444, 0.09205, 0, 0.5],
        "915": [0, 0.69444, 0.13372, 0, 0.54167],
        "916": [0, 0.69444, 0, 0, 0.83334],
        "920": [0, 0.69444, 0.07555, 0, 0.77778],
        "923": [0, 0.69444, 0, 0, 0.61111],
        "926": [0, 0.69444, 0.12816, 0, 0.66667],
        "928": [0, 0.69444, 0.08094, 0, 0.70834],
        "931": [0, 0.69444, 0.11983, 0, 0.72222],
        "933": [0, 0.69444, 0.09031, 0, 0.77778],
        "934": [0, 0.69444, 0.04603, 0, 0.72222],
        "936": [0, 0.69444, 0.09031, 0, 0.77778],
        "937": [0, 0.69444, 0.08293, 0, 0.72222],
        "8211": [0, 0.44444, 0.08616, 0, 0.5],
        "8212": [0, 0.44444, 0.08616, 0, 1.0],
        "8216": [0, 0.69444, 0.07816, 0, 0.27778],
        "8217": [0, 0.69444, 0.07816, 0, 0.27778],
        "8220": [0, 0.69444, 0.14205, 0, 0.5],
        "8221": [0, 0.69444, 0.00316, 0, 0.5]
      },
      "SansSerif-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0, 0, 0.31945],
        "34": [0, 0.69444, 0, 0, 0.5],
        "35": [0.19444, 0.69444, 0, 0, 0.83334],
        "36": [0.05556, 0.75, 0, 0, 0.5],
        "37": [0.05556, 0.75, 0, 0, 0.83334],
        "38": [0, 0.69444, 0, 0, 0.75834],
        "39": [0, 0.69444, 0, 0, 0.27778],
        "40": [0.25, 0.75, 0, 0, 0.38889],
        "41": [0.25, 0.75, 0, 0, 0.38889],
        "42": [0, 0.75, 0, 0, 0.5],
        "43": [0.08333, 0.58333, 0, 0, 0.77778],
        "44": [0.125, 0.08333, 0, 0, 0.27778],
        "45": [0, 0.44444, 0, 0, 0.33333],
        "46": [0, 0.08333, 0, 0, 0.27778],
        "47": [0.25, 0.75, 0, 0, 0.5],
        "48": [0, 0.65556, 0, 0, 0.5],
        "49": [0, 0.65556, 0, 0, 0.5],
        "50": [0, 0.65556, 0, 0, 0.5],
        "51": [0, 0.65556, 0, 0, 0.5],
        "52": [0, 0.65556, 0, 0, 0.5],
        "53": [0, 0.65556, 0, 0, 0.5],
        "54": [0, 0.65556, 0, 0, 0.5],
        "55": [0, 0.65556, 0, 0, 0.5],
        "56": [0, 0.65556, 0, 0, 0.5],
        "57": [0, 0.65556, 0, 0, 0.5],
        "58": [0, 0.44444, 0, 0, 0.27778],
        "59": [0.125, 0.44444, 0, 0, 0.27778],
        "61": [-0.13, 0.37, 0, 0, 0.77778],
        "63": [0, 0.69444, 0, 0, 0.47222],
        "64": [0, 0.69444, 0, 0, 0.66667],
        "65": [0, 0.69444, 0, 0, 0.66667],
        "66": [0, 0.69444, 0, 0, 0.66667],
        "67": [0, 0.69444, 0, 0, 0.63889],
        "68": [0, 0.69444, 0, 0, 0.72223],
        "69": [0, 0.69444, 0, 0, 0.59722],
        "70": [0, 0.69444, 0, 0, 0.56945],
        "71": [0, 0.69444, 0, 0, 0.66667],
        "72": [0, 0.69444, 0, 0, 0.70834],
        "73": [0, 0.69444, 0, 0, 0.27778],
        "74": [0, 0.69444, 0, 0, 0.47222],
        "75": [0, 0.69444, 0, 0, 0.69445],
        "76": [0, 0.69444, 0, 0, 0.54167],
        "77": [0, 0.69444, 0, 0, 0.875],
        "78": [0, 0.69444, 0, 0, 0.70834],
        "79": [0, 0.69444, 0, 0, 0.73611],
        "80": [0, 0.69444, 0, 0, 0.63889],
        "81": [0.125, 0.69444, 0, 0, 0.73611],
        "82": [0, 0.69444, 0, 0, 0.64584],
        "83": [0, 0.69444, 0, 0, 0.55556],
        "84": [0, 0.69444, 0, 0, 0.68056],
        "85": [0, 0.69444, 0, 0, 0.6875],
        "86": [0, 0.69444, 0.01389, 0, 0.66667],
        "87": [0, 0.69444, 0.01389, 0, 0.94445],
        "88": [0, 0.69444, 0, 0, 0.66667],
        "89": [0, 0.69444, 0.025, 0, 0.66667],
        "90": [0, 0.69444, 0, 0, 0.61111],
        "91": [0.25, 0.75, 0, 0, 0.28889],
        "93": [0.25, 0.75, 0, 0, 0.28889],
        "94": [0, 0.69444, 0, 0, 0.5],
        "95": [0.35, 0.09444, 0.02778, 0, 0.5],
        "97": [0, 0.44444, 0, 0, 0.48056],
        "98": [0, 0.69444, 0, 0, 0.51667],
        "99": [0, 0.44444, 0, 0, 0.44445],
        "100": [0, 0.69444, 0, 0, 0.51667],
        "101": [0, 0.44444, 0, 0, 0.44445],
        "102": [0, 0.69444, 0.06944, 0, 0.30556],
        "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
        "104": [0, 0.69444, 0, 0, 0.51667],
        "105": [0, 0.67937, 0, 0, 0.23889],
        "106": [0.19444, 0.67937, 0, 0, 0.26667],
        "107": [0, 0.69444, 0, 0, 0.48889],
        "108": [0, 0.69444, 0, 0, 0.23889],
        "109": [0, 0.44444, 0, 0, 0.79445],
        "110": [0, 0.44444, 0, 0, 0.51667],
        "111": [0, 0.44444, 0, 0, 0.5],
        "112": [0.19444, 0.44444, 0, 0, 0.51667],
        "113": [0.19444, 0.44444, 0, 0, 0.51667],
        "114": [0, 0.44444, 0.01389, 0, 0.34167],
        "115": [0, 0.44444, 0, 0, 0.38333],
        "116": [0, 0.57143, 0, 0, 0.36111],
        "117": [0, 0.44444, 0, 0, 0.51667],
        "118": [0, 0.44444, 0.01389, 0, 0.46111],
        "119": [0, 0.44444, 0.01389, 0, 0.68334],
        "120": [0, 0.44444, 0, 0, 0.46111],
        "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
        "122": [0, 0.44444, 0, 0, 0.43472],
        "126": [0.35, 0.32659, 0, 0, 0.5],
        "160": [0, 0, 0, 0, 0.25],
        "168": [0, 0.67937, 0, 0, 0.5],
        "176": [0, 0.69444, 0, 0, 0.66667],
        "184": [0.17014, 0, 0, 0, 0.44445],
        "305": [0, 0.44444, 0, 0, 0.23889],
        "567": [0.19444, 0.44444, 0, 0, 0.26667],
        "710": [0, 0.69444, 0, 0, 0.5],
        "711": [0, 0.63194, 0, 0, 0.5],
        "713": [0, 0.60889, 0, 0, 0.5],
        "714": [0, 0.69444, 0, 0, 0.5],
        "715": [0, 0.69444, 0, 0, 0.5],
        "728": [0, 0.69444, 0, 0, 0.5],
        "729": [0, 0.67937, 0, 0, 0.27778],
        "730": [0, 0.69444, 0, 0, 0.66667],
        "732": [0, 0.67659, 0, 0, 0.5],
        "733": [0, 0.69444, 0, 0, 0.5],
        "915": [0, 0.69444, 0, 0, 0.54167],
        "916": [0, 0.69444, 0, 0, 0.83334],
        "920": [0, 0.69444, 0, 0, 0.77778],
        "923": [0, 0.69444, 0, 0, 0.61111],
        "926": [0, 0.69444, 0, 0, 0.66667],
        "928": [0, 0.69444, 0, 0, 0.70834],
        "931": [0, 0.69444, 0, 0, 0.72222],
        "933": [0, 0.69444, 0, 0, 0.77778],
        "934": [0, 0.69444, 0, 0, 0.72222],
        "936": [0, 0.69444, 0, 0, 0.77778],
        "937": [0, 0.69444, 0, 0, 0.72222],
        "8211": [0, 0.44444, 0.02778, 0, 0.5],
        "8212": [0, 0.44444, 0.02778, 0, 1.0],
        "8216": [0, 0.69444, 0, 0, 0.27778],
        "8217": [0, 0.69444, 0, 0, 0.27778],
        "8220": [0, 0.69444, 0, 0, 0.5],
        "8221": [0, 0.69444, 0, 0, 0.5]
      },
      "Script-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "65": [0, 0.7, 0.22925, 0, 0.80253],
        "66": [0, 0.7, 0.04087, 0, 0.90757],
        "67": [0, 0.7, 0.1689, 0, 0.66619],
        "68": [0, 0.7, 0.09371, 0, 0.77443],
        "69": [0, 0.7, 0.18583, 0, 0.56162],
        "70": [0, 0.7, 0.13634, 0, 0.89544],
        "71": [0, 0.7, 0.17322, 0, 0.60961],
        "72": [0, 0.7, 0.29694, 0, 0.96919],
        "73": [0, 0.7, 0.19189, 0, 0.80907],
        "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
        "75": [0, 0.7, 0.31259, 0, 0.91364],
        "76": [0, 0.7, 0.19189, 0, 0.87373],
        "77": [0, 0.7, 0.15981, 0, 1.08031],
        "78": [0, 0.7, 0.3525, 0, 0.9015],
        "79": [0, 0.7, 0.08078, 0, 0.73787],
        "80": [0, 0.7, 0.08078, 0, 1.01262],
        "81": [0, 0.7, 0.03305, 0, 0.88282],
        "82": [0, 0.7, 0.06259, 0, 0.85],
        "83": [0, 0.7, 0.19189, 0, 0.86767],
        "84": [0, 0.7, 0.29087, 0, 0.74697],
        "85": [0, 0.7, 0.25815, 0, 0.79996],
        "86": [0, 0.7, 0.27523, 0, 0.62204],
        "87": [0, 0.7, 0.27523, 0, 0.80532],
        "88": [0, 0.7, 0.26006, 0, 0.94445],
        "89": [0, 0.7, 0.2939, 0, 0.70961],
        "90": [0, 0.7, 0.24037, 0, 0.8212],
        "160": [0, 0, 0, 0, 0.25]
      },
      "Size1-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "40": [0.35001, 0.85, 0, 0, 0.45834],
        "41": [0.35001, 0.85, 0, 0, 0.45834],
        "47": [0.35001, 0.85, 0, 0, 0.57778],
        "91": [0.35001, 0.85, 0, 0, 0.41667],
        "92": [0.35001, 0.85, 0, 0, 0.57778],
        "93": [0.35001, 0.85, 0, 0, 0.41667],
        "123": [0.35001, 0.85, 0, 0, 0.58334],
        "125": [0.35001, 0.85, 0, 0, 0.58334],
        "160": [0, 0, 0, 0, 0.25],
        "710": [0, 0.72222, 0, 0, 0.55556],
        "732": [0, 0.72222, 0, 0, 0.55556],
        "770": [0, 0.72222, 0, 0, 0.55556],
        "771": [0, 0.72222, 0, 0, 0.55556],
        "8214": [-0.00099, 0.601, 0, 0, 0.77778],
        "8593": [1e-05, 0.6, 0, 0, 0.66667],
        "8595": [1e-05, 0.6, 0, 0, 0.66667],
        "8657": [1e-05, 0.6, 0, 0, 0.77778],
        "8659": [1e-05, 0.6, 0, 0, 0.77778],
        "8719": [0.25001, 0.75, 0, 0, 0.94445],
        "8720": [0.25001, 0.75, 0, 0, 0.94445],
        "8721": [0.25001, 0.75, 0, 0, 1.05556],
        "8730": [0.35001, 0.85, 0, 0, 1.0],
        "8739": [-0.00599, 0.606, 0, 0, 0.33333],
        "8741": [-0.00599, 0.606, 0, 0, 0.55556],
        "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
        "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
        "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
        "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
        "8896": [0.25001, 0.75, 0, 0, 0.83334],
        "8897": [0.25001, 0.75, 0, 0, 0.83334],
        "8898": [0.25001, 0.75, 0, 0, 0.83334],
        "8899": [0.25001, 0.75, 0, 0, 0.83334],
        "8968": [0.35001, 0.85, 0, 0, 0.47222],
        "8969": [0.35001, 0.85, 0, 0, 0.47222],
        "8970": [0.35001, 0.85, 0, 0, 0.47222],
        "8971": [0.35001, 0.85, 0, 0, 0.47222],
        "9168": [-0.00099, 0.601, 0, 0, 0.66667],
        "10216": [0.35001, 0.85, 0, 0, 0.47222],
        "10217": [0.35001, 0.85, 0, 0, 0.47222],
        "10752": [0.25001, 0.75, 0, 0, 1.11111],
        "10753": [0.25001, 0.75, 0, 0, 1.11111],
        "10754": [0.25001, 0.75, 0, 0, 1.11111],
        "10756": [0.25001, 0.75, 0, 0, 0.83334],
        "10758": [0.25001, 0.75, 0, 0, 0.83334]
      },
      "Size2-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "40": [0.65002, 1.15, 0, 0, 0.59722],
        "41": [0.65002, 1.15, 0, 0, 0.59722],
        "47": [0.65002, 1.15, 0, 0, 0.81111],
        "91": [0.65002, 1.15, 0, 0, 0.47222],
        "92": [0.65002, 1.15, 0, 0, 0.81111],
        "93": [0.65002, 1.15, 0, 0, 0.47222],
        "123": [0.65002, 1.15, 0, 0, 0.66667],
        "125": [0.65002, 1.15, 0, 0, 0.66667],
        "160": [0, 0, 0, 0, 0.25],
        "710": [0, 0.75, 0, 0, 1.0],
        "732": [0, 0.75, 0, 0, 1.0],
        "770": [0, 0.75, 0, 0, 1.0],
        "771": [0, 0.75, 0, 0, 1.0],
        "8719": [0.55001, 1.05, 0, 0, 1.27778],
        "8720": [0.55001, 1.05, 0, 0, 1.27778],
        "8721": [0.55001, 1.05, 0, 0, 1.44445],
        "8730": [0.65002, 1.15, 0, 0, 1.0],
        "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
        "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
        "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
        "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
        "8896": [0.55001, 1.05, 0, 0, 1.11111],
        "8897": [0.55001, 1.05, 0, 0, 1.11111],
        "8898": [0.55001, 1.05, 0, 0, 1.11111],
        "8899": [0.55001, 1.05, 0, 0, 1.11111],
        "8968": [0.65002, 1.15, 0, 0, 0.52778],
        "8969": [0.65002, 1.15, 0, 0, 0.52778],
        "8970": [0.65002, 1.15, 0, 0, 0.52778],
        "8971": [0.65002, 1.15, 0, 0, 0.52778],
        "10216": [0.65002, 1.15, 0, 0, 0.61111],
        "10217": [0.65002, 1.15, 0, 0, 0.61111],
        "10752": [0.55001, 1.05, 0, 0, 1.51112],
        "10753": [0.55001, 1.05, 0, 0, 1.51112],
        "10754": [0.55001, 1.05, 0, 0, 1.51112],
        "10756": [0.55001, 1.05, 0, 0, 1.11111],
        "10758": [0.55001, 1.05, 0, 0, 1.11111]
      },
      "Size3-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "40": [0.95003, 1.45, 0, 0, 0.73611],
        "41": [0.95003, 1.45, 0, 0, 0.73611],
        "47": [0.95003, 1.45, 0, 0, 1.04445],
        "91": [0.95003, 1.45, 0, 0, 0.52778],
        "92": [0.95003, 1.45, 0, 0, 1.04445],
        "93": [0.95003, 1.45, 0, 0, 0.52778],
        "123": [0.95003, 1.45, 0, 0, 0.75],
        "125": [0.95003, 1.45, 0, 0, 0.75],
        "160": [0, 0, 0, 0, 0.25],
        "710": [0, 0.75, 0, 0, 1.44445],
        "732": [0, 0.75, 0, 0, 1.44445],
        "770": [0, 0.75, 0, 0, 1.44445],
        "771": [0, 0.75, 0, 0, 1.44445],
        "8730": [0.95003, 1.45, 0, 0, 1.0],
        "8968": [0.95003, 1.45, 0, 0, 0.58334],
        "8969": [0.95003, 1.45, 0, 0, 0.58334],
        "8970": [0.95003, 1.45, 0, 0, 0.58334],
        "8971": [0.95003, 1.45, 0, 0, 0.58334],
        "10216": [0.95003, 1.45, 0, 0, 0.75],
        "10217": [0.95003, 1.45, 0, 0, 0.75]
      },
      "Size4-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "40": [1.25003, 1.75, 0, 0, 0.79167],
        "41": [1.25003, 1.75, 0, 0, 0.79167],
        "47": [1.25003, 1.75, 0, 0, 1.27778],
        "91": [1.25003, 1.75, 0, 0, 0.58334],
        "92": [1.25003, 1.75, 0, 0, 1.27778],
        "93": [1.25003, 1.75, 0, 0, 0.58334],
        "123": [1.25003, 1.75, 0, 0, 0.80556],
        "125": [1.25003, 1.75, 0, 0, 0.80556],
        "160": [0, 0, 0, 0, 0.25],
        "710": [0, 0.825, 0, 0, 1.8889],
        "732": [0, 0.825, 0, 0, 1.8889],
        "770": [0, 0.825, 0, 0, 1.8889],
        "771": [0, 0.825, 0, 0, 1.8889],
        "8730": [1.25003, 1.75, 0, 0, 1.0],
        "8968": [1.25003, 1.75, 0, 0, 0.63889],
        "8969": [1.25003, 1.75, 0, 0, 0.63889],
        "8970": [1.25003, 1.75, 0, 0, 0.63889],
        "8971": [1.25003, 1.75, 0, 0, 0.63889],
        "9115": [0.64502, 1.155, 0, 0, 0.875],
        "9116": [1e-05, 0.6, 0, 0, 0.875],
        "9117": [0.64502, 1.155, 0, 0, 0.875],
        "9118": [0.64502, 1.155, 0, 0, 0.875],
        "9119": [1e-05, 0.6, 0, 0, 0.875],
        "9120": [0.64502, 1.155, 0, 0, 0.875],
        "9121": [0.64502, 1.155, 0, 0, 0.66667],
        "9122": [-0.00099, 0.601, 0, 0, 0.66667],
        "9123": [0.64502, 1.155, 0, 0, 0.66667],
        "9124": [0.64502, 1.155, 0, 0, 0.66667],
        "9125": [-0.00099, 0.601, 0, 0, 0.66667],
        "9126": [0.64502, 1.155, 0, 0, 0.66667],
        "9127": [1e-05, 0.9, 0, 0, 0.88889],
        "9128": [0.65002, 1.15, 0, 0, 0.88889],
        "9129": [0.90001, 0, 0, 0, 0.88889],
        "9130": [0, 0.3, 0, 0, 0.88889],
        "9131": [1e-05, 0.9, 0, 0, 0.88889],
        "9132": [0.65002, 1.15, 0, 0, 0.88889],
        "9133": [0.90001, 0, 0, 0, 0.88889],
        "9143": [0.88502, 0.915, 0, 0, 1.05556],
        "10216": [1.25003, 1.75, 0, 0, 0.80556],
        "10217": [1.25003, 1.75, 0, 0, 0.80556],
        "57344": [-0.00499, 0.605, 0, 0, 1.05556],
        "57345": [-0.00499, 0.605, 0, 0, 1.05556],
        "57680": [0, 0.12, 0, 0, 0.45],
        "57681": [0, 0.12, 0, 0, 0.45],
        "57682": [0, 0.12, 0, 0, 0.45],
        "57683": [0, 0.12, 0, 0, 0.45]
      },
      "Typewriter-Regular": {
        "32": [0, 0, 0, 0, 0.525],
        "33": [0, 0.61111, 0, 0, 0.525],
        "34": [0, 0.61111, 0, 0, 0.525],
        "35": [0, 0.61111, 0, 0, 0.525],
        "36": [0.08333, 0.69444, 0, 0, 0.525],
        "37": [0.08333, 0.69444, 0, 0, 0.525],
        "38": [0, 0.61111, 0, 0, 0.525],
        "39": [0, 0.61111, 0, 0, 0.525],
        "40": [0.08333, 0.69444, 0, 0, 0.525],
        "41": [0.08333, 0.69444, 0, 0, 0.525],
        "42": [0, 0.52083, 0, 0, 0.525],
        "43": [-0.08056, 0.53055, 0, 0, 0.525],
        "44": [0.13889, 0.125, 0, 0, 0.525],
        "45": [-0.08056, 0.53055, 0, 0, 0.525],
        "46": [0, 0.125, 0, 0, 0.525],
        "47": [0.08333, 0.69444, 0, 0, 0.525],
        "48": [0, 0.61111, 0, 0, 0.525],
        "49": [0, 0.61111, 0, 0, 0.525],
        "50": [0, 0.61111, 0, 0, 0.525],
        "51": [0, 0.61111, 0, 0, 0.525],
        "52": [0, 0.61111, 0, 0, 0.525],
        "53": [0, 0.61111, 0, 0, 0.525],
        "54": [0, 0.61111, 0, 0, 0.525],
        "55": [0, 0.61111, 0, 0, 0.525],
        "56": [0, 0.61111, 0, 0, 0.525],
        "57": [0, 0.61111, 0, 0, 0.525],
        "58": [0, 0.43056, 0, 0, 0.525],
        "59": [0.13889, 0.43056, 0, 0, 0.525],
        "60": [-0.05556, 0.55556, 0, 0, 0.525],
        "61": [-0.19549, 0.41562, 0, 0, 0.525],
        "62": [-0.05556, 0.55556, 0, 0, 0.525],
        "63": [0, 0.61111, 0, 0, 0.525],
        "64": [0, 0.61111, 0, 0, 0.525],
        "65": [0, 0.61111, 0, 0, 0.525],
        "66": [0, 0.61111, 0, 0, 0.525],
        "67": [0, 0.61111, 0, 0, 0.525],
        "68": [0, 0.61111, 0, 0, 0.525],
        "69": [0, 0.61111, 0, 0, 0.525],
        "70": [0, 0.61111, 0, 0, 0.525],
        "71": [0, 0.61111, 0, 0, 0.525],
        "72": [0, 0.61111, 0, 0, 0.525],
        "73": [0, 0.61111, 0, 0, 0.525],
        "74": [0, 0.61111, 0, 0, 0.525],
        "75": [0, 0.61111, 0, 0, 0.525],
        "76": [0, 0.61111, 0, 0, 0.525],
        "77": [0, 0.61111, 0, 0, 0.525],
        "78": [0, 0.61111, 0, 0, 0.525],
        "79": [0, 0.61111, 0, 0, 0.525],
        "80": [0, 0.61111, 0, 0, 0.525],
        "81": [0.13889, 0.61111, 0, 0, 0.525],
        "82": [0, 0.61111, 0, 0, 0.525],
        "83": [0, 0.61111, 0, 0, 0.525],
        "84": [0, 0.61111, 0, 0, 0.525],
        "85": [0, 0.61111, 0, 0, 0.525],
        "86": [0, 0.61111, 0, 0, 0.525],
        "87": [0, 0.61111, 0, 0, 0.525],
        "88": [0, 0.61111, 0, 0, 0.525],
        "89": [0, 0.61111, 0, 0, 0.525],
        "90": [0, 0.61111, 0, 0, 0.525],
        "91": [0.08333, 0.69444, 0, 0, 0.525],
        "92": [0.08333, 0.69444, 0, 0, 0.525],
        "93": [0.08333, 0.69444, 0, 0, 0.525],
        "94": [0, 0.61111, 0, 0, 0.525],
        "95": [0.09514, 0, 0, 0, 0.525],
        "96": [0, 0.61111, 0, 0, 0.525],
        "97": [0, 0.43056, 0, 0, 0.525],
        "98": [0, 0.61111, 0, 0, 0.525],
        "99": [0, 0.43056, 0, 0, 0.525],
        "100": [0, 0.61111, 0, 0, 0.525],
        "101": [0, 0.43056, 0, 0, 0.525],
        "102": [0, 0.61111, 0, 0, 0.525],
        "103": [0.22222, 0.43056, 0, 0, 0.525],
        "104": [0, 0.61111, 0, 0, 0.525],
        "105": [0, 0.61111, 0, 0, 0.525],
        "106": [0.22222, 0.61111, 0, 0, 0.525],
        "107": [0, 0.61111, 0, 0, 0.525],
        "108": [0, 0.61111, 0, 0, 0.525],
        "109": [0, 0.43056, 0, 0, 0.525],
        "110": [0, 0.43056, 0, 0, 0.525],
        "111": [0, 0.43056, 0, 0, 0.525],
        "112": [0.22222, 0.43056, 0, 0, 0.525],
        "113": [0.22222, 0.43056, 0, 0, 0.525],
        "114": [0, 0.43056, 0, 0, 0.525],
        "115": [0, 0.43056, 0, 0, 0.525],
        "116": [0, 0.55358, 0, 0, 0.525],
        "117": [0, 0.43056, 0, 0, 0.525],
        "118": [0, 0.43056, 0, 0, 0.525],
        "119": [0, 0.43056, 0, 0, 0.525],
        "120": [0, 0.43056, 0, 0, 0.525],
        "121": [0.22222, 0.43056, 0, 0, 0.525],
        "122": [0, 0.43056, 0, 0, 0.525],
        "123": [0.08333, 0.69444, 0, 0, 0.525],
        "124": [0.08333, 0.69444, 0, 0, 0.525],
        "125": [0.08333, 0.69444, 0, 0, 0.525],
        "126": [0, 0.61111, 0, 0, 0.525],
        "127": [0, 0.61111, 0, 0, 0.525],
        "160": [0, 0, 0, 0, 0.525],
        "176": [0, 0.61111, 0, 0, 0.525],
        "184": [0.19445, 0, 0, 0, 0.525],
        "305": [0, 0.43056, 0, 0, 0.525],
        "567": [0.22222, 0.43056, 0, 0, 0.525],
        "711": [0, 0.56597, 0, 0, 0.525],
        "713": [0, 0.56555, 0, 0, 0.525],
        "714": [0, 0.61111, 0, 0, 0.525],
        "715": [0, 0.61111, 0, 0, 0.525],
        "728": [0, 0.61111, 0, 0, 0.525],
        "730": [0, 0.61111, 0, 0, 0.525],
        "770": [0, 0.61111, 0, 0, 0.525],
        "771": [0, 0.61111, 0, 0, 0.525],
        "776": [0, 0.61111, 0, 0, 0.525],
        "915": [0, 0.61111, 0, 0, 0.525],
        "916": [0, 0.61111, 0, 0, 0.525],
        "920": [0, 0.61111, 0, 0, 0.525],
        "923": [0, 0.61111, 0, 0, 0.525],
        "926": [0, 0.61111, 0, 0, 0.525],
        "928": [0, 0.61111, 0, 0, 0.525],
        "931": [0, 0.61111, 0, 0, 0.525],
        "933": [0, 0.61111, 0, 0, 0.525],
        "934": [0, 0.61111, 0, 0, 0.525],
        "936": [0, 0.61111, 0, 0, 0.525],
        "937": [0, 0.61111, 0, 0, 0.525],
        "8216": [0, 0.61111, 0, 0, 0.525],
        "8217": [0, 0.61111, 0, 0, 0.525],
        "8242": [0, 0.61111, 0, 0, 0.525],
        "9251": [0.11111, 0.21944, 0, 0, 0.525]
      }
    };
    var sigmasAndXis = {
      slant: [0.250, 0.250, 0.250],
      space: [0.000, 0.000, 0.000],
      stretch: [0.000, 0.000, 0.000],
      shrink: [0.000, 0.000, 0.000],
      xHeight: [0.431, 0.431, 0.431],
      quad: [1.000, 1.171, 1.472],
      extraSpace: [0.000, 0.000, 0.000],
      num1: [0.677, 0.732, 0.925],
      num2: [0.394, 0.384, 0.387],
      num3: [0.444, 0.471, 0.504],
      denom1: [0.686, 0.752, 1.025],
      denom2: [0.345, 0.344, 0.532],
      sup1: [0.413, 0.503, 0.504],
      sup2: [0.363, 0.431, 0.404],
      sup3: [0.289, 0.286, 0.294],
      sub1: [0.150, 0.143, 0.200],
      sub2: [0.247, 0.286, 0.400],
      supDrop: [0.386, 0.353, 0.494],
      subDrop: [0.050, 0.071, 0.100],
      delim1: [2.390, 1.700, 1.980],
      delim2: [1.010, 1.157, 1.420],
      axisHeight: [0.250, 0.250, 0.250],
      defaultRuleThickness: [0.04, 0.049, 0.049],
      bigOpSpacing1: [0.111, 0.111, 0.111],
      bigOpSpacing2: [0.166, 0.166, 0.166],
      bigOpSpacing3: [0.2, 0.2, 0.2],
      bigOpSpacing4: [0.6, 0.611, 0.611],
      bigOpSpacing5: [0.1, 0.143, 0.143],
      sqrtRuleThickness: [0.04, 0.04, 0.04],
      ptPerEm: [10.0, 10.0, 10.0],
      doubleRuleSep: [0.2, 0.2, 0.2],
      arrayRuleWidth: [0.04, 0.04, 0.04],
      fboxsep: [0.3, 0.3, 0.3],
      fboxrule: [0.04, 0.04, 0.04]
    };
    var extraCharacterMap = {
      '': 'A',
      '': 'D',
      '': 'o',
      '': 'a',
      '': 'd',
      '': 'o',
      '': 'A',
      '': 'B',
      '': 'B',
      '': 'F',
      '': 'A',
      '': 'E',
      '': 'K',
      '': '3',
      '': 'N',
      '': 'N',
      '': 'K',
      '': 'N',
      '': 'M',
      '': 'H',
      '': 'O',
      '': 'N',
      '': 'P',
      '': 'C',
      '': 'T',
      '': 'y',
      '': 'O',
      '': 'X',
      '': 'U',
      '': 'h',
      '': 'W',
      '': 'W',
      '': 'B',
      '': 'X',
      '': 'B',
      '': '3',
      '': 'X',
      '': 'R',
      '': 'a',
      '': 'b',
      '': 'a',
      '': 'r',
      '': 'y',
      '': 'e',
      '': 'm',
      '': 'e',
      '': 'n',
      '': 'n',
      '': 'n',
      '': 'n',
      '': 'm',
      '': 'n',
      '': 'o',
      '': 'n',
      '': 'p',
      '': 'c',
      '': 'o',
      '': 'y',
      '': 'b',
      '': 'x',
      '': 'n',
      '': 'n',
      '': 'w',
      '': 'w',
      '': 'a',
      '': 'm',
      '': 'a',
      '': 'e',
      '': 'm',
      '': 'r'
    };
    function setFontMetrics(fontName, metrics) {
      fontMetricsData[fontName] = metrics;
    }
    function getCharacterMetrics(character, font, mode) {
      if (!fontMetricsData[font]) {
        throw new Error("Font metrics not found for font: " + font + ".");
      }
      var ch = character.charCodeAt(0);
      var metrics = fontMetricsData[font][ch];
      if (!metrics && character[0] in extraCharacterMap) {
        ch = extraCharacterMap[character[0]].charCodeAt(0);
        metrics = fontMetricsData[font][ch];
      }
      if (!metrics && mode === 'text') {
        if (supportedCodepoint(ch)) {
          metrics = fontMetricsData[font][77];
        }
      }
      if (metrics) {
        return {
          depth: metrics[0],
          height: metrics[1],
          italic: metrics[2],
          skew: metrics[3],
          width: metrics[4]
        };
      }
    }
    var fontMetricsBySizeIndex = {};
    function getGlobalMetrics(size) {
      var sizeIndex;
      if (size >= 5) {
        sizeIndex = 0;
      } else if (size >= 3) {
        sizeIndex = 1;
      } else {
        sizeIndex = 2;
      }
      if (!fontMetricsBySizeIndex[sizeIndex]) {
        var metrics = fontMetricsBySizeIndex[sizeIndex] = {
          cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
        };
        for (var key in sigmasAndXis) {
          if (sigmasAndXis.hasOwnProperty(key)) {
            metrics[key] = sigmasAndXis[key][sizeIndex];
          }
        }
      }
      return fontMetricsBySizeIndex[sizeIndex];
    }
    var sizeStyleMap = [
    [1, 1, 1],
    [2, 1, 1],
    [3, 1, 1],
    [4, 2, 1],
    [5, 2, 1],
    [6, 3, 1],
    [7, 4, 2],
    [8, 6, 3],
    [9, 7, 6],
    [10, 8, 7],
    [11, 10, 9]
    ];
    var sizeMultipliers = [
    0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.44, 1.728, 2.074, 2.488];
    var sizeAtStyle = function sizeAtStyle(size, style) {
      return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
    };
    class Options {
      constructor(data) {
        this.style = void 0;
        this.color = void 0;
        this.size = void 0;
        this.textSize = void 0;
        this.phantom = void 0;
        this.font = void 0;
        this.fontFamily = void 0;
        this.fontWeight = void 0;
        this.fontShape = void 0;
        this.sizeMultiplier = void 0;
        this.maxSize = void 0;
        this.minRuleThickness = void 0;
        this._fontMetrics = void 0;
        this.style = data.style;
        this.color = data.color;
        this.size = data.size || Options.BASESIZE;
        this.textSize = data.textSize || this.size;
        this.phantom = !!data.phantom;
        this.font = data.font || "";
        this.fontFamily = data.fontFamily || "";
        this.fontWeight = data.fontWeight || '';
        this.fontShape = data.fontShape || '';
        this.sizeMultiplier = sizeMultipliers[this.size - 1];
        this.maxSize = data.maxSize;
        this.minRuleThickness = data.minRuleThickness;
        this._fontMetrics = undefined;
      }
      extend(extension) {
        var data = {
          style: this.style,
          size: this.size,
          textSize: this.textSize,
          color: this.color,
          phantom: this.phantom,
          font: this.font,
          fontFamily: this.fontFamily,
          fontWeight: this.fontWeight,
          fontShape: this.fontShape,
          maxSize: this.maxSize,
          minRuleThickness: this.minRuleThickness
        };
        for (var key in extension) {
          if (extension.hasOwnProperty(key)) {
            data[key] = extension[key];
          }
        }
        return new Options(data);
      }
      havingStyle(style) {
        if (this.style === style) {
          return this;
        } else {
          return this.extend({
            style: style,
            size: sizeAtStyle(this.textSize, style)
          });
        }
      }
      havingCrampedStyle() {
        return this.havingStyle(this.style.cramp());
      }
      havingSize(size) {
        if (this.size === size && this.textSize === size) {
          return this;
        } else {
          return this.extend({
            style: this.style.text(),
            size: size,
            textSize: size,
            sizeMultiplier: sizeMultipliers[size - 1]
          });
        }
      }
      havingBaseStyle(style) {
        style = style || this.style.text();
        var wantSize = sizeAtStyle(Options.BASESIZE, style);
        if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
          return this;
        } else {
          return this.extend({
            style: style,
            size: wantSize
          });
        }
      }
      havingBaseSizing() {
        var size;
        switch (this.style.id) {
          case 4:
          case 5:
            size = 3;
            break;
          case 6:
          case 7:
            size = 1;
            break;
          default:
            size = 6;
        }
        return this.extend({
          style: this.style.text(),
          size: size
        });
      }
      withColor(color) {
        return this.extend({
          color: color
        });
      }
      withPhantom() {
        return this.extend({
          phantom: true
        });
      }
      withFont(font) {
        return this.extend({
          font
        });
      }
      withTextFontFamily(fontFamily) {
        return this.extend({
          fontFamily,
          font: ""
        });
      }
      withTextFontWeight(fontWeight) {
        return this.extend({
          fontWeight,
          font: ""
        });
      }
      withTextFontShape(fontShape) {
        return this.extend({
          fontShape,
          font: ""
        });
      }
      sizingClasses(oldOptions) {
        if (oldOptions.size !== this.size) {
          return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
        } else {
          return [];
        }
      }
      baseSizingClasses() {
        if (this.size !== Options.BASESIZE) {
          return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
        } else {
          return [];
        }
      }
      fontMetrics() {
        if (!this._fontMetrics) {
          this._fontMetrics = getGlobalMetrics(this.size);
        }
        return this._fontMetrics;
      }
      getColor() {
        if (this.phantom) {
          return "transparent";
        } else {
          return this.color;
        }
      }
    }
    Options.BASESIZE = 6;
    var ptPerUnit = {
      "pt": 1,
      "mm": 7227 / 2540,
      "cm": 7227 / 254,
      "in": 72.27,
      "bp": 803 / 800,
      "pc": 12,
      "dd": 1238 / 1157,
      "cc": 14856 / 1157,
      "nd": 685 / 642,
      "nc": 1370 / 107,
      "sp": 1 / 65536,
      "px": 803 / 800
    };
    var relativeUnit = {
      "ex": true,
      "em": true,
      "mu": true
    };
    var validUnit = function validUnit(unit) {
      if (typeof unit !== "string") {
        unit = unit.unit;
      }
      return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
    };
    var calculateSize = function calculateSize(sizeValue, options) {
      var scale;
      if (sizeValue.unit in ptPerUnit) {
        scale = ptPerUnit[sizeValue.unit]
        / options.fontMetrics().ptPerEm
        / options.sizeMultiplier;
      } else if (sizeValue.unit === "mu") {
        scale = options.fontMetrics().cssEmPerMu;
      } else {
        var unitOptions;
        if (options.style.isTight()) {
          unitOptions = options.havingStyle(options.style.text());
        } else {
          unitOptions = options;
        }
        if (sizeValue.unit === "ex") {
          scale = unitOptions.fontMetrics().xHeight;
        } else if (sizeValue.unit === "em") {
          scale = unitOptions.fontMetrics().quad;
        } else {
          throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
        }
        if (unitOptions !== options) {
          scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
        }
      }
      return Math.min(sizeValue.number * scale, options.maxSize);
    };
    var makeEm = function makeEm(n) {
      return +n.toFixed(4) + "em";
    };
    var createClass = function createClass(classes) {
      return classes.filter(cls => cls).join(" ");
    };
    var initNode = function initNode(classes, options, style) {
      this.classes = classes || [];
      this.attributes = {};
      this.height = 0;
      this.depth = 0;
      this.maxFontSize = 0;
      this.style = style || {};
      if (options) {
        if (options.style.isTight()) {
          this.classes.push("mtight");
        }
        var color = options.getColor();
        if (color) {
          this.style.color = color;
        }
      }
    };
    var toNode = function toNode(tagName) {
      var node = document.createElement(tagName);
      node.className = createClass(this.classes);
      for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
          node.style[style] = this.style[style];
        }
      }
      for (var attr in this.attributes) {
        if (this.attributes.hasOwnProperty(attr)) {
          node.setAttribute(attr, this.attributes[attr]);
        }
      }
      for (var i = 0; i < this.children.length; i++) {
        node.appendChild(this.children[i].toNode());
      }
      return node;
    };
    var toMarkup = function toMarkup(tagName) {
      var markup = "<" + tagName;
      if (this.classes.length) {
        markup += " class=\"" + utils.escape(createClass(this.classes)) + "\"";
      }
      var styles = "";
      for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
          styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
      }
      if (styles) {
        markup += " style=\"" + utils.escape(styles) + "\"";
      }
      for (var attr in this.attributes) {
        if (this.attributes.hasOwnProperty(attr)) {
          markup += " " + attr + "=\"" + utils.escape(this.attributes[attr]) + "\"";
        }
      }
      markup += ">";
      for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
      }
      markup += "</" + tagName + ">";
      return markup;
    };
    class Span {
      constructor(classes, children, options, style) {
        this.children = void 0;
        this.attributes = void 0;
        this.classes = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.width = void 0;
        this.maxFontSize = void 0;
        this.style = void 0;
        initNode.call(this, classes, options, style);
        this.children = children || [];
      }
      setAttribute(attribute, value) {
        this.attributes[attribute] = value;
      }
      hasClass(className) {
        return utils.contains(this.classes, className);
      }
      toNode() {
        return toNode.call(this, "span");
      }
      toMarkup() {
        return toMarkup.call(this, "span");
      }
    }
    class Anchor {
      constructor(href, classes, children, options) {
        this.children = void 0;
        this.attributes = void 0;
        this.classes = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.maxFontSize = void 0;
        this.style = void 0;
        initNode.call(this, classes, options);
        this.children = children || [];
        this.setAttribute('href', href);
      }
      setAttribute(attribute, value) {
        this.attributes[attribute] = value;
      }
      hasClass(className) {
        return utils.contains(this.classes, className);
      }
      toNode() {
        return toNode.call(this, "a");
      }
      toMarkup() {
        return toMarkup.call(this, "a");
      }
    }
    class Img {
      constructor(src, alt, style) {
        this.src = void 0;
        this.alt = void 0;
        this.classes = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.maxFontSize = void 0;
        this.style = void 0;
        this.alt = alt;
        this.src = src;
        this.classes = ["mord"];
        this.style = style;
      }
      hasClass(className) {
        return utils.contains(this.classes, className);
      }
      toNode() {
        var node = document.createElement("img");
        node.src = this.src;
        node.alt = this.alt;
        node.className = "mord";
        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            node.style[style] = this.style[style];
          }
        }
        return node;
      }
      toMarkup() {
        var markup = "<img  src='" + this.src + " 'alt='" + this.alt + "' ";
        var styles = "";
        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
          }
        }
        if (styles) {
          markup += " style=\"" + utils.escape(styles) + "\"";
        }
        markup += "'/>";
        return markup;
      }
    }
    var iCombinations = {
      '': '\u0131\u0302',
      '': '\u0131\u0308',
      '': '\u0131\u0301',
      '': '\u0131\u0300'
    };
    class SymbolNode {
      constructor(text, height, depth, italic, skew, width, classes, style) {
        this.text = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.italic = void 0;
        this.skew = void 0;
        this.width = void 0;
        this.maxFontSize = void 0;
        this.classes = void 0;
        this.style = void 0;
        this.text = text;
        this.height = height || 0;
        this.depth = depth || 0;
        this.italic = italic || 0;
        this.skew = skew || 0;
        this.width = width || 0;
        this.classes = classes || [];
        this.style = style || {};
        this.maxFontSize = 0;
        var script = scriptFromCodepoint(this.text.charCodeAt(0));
        if (script) {
          this.classes.push(script + "_fallback");
        }
        if (/[]/.test(this.text)) {
          this.text = iCombinations[this.text];
        }
      }
      hasClass(className) {
        return utils.contains(this.classes, className);
      }
      toNode() {
        var node = document.createTextNode(this.text);
        var span = null;
        if (this.italic > 0) {
          span = document.createElement("span");
          span.style.marginRight = makeEm(this.italic);
        }
        if (this.classes.length > 0) {
          span = span || document.createElement("span");
          span.className = createClass(this.classes);
        }
        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            span = span || document.createElement("span");
            span.style[style] = this.style[style];
          }
        }
        if (span) {
          span.appendChild(node);
          return span;
        } else {
          return node;
        }
      }
      toMarkup() {
        var needsSpan = false;
        var markup = "<span";
        if (this.classes.length) {
          needsSpan = true;
          markup += " class=\"";
          markup += utils.escape(createClass(this.classes));
          markup += "\"";
        }
        var styles = "";
        if (this.italic > 0) {
          styles += "margin-right:" + this.italic + "em;";
        }
        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
          }
        }
        if (styles) {
          needsSpan = true;
          markup += " style=\"" + utils.escape(styles) + "\"";
        }
        var escaped = utils.escape(this.text);
        if (needsSpan) {
          markup += ">";
          markup += escaped;
          markup += "</span>";
          return markup;
        } else {
          return escaped;
        }
      }
    }
    class SvgNode {
      constructor(children, attributes) {
        this.children = void 0;
        this.attributes = void 0;
        this.children = children || [];
        this.attributes = attributes || {};
      }
      toNode() {
        var svgNS = "http://www.w3.org/2000/svg";
        var node = document.createElementNS(svgNS, "svg");
        for (var attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            node.setAttribute(attr, this.attributes[attr]);
          }
        }
        for (var i = 0; i < this.children.length; i++) {
          node.appendChild(this.children[i].toNode());
        }
        return node;
      }
      toMarkup() {
        var markup = "<svg xmlns=\"http://www.w3.org/2000/svg\"";
        for (var attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "='" + this.attributes[attr] + "'";
          }
        }
        markup += ">";
        for (var i = 0; i < this.children.length; i++) {
          markup += this.children[i].toMarkup();
        }
        markup += "</svg>";
        return markup;
      }
    }
    class PathNode {
      constructor(pathName, alternate) {
        this.pathName = void 0;
        this.alternate = void 0;
        this.pathName = pathName;
        this.alternate = alternate;
      }
      toNode() {
        var svgNS = "http://www.w3.org/2000/svg";
        var node = document.createElementNS(svgNS, "path");
        if (this.alternate) {
          node.setAttribute("d", this.alternate);
        } else {
          node.setAttribute("d", path[this.pathName]);
        }
        return node;
      }
      toMarkup() {
        if (this.alternate) {
          return "<path d='" + this.alternate + "'/>";
        } else {
          return "<path d='" + path[this.pathName] + "'/>";
        }
      }
    }
    class LineNode {
      constructor(attributes) {
        this.attributes = void 0;
        this.attributes = attributes || {};
      }
      toNode() {
        var svgNS = "http://www.w3.org/2000/svg";
        var node = document.createElementNS(svgNS, "line");
        for (var attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            node.setAttribute(attr, this.attributes[attr]);
          }
        }
        return node;
      }
      toMarkup() {
        var markup = "<line";
        for (var attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "='" + this.attributes[attr] + "'";
          }
        }
        markup += "/>";
        return markup;
      }
    }
    function assertSymbolDomNode(group) {
      if (group instanceof SymbolNode) {
        return group;
      } else {
        throw new Error("Expected symbolNode but got " + String(group) + ".");
      }
    }
    function assertSpan(group) {
      if (group instanceof Span) {
        return group;
      } else {
        throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
      }
    }
    var ATOMS = {
      "bin": 1,
      "close": 1,
      "inner": 1,
      "open": 1,
      "punct": 1,
      "rel": 1
    };
    var NON_ATOMS = {
      "accent-token": 1,
      "mathord": 1,
      "op-token": 1,
      "spacing": 1,
      "textord": 1
    };
    var symbols = {
      "math": {},
      "text": {}
    };
    function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
      symbols[mode][name] = {
        font,
        group,
        replace
      };
      if (acceptUnicodeChar && replace) {
        symbols[mode][replace] = symbols[mode][name];
      }
    }
    var math = "math";
    var text = "text";
    var main = "main";
    var ams = "ams";
    var accent = "accent-token";
    var bin = "bin";
    var close = "close";
    var inner = "inner";
    var mathord = "mathord";
    var op = "op-token";
    var open = "open";
    var punct = "punct";
    var rel = "rel";
    var spacing = "spacing";
    var textord = "textord";
    defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
    defineSymbol(math, main, rel, "\u227a", "\\prec", true);
    defineSymbol(math, main, rel, "\u227b", "\\succ", true);
    defineSymbol(math, main, rel, "\u223c", "\\sim", true);
    defineSymbol(math, main, rel, "\u22a5", "\\perp");
    defineSymbol(math, main, rel, "\u2aaf", "\\preceq", true);
    defineSymbol(math, main, rel, "\u2ab0", "\\succeq", true);
    defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
    defineSymbol(math, main, rel, "\u2223", "\\mid", true);
    defineSymbol(math, main, rel, "\u226a", "\\ll", true);
    defineSymbol(math, main, rel, "\u226b", "\\gg", true);
    defineSymbol(math, main, rel, "\u224d", "\\asymp", true);
    defineSymbol(math, main, rel, "\u2225", "\\parallel");
    defineSymbol(math, main, rel, "\u22c8", "\\bowtie", true);
    defineSymbol(math, main, rel, "\u2323", "\\smile", true);
    defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
    defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
    defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
    defineSymbol(math, main, rel, "\u2322", "\\frown", true);
    defineSymbol(math, main, rel, "\u220b", "\\ni", true);
    defineSymbol(math, main, rel, "\u221d", "\\propto", true);
    defineSymbol(math, main, rel, "\u22a2", "\\vdash", true);
    defineSymbol(math, main, rel, "\u22a3", "\\dashv", true);
    defineSymbol(math, main, rel, "\u220b", "\\owns");
    defineSymbol(math, main, punct, "\u002e", "\\ldotp");
    defineSymbol(math, main, punct, "\u22c5", "\\cdotp");
    defineSymbol(math, main, textord, "\u0023", "\\#");
    defineSymbol(text, main, textord, "\u0023", "\\#");
    defineSymbol(math, main, textord, "\u0026", "\\&");
    defineSymbol(text, main, textord, "\u0026", "\\&");
    defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
    defineSymbol(math, main, textord, "\u2200", "\\forall", true);
    defineSymbol(math, main, textord, "\u210f", "\\hbar", true);
    defineSymbol(math, main, textord, "\u2203", "\\exists", true);
    defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
    defineSymbol(math, main, textord, "\u266d", "\\flat", true);
    defineSymbol(math, main, textord, "\u2113", "\\ell", true);
    defineSymbol(math, main, textord, "\u266e", "\\natural", true);
    defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
    defineSymbol(math, main, textord, "\u2118", "\\wp", true);
    defineSymbol(math, main, textord, "\u266f", "\\sharp", true);
    defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
    defineSymbol(math, main, textord, "\u211c", "\\Re", true);
    defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
    defineSymbol(math, main, textord, "\u2111", "\\Im", true);
    defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
    defineSymbol(math, main, textord, "\u00a7", "\\S", true);
    defineSymbol(text, main, textord, "\u00a7", "\\S");
    defineSymbol(math, main, textord, "\u00b6", "\\P", true);
    defineSymbol(text, main, textord, "\u00b6", "\\P");
    defineSymbol(math, main, textord, "\u2020", "\\dag");
    defineSymbol(text, main, textord, "\u2020", "\\dag");
    defineSymbol(text, main, textord, "\u2020", "\\textdagger");
    defineSymbol(math, main, textord, "\u2021", "\\ddag");
    defineSymbol(text, main, textord, "\u2021", "\\ddag");
    defineSymbol(text, main, textord, "\u2021", "\\textdaggerdbl");
    defineSymbol(math, main, close, "\u23b1", "\\rmoustache", true);
    defineSymbol(math, main, open, "\u23b0", "\\lmoustache", true);
    defineSymbol(math, main, close, "\u27ef", "\\rgroup", true);
    defineSymbol(math, main, open, "\u27ee", "\\lgroup", true);
    defineSymbol(math, main, bin, "\u2213", "\\mp", true);
    defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
    defineSymbol(math, main, bin, "\u228e", "\\uplus", true);
    defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
    defineSymbol(math, main, bin, "\u2217", "\\ast");
    defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
    defineSymbol(math, main, bin, "\u25ef", "\\bigcirc", true);
    defineSymbol(math, main, bin, "\u2219", "\\bullet", true);
    defineSymbol(math, main, bin, "\u2021", "\\ddagger");
    defineSymbol(math, main, bin, "\u2240", "\\wr", true);
    defineSymbol(math, main, bin, "\u2a3f", "\\amalg");
    defineSymbol(math, main, bin, "\u0026", "\\And");
    defineSymbol(math, main, rel, "\u27f5", "\\longleftarrow", true);
    defineSymbol(math, main, rel, "\u21d0", "\\Leftarrow", true);
    defineSymbol(math, main, rel, "\u27f8", "\\Longleftarrow", true);
    defineSymbol(math, main, rel, "\u27f6", "\\longrightarrow", true);
    defineSymbol(math, main, rel, "\u21d2", "\\Rightarrow", true);
    defineSymbol(math, main, rel, "\u27f9", "\\Longrightarrow", true);
    defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
    defineSymbol(math, main, rel, "\u27f7", "\\longleftrightarrow", true);
    defineSymbol(math, main, rel, "\u21d4", "\\Leftrightarrow", true);
    defineSymbol(math, main, rel, "\u27fa", "\\Longleftrightarrow", true);
    defineSymbol(math, main, rel, "\u21a6", "\\mapsto", true);
    defineSymbol(math, main, rel, "\u27fc", "\\longmapsto", true);
    defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
    defineSymbol(math, main, rel, "\u21a9", "\\hookleftarrow", true);
    defineSymbol(math, main, rel, "\u21aa", "\\hookrightarrow", true);
    defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
    defineSymbol(math, main, rel, "\u21bc", "\\leftharpoonup", true);
    defineSymbol(math, main, rel, "\u21c0", "\\rightharpoonup", true);
    defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
    defineSymbol(math, main, rel, "\u21bd", "\\leftharpoondown", true);
    defineSymbol(math, main, rel, "\u21c1", "\\rightharpoondown", true);
    defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
    defineSymbol(math, main, rel, "\u21cc", "\\rightleftharpoons", true);
    defineSymbol(math, ams, rel, "\u226e", "\\nless", true);
    defineSymbol(math, ams, rel, "\ue010", "\\@nleqslant");
    defineSymbol(math, ams, rel, "\ue011", "\\@nleqq");
    defineSymbol(math, ams, rel, "\u2a87", "\\lneq", true);
    defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
    defineSymbol(math, ams, rel, "\ue00c", "\\@lvertneqq");
    defineSymbol(math, ams, rel, "\u22e6", "\\lnsim", true);
    defineSymbol(math, ams, rel, "\u2a89", "\\lnapprox", true);
    defineSymbol(math, ams, rel, "\u2280", "\\nprec", true);
    defineSymbol(math, ams, rel, "\u22e0", "\\npreceq", true);
    defineSymbol(math, ams, rel, "\u22e8", "\\precnsim", true);
    defineSymbol(math, ams, rel, "\u2ab9", "\\precnapprox", true);
    defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
    defineSymbol(math, ams, rel, "\ue006", "\\@nshortmid");
    defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
    defineSymbol(math, ams, rel, "\u22ac", "\\nvdash", true);
    defineSymbol(math, ams, rel, "\u22ad", "\\nvDash", true);
    defineSymbol(math, ams, rel, "\u22ea", "\\ntriangleleft");
    defineSymbol(math, ams, rel, "\u22ec", "\\ntrianglelefteq", true);
    defineSymbol(math, ams, rel, "\u228a", "\\subsetneq", true);
    defineSymbol(math, ams, rel, "\ue01a", "\\@varsubsetneq");
    defineSymbol(math, ams, rel, "\u2acb", "\\subsetneqq", true);
    defineSymbol(math, ams, rel, "\ue017", "\\@varsubsetneqq");
    defineSymbol(math, ams, rel, "\u226f", "\\ngtr", true);
    defineSymbol(math, ams, rel, "\ue00f", "\\@ngeqslant");
    defineSymbol(math, ams, rel, "\ue00e", "\\@ngeqq");
    defineSymbol(math, ams, rel, "\u2a88", "\\gneq", true);
    defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
    defineSymbol(math, ams, rel, "\ue00d", "\\@gvertneqq");
    defineSymbol(math, ams, rel, "\u22e7", "\\gnsim", true);
    defineSymbol(math, ams, rel, "\u2a8a", "\\gnapprox", true);
    defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true);
    defineSymbol(math, ams, rel, "\u22e1", "\\nsucceq", true);
    defineSymbol(math, ams, rel, "\u22e9", "\\succnsim", true);
    defineSymbol(math, ams, rel, "\u2aba", "\\succnapprox", true);
    defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
    defineSymbol(math, ams, rel, "\ue007", "\\@nshortparallel");
    defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
    defineSymbol(math, ams, rel, "\u22af", "\\nVDash", true);
    defineSymbol(math, ams, rel, "\u22eb", "\\ntriangleright");
    defineSymbol(math, ams, rel, "\u22ed", "\\ntrianglerighteq", true);
    defineSymbol(math, ams, rel, "\ue018", "\\@nsupseteqq");
    defineSymbol(math, ams, rel, "\u228b", "\\supsetneq", true);
    defineSymbol(math, ams, rel, "\ue01b", "\\@varsupsetneq");
    defineSymbol(math, ams, rel, "\u2acc", "\\supsetneqq", true);
    defineSymbol(math, ams, rel, "\ue019", "\\@varsupsetneqq");
    defineSymbol(math, ams, rel, "\u22ae", "\\nVdash", true);
    defineSymbol(math, ams, rel, "\u2ab5", "\\precneqq", true);
    defineSymbol(math, ams, rel, "\u2ab6", "\\succneqq", true);
    defineSymbol(math, ams, rel, "\ue016", "\\@nsubseteqq");
    defineSymbol(math, ams, bin, "\u22b4", "\\unlhd");
    defineSymbol(math, ams, bin, "\u22b5", "\\unrhd");
    defineSymbol(math, ams, rel, "\u219a", "\\nleftarrow", true);
    defineSymbol(math, ams, rel, "\u219b", "\\nrightarrow", true);
    defineSymbol(math, ams, rel, "\u21cd", "\\nLeftarrow", true);
    defineSymbol(math, ams, rel, "\u21cf", "\\nRightarrow", true);
    defineSymbol(math, ams, rel, "\u21ae", "\\nleftrightarrow", true);
    defineSymbol(math, ams, rel, "\u21ce", "\\nLeftrightarrow", true);
    defineSymbol(math, ams, rel, "\u25b3", "\\vartriangle");
    defineSymbol(math, ams, textord, "\u210f", "\\hslash");
    defineSymbol(math, ams, textord, "\u25bd", "\\triangledown");
    defineSymbol(math, ams, textord, "\u25ca", "\\lozenge");
    defineSymbol(math, ams, textord, "\u24c8", "\\circledS");
    defineSymbol(math, ams, textord, "\u00ae", "\\circledR");
    defineSymbol(text, ams, textord, "\u00ae", "\\circledR");
    defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
    defineSymbol(math, ams, textord, "\u2204", "\\nexists");
    defineSymbol(math, ams, textord, "\u2127", "\\mho");
    defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
    defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
    defineSymbol(math, ams, textord, "\u2035", "\\backprime");
    defineSymbol(math, ams, textord, "\u25b2", "\\blacktriangle");
    defineSymbol(math, ams, textord, "\u25bc", "\\blacktriangledown");
    defineSymbol(math, ams, textord, "\u25a0", "\\blacksquare");
    defineSymbol(math, ams, textord, "\u29eb", "\\blacklozenge");
    defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
    defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
    defineSymbol(math, ams, textord, "\u2201", "\\complement", true);
    defineSymbol(math, ams, textord, "\u00f0", "\\eth", true);
    defineSymbol(text, main, textord, "\u00f0", "\u00f0");
    defineSymbol(math, ams, textord, "\u2571", "\\diagup");
    defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
    defineSymbol(math, ams, textord, "\u25a1", "\\square");
    defineSymbol(math, ams, textord, "\u25a1", "\\Box");
    defineSymbol(math, ams, textord, "\u25ca", "\\Diamond");
    defineSymbol(math, ams, textord, "\u00a5", "\\yen", true);
    defineSymbol(text, ams, textord, "\u00a5", "\\yen", true);
    defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
    defineSymbol(text, ams, textord, "\u2713", "\\checkmark");
    defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
    defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
    defineSymbol(math, ams, textord, "\u2137", "\\gimel", true);
    defineSymbol(math, ams, textord, "\u03dd", "\\digamma", true);
    defineSymbol(math, ams, textord, "\u03f0", "\\varkappa");
    defineSymbol(math, ams, open, "\u250c", "\\@ulcorner", true);
    defineSymbol(math, ams, close, "\u2510", "\\@urcorner", true);
    defineSymbol(math, ams, open, "\u2514", "\\@llcorner", true);
    defineSymbol(math, ams, close, "\u2518", "\\@lrcorner", true);
    defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
    defineSymbol(math, ams, rel, "\u2a7d", "\\leqslant", true);
    defineSymbol(math, ams, rel, "\u2a95", "\\eqslantless", true);
    defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
    defineSymbol(math, ams, rel, "\u2a85", "\\lessapprox", true);
    defineSymbol(math, ams, rel, "\u224a", "\\approxeq", true);
    defineSymbol(math, ams, bin, "\u22d6", "\\lessdot");
    defineSymbol(math, ams, rel, "\u22d8", "\\lll", true);
    defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
    defineSymbol(math, ams, rel, "\u22da", "\\lesseqgtr", true);
    defineSymbol(math, ams, rel, "\u2a8b", "\\lesseqqgtr", true);
    defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
    defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
    defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
    defineSymbol(math, ams, rel, "\u223d", "\\backsim", true);
    defineSymbol(math, ams, rel, "\u22cd", "\\backsimeq", true);
    defineSymbol(math, ams, rel, "\u2ac5", "\\subseteqq", true);
    defineSymbol(math, ams, rel, "\u22d0", "\\Subset", true);
    defineSymbol(math, ams, rel, "\u228f", "\\sqsubset", true);
    defineSymbol(math, ams, rel, "\u227c", "\\preccurlyeq", true);
    defineSymbol(math, ams, rel, "\u22de", "\\curlyeqprec", true);
    defineSymbol(math, ams, rel, "\u227e", "\\precsim", true);
    defineSymbol(math, ams, rel, "\u2ab7", "\\precapprox", true);
    defineSymbol(math, ams, rel, "\u22b2", "\\vartriangleleft");
    defineSymbol(math, ams, rel, "\u22b4", "\\trianglelefteq");
    defineSymbol(math, ams, rel, "\u22a8", "\\vDash", true);
    defineSymbol(math, ams, rel, "\u22aa", "\\Vvdash", true);
    defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
    defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
    defineSymbol(math, ams, rel, "\u224f", "\\bumpeq", true);
    defineSymbol(math, ams, rel, "\u224e", "\\Bumpeq", true);
    defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
    defineSymbol(math, ams, rel, "\u2a7e", "\\geqslant", true);
    defineSymbol(math, ams, rel, "\u2a96", "\\eqslantgtr", true);
    defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
    defineSymbol(math, ams, rel, "\u2a86", "\\gtrapprox", true);
    defineSymbol(math, ams, bin, "\u22d7", "\\gtrdot");
    defineSymbol(math, ams, rel, "\u22d9", "\\ggg", true);
    defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
    defineSymbol(math, ams, rel, "\u22db", "\\gtreqless", true);
    defineSymbol(math, ams, rel, "\u2a8c", "\\gtreqqless", true);
    defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
    defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
    defineSymbol(math, ams, rel, "\u225c", "\\triangleq", true);
    defineSymbol(math, ams, rel, "\u223c", "\\thicksim");
    defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
    defineSymbol(math, ams, rel, "\u2ac6", "\\supseteqq", true);
    defineSymbol(math, ams, rel, "\u22d1", "\\Supset", true);
    defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
    defineSymbol(math, ams, rel, "\u227d", "\\succcurlyeq", true);
    defineSymbol(math, ams, rel, "\u22df", "\\curlyeqsucc", true);
    defineSymbol(math, ams, rel, "\u227f", "\\succsim", true);
    defineSymbol(math, ams, rel, "\u2ab8", "\\succapprox", true);
    defineSymbol(math, ams, rel, "\u22b3", "\\vartriangleright");
    defineSymbol(math, ams, rel, "\u22b5", "\\trianglerighteq");
    defineSymbol(math, ams, rel, "\u22a9", "\\Vdash", true);
    defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
    defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
    defineSymbol(math, ams, rel, "\u226c", "\\between", true);
    defineSymbol(math, ams, rel, "\u22d4", "\\pitchfork", true);
    defineSymbol(math, ams, rel, "\u221d", "\\varpropto");
    defineSymbol(math, ams, rel, "\u25c0", "\\blacktriangleleft");
    defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
    defineSymbol(math, ams, rel, "\u220d", "\\backepsilon");
    defineSymbol(math, ams, rel, "\u25b6", "\\blacktriangleright");
    defineSymbol(math, ams, rel, "\u2235", "\\because", true);
    defineSymbol(math, ams, rel, "\u22d8", "\\llless");
    defineSymbol(math, ams, rel, "\u22d9", "\\gggtr");
    defineSymbol(math, ams, bin, "\u22b2", "\\lhd");
    defineSymbol(math, ams, bin, "\u22b3", "\\rhd");
    defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
    defineSymbol(math, main, rel, "\u22c8", "\\Join");
    defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true);
    defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
    defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
    defineSymbol(math, ams, bin, "\u22d2", "\\Cap", true);
    defineSymbol(math, ams, bin, "\u22d3", "\\Cup", true);
    defineSymbol(math, ams, bin, "\u2a5e", "\\doublebarwedge", true);
    defineSymbol(math, ams, bin, "\u229f", "\\boxminus", true);
    defineSymbol(math, ams, bin, "\u229e", "\\boxplus", true);
    defineSymbol(math, ams, bin, "\u22c7", "\\divideontimes", true);
    defineSymbol(math, ams, bin, "\u22c9", "\\ltimes", true);
    defineSymbol(math, ams, bin, "\u22ca", "\\rtimes", true);
    defineSymbol(math, ams, bin, "\u22cb", "\\leftthreetimes", true);
    defineSymbol(math, ams, bin, "\u22cc", "\\rightthreetimes", true);
    defineSymbol(math, ams, bin, "\u22cf", "\\curlywedge", true);
    defineSymbol(math, ams, bin, "\u22ce", "\\curlyvee", true);
    defineSymbol(math, ams, bin, "\u229d", "\\circleddash", true);
    defineSymbol(math, ams, bin, "\u229b", "\\circledast", true);
    defineSymbol(math, ams, bin, "\u22c5", "\\centerdot");
    defineSymbol(math, ams, bin, "\u22ba", "\\intercal", true);
    defineSymbol(math, ams, bin, "\u22d2", "\\doublecap");
    defineSymbol(math, ams, bin, "\u22d3", "\\doublecup");
    defineSymbol(math, ams, bin, "\u22a0", "\\boxtimes", true);
    defineSymbol(math, ams, rel, "\u21e2", "\\dashrightarrow", true);
    defineSymbol(math, ams, rel, "\u21e0", "\\dashleftarrow", true);
    defineSymbol(math, ams, rel, "\u21c7", "\\leftleftarrows", true);
    defineSymbol(math, ams, rel, "\u21c6", "\\leftrightarrows", true);
    defineSymbol(math, ams, rel, "\u21da", "\\Lleftarrow", true);
    defineSymbol(math, ams, rel, "\u219e", "\\twoheadleftarrow", true);
    defineSymbol(math, ams, rel, "\u21a2", "\\leftarrowtail", true);
    defineSymbol(math, ams, rel, "\u21ab", "\\looparrowleft", true);
    defineSymbol(math, ams, rel, "\u21cb", "\\leftrightharpoons", true);
    defineSymbol(math, ams, rel, "\u21b6", "\\curvearrowleft", true);
    defineSymbol(math, ams, rel, "\u21ba", "\\circlearrowleft", true);
    defineSymbol(math, ams, rel, "\u21b0", "\\Lsh", true);
    defineSymbol(math, ams, rel, "\u21c8", "\\upuparrows", true);
    defineSymbol(math, ams, rel, "\u21bf", "\\upharpoonleft", true);
    defineSymbol(math, ams, rel, "\u21c3", "\\downharpoonleft", true);
    defineSymbol(math, main, rel, "\u22b6", "\\origof", true);
    defineSymbol(math, main, rel, "\u22b7", "\\imageof", true);
    defineSymbol(math, ams, rel, "\u22b8", "\\multimap", true);
    defineSymbol(math, ams, rel, "\u21ad", "\\leftrightsquigarrow", true);
    defineSymbol(math, ams, rel, "\u21c9", "\\rightrightarrows", true);
    defineSymbol(math, ams, rel, "\u21c4", "\\rightleftarrows", true);
    defineSymbol(math, ams, rel, "\u21a0", "\\twoheadrightarrow", true);
    defineSymbol(math, ams, rel, "\u21a3", "\\rightarrowtail", true);
    defineSymbol(math, ams, rel, "\u21ac", "\\looparrowright", true);
    defineSymbol(math, ams, rel, "\u21b7", "\\curvearrowright", true);
    defineSymbol(math, ams, rel, "\u21bb", "\\circlearrowright", true);
    defineSymbol(math, ams, rel, "\u21b1", "\\Rsh", true);
    defineSymbol(math, ams, rel, "\u21ca", "\\downdownarrows", true);
    defineSymbol(math, ams, rel, "\u21be", "\\upharpoonright", true);
    defineSymbol(math, ams, rel, "\u21c2", "\\downharpoonright", true);
    defineSymbol(math, ams, rel, "\u21dd", "\\rightsquigarrow", true);
    defineSymbol(math, ams, rel, "\u21dd", "\\leadsto");
    defineSymbol(math, ams, rel, "\u21db", "\\Rrightarrow", true);
    defineSymbol(math, ams, rel, "\u21be", "\\restriction");
    defineSymbol(math, main, textord, "\u2018", "`");
    defineSymbol(math, main, textord, "$", "\\$");
    defineSymbol(text, main, textord, "$", "\\$");
    defineSymbol(text, main, textord, "$", "\\textdollar");
    defineSymbol(math, main, textord, "%", "\\%");
    defineSymbol(text, main, textord, "%", "\\%");
    defineSymbol(math, main, textord, "_", "\\_");
    defineSymbol(text, main, textord, "_", "\\_");
    defineSymbol(text, main, textord, "_", "\\textunderscore");
    defineSymbol(math, main, textord, "\u2220", "\\angle", true);
    defineSymbol(math, main, textord, "\u221e", "\\infty", true);
    defineSymbol(math, main, textord, "\u2032", "\\prime");
    defineSymbol(math, main, textord, "\u25b3", "\\triangle");
    defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
    defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
    defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
    defineSymbol(math, main, textord, "\u039b", "\\Lambda", true);
    defineSymbol(math, main, textord, "\u039e", "\\Xi", true);
    defineSymbol(math, main, textord, "\u03a0", "\\Pi", true);
    defineSymbol(math, main, textord, "\u03a3", "\\Sigma", true);
    defineSymbol(math, main, textord, "\u03a5", "\\Upsilon", true);
    defineSymbol(math, main, textord, "\u03a6", "\\Phi", true);
    defineSymbol(math, main, textord, "\u03a8", "\\Psi", true);
    defineSymbol(math, main, textord, "\u03a9", "\\Omega", true);
    defineSymbol(math, main, textord, "A", "\u0391");
    defineSymbol(math, main, textord, "B", "\u0392");
    defineSymbol(math, main, textord, "E", "\u0395");
    defineSymbol(math, main, textord, "Z", "\u0396");
    defineSymbol(math, main, textord, "H", "\u0397");
    defineSymbol(math, main, textord, "I", "\u0399");
    defineSymbol(math, main, textord, "K", "\u039A");
    defineSymbol(math, main, textord, "M", "\u039C");
    defineSymbol(math, main, textord, "N", "\u039D");
    defineSymbol(math, main, textord, "O", "\u039F");
    defineSymbol(math, main, textord, "P", "\u03A1");
    defineSymbol(math, main, textord, "T", "\u03A4");
    defineSymbol(math, main, textord, "X", "\u03A7");
    defineSymbol(math, main, textord, "\u00ac", "\\neg", true);
    defineSymbol(math, main, textord, "\u00ac", "\\lnot");
    defineSymbol(math, main, textord, "\u22a4", "\\top");
    defineSymbol(math, main, textord, "\u22a5", "\\bot");
    defineSymbol(math, main, textord, "\u2205", "\\emptyset");
    defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
    defineSymbol(math, main, mathord, "\u03b1", "\\alpha", true);
    defineSymbol(math, main, mathord, "\u03b2", "\\beta", true);
    defineSymbol(math, main, mathord, "\u03b3", "\\gamma", true);
    defineSymbol(math, main, mathord, "\u03b4", "\\delta", true);
    defineSymbol(math, main, mathord, "\u03f5", "\\epsilon", true);
    defineSymbol(math, main, mathord, "\u03b6", "\\zeta", true);
    defineSymbol(math, main, mathord, "\u03b7", "\\eta", true);
    defineSymbol(math, main, mathord, "\u03b8", "\\theta", true);
    defineSymbol(math, main, mathord, "\u03b9", "\\iota", true);
    defineSymbol(math, main, mathord, "\u03ba", "\\kappa", true);
    defineSymbol(math, main, mathord, "\u03bb", "\\lambda", true);
    defineSymbol(math, main, mathord, "\u03bc", "\\mu", true);
    defineSymbol(math, main, mathord, "\u03bd", "\\nu", true);
    defineSymbol(math, main, mathord, "\u03be", "\\xi", true);
    defineSymbol(math, main, mathord, "\u03bf", "\\omicron", true);
    defineSymbol(math, main, mathord, "\u03c0", "\\pi", true);
    defineSymbol(math, main, mathord, "\u03c1", "\\rho", true);
    defineSymbol(math, main, mathord, "\u03c3", "\\sigma", true);
    defineSymbol(math, main, mathord, "\u03c4", "\\tau", true);
    defineSymbol(math, main, mathord, "\u03c5", "\\upsilon", true);
    defineSymbol(math, main, mathord, "\u03d5", "\\phi", true);
    defineSymbol(math, main, mathord, "\u03c7", "\\chi", true);
    defineSymbol(math, main, mathord, "\u03c8", "\\psi", true);
    defineSymbol(math, main, mathord, "\u03c9", "\\omega", true);
    defineSymbol(math, main, mathord, "\u03b5", "\\varepsilon", true);
    defineSymbol(math, main, mathord, "\u03d1", "\\vartheta", true);
    defineSymbol(math, main, mathord, "\u03d6", "\\varpi", true);
    defineSymbol(math, main, mathord, "\u03f1", "\\varrho", true);
    defineSymbol(math, main, mathord, "\u03c2", "\\varsigma", true);
    defineSymbol(math, main, mathord, "\u03c6", "\\varphi", true);
    defineSymbol(math, main, bin, "\u2217", "*", true);
    defineSymbol(math, main, bin, "+", "+");
    defineSymbol(math, main, bin, "\u2212", "-", true);
    defineSymbol(math, main, bin, "\u22c5", "\\cdot", true);
    defineSymbol(math, main, bin, "\u2218", "\\circ", true);
    defineSymbol(math, main, bin, "\u00f7", "\\div", true);
    defineSymbol(math, main, bin, "\u00b1", "\\pm", true);
    defineSymbol(math, main, bin, "\u00d7", "\\times", true);
    defineSymbol(math, main, bin, "\u2229", "\\cap", true);
    defineSymbol(math, main, bin, "\u222a", "\\cup", true);
    defineSymbol(math, main, bin, "\u2216", "\\setminus", true);
    defineSymbol(math, main, bin, "\u2227", "\\land");
    defineSymbol(math, main, bin, "\u2228", "\\lor");
    defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
    defineSymbol(math, main, bin, "\u2228", "\\vee", true);
    defineSymbol(math, main, textord, "\u221a", "\\surd");
    defineSymbol(math, main, open, "\u27e8", "\\langle", true);
    defineSymbol(math, main, open, "\u2223", "\\lvert");
    defineSymbol(math, main, open, "\u2225", "\\lVert");
    defineSymbol(math, main, close, "?", "?");
    defineSymbol(math, main, close, "!", "!");
    defineSymbol(math, main, close, "\u27e9", "\\rangle", true);
    defineSymbol(math, main, close, "\u2223", "\\rvert");
    defineSymbol(math, main, close, "\u2225", "\\rVert");
    defineSymbol(math, main, rel, "=", "=");
    defineSymbol(math, main, rel, ":", ":");
    defineSymbol(math, main, rel, "\u2248", "\\approx", true);
    defineSymbol(math, main, rel, "\u2245", "\\cong", true);
    defineSymbol(math, main, rel, "\u2265", "\\ge");
    defineSymbol(math, main, rel, "\u2265", "\\geq", true);
    defineSymbol(math, main, rel, "\u2190", "\\gets");
    defineSymbol(math, main, rel, ">", "\\gt", true);
    defineSymbol(math, main, rel, "\u2208", "\\in", true);
    defineSymbol(math, main, rel, "\ue020", "\\@not");
    defineSymbol(math, main, rel, "\u2282", "\\subset", true);
    defineSymbol(math, main, rel, "\u2283", "\\supset", true);
    defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
    defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
    defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
    defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
    defineSymbol(math, main, rel, "\u22a8", "\\models");
    defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
    defineSymbol(math, main, rel, "\u2264", "\\le");
    defineSymbol(math, main, rel, "\u2264", "\\leq", true);
    defineSymbol(math, main, rel, "<", "\\lt", true);
    defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
    defineSymbol(math, main, rel, "\u2192", "\\to");
    defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
    defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
    defineSymbol(math, main, spacing, "\u00a0", "\\ ");
    defineSymbol(math, main, spacing, "\u00a0", "\\space");
    defineSymbol(math, main, spacing, "\u00a0", "\\nobreakspace");
    defineSymbol(text, main, spacing, "\u00a0", "\\ ");
    defineSymbol(text, main, spacing, "\u00a0", " ");
    defineSymbol(text, main, spacing, "\u00a0", "\\space");
    defineSymbol(text, main, spacing, "\u00a0", "\\nobreakspace");
    defineSymbol(math, main, spacing, null, "\\nobreak");
    defineSymbol(math, main, spacing, null, "\\allowbreak");
    defineSymbol(math, main, punct, ",", ",");
    defineSymbol(math, main, punct, ";", ";");
    defineSymbol(math, ams, bin, "\u22bc", "\\barwedge", true);
    defineSymbol(math, ams, bin, "\u22bb", "\\veebar", true);
    defineSymbol(math, main, bin, "\u2299", "\\odot", true);
    defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
    defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
    defineSymbol(math, main, textord, "\u2202", "\\partial", true);
    defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
    defineSymbol(math, ams, bin, "\u229a", "\\circledcirc", true);
    defineSymbol(math, ams, bin, "\u22a1", "\\boxdot", true);
    defineSymbol(math, main, bin, "\u25b3", "\\bigtriangleup");
    defineSymbol(math, main, bin, "\u25bd", "\\bigtriangledown");
    defineSymbol(math, main, bin, "\u2020", "\\dagger");
    defineSymbol(math, main, bin, "\u22c4", "\\diamond");
    defineSymbol(math, main, bin, "\u22c6", "\\star");
    defineSymbol(math, main, bin, "\u25c3", "\\triangleleft");
    defineSymbol(math, main, bin, "\u25b9", "\\triangleright");
    defineSymbol(math, main, open, "{", "\\{");
    defineSymbol(text, main, textord, "{", "\\{");
    defineSymbol(text, main, textord, "{", "\\textbraceleft");
    defineSymbol(math, main, close, "}", "\\}");
    defineSymbol(text, main, textord, "}", "\\}");
    defineSymbol(text, main, textord, "}", "\\textbraceright");
    defineSymbol(math, main, open, "{", "\\lbrace");
    defineSymbol(math, main, close, "}", "\\rbrace");
    defineSymbol(math, main, open, "[", "\\lbrack", true);
    defineSymbol(text, main, textord, "[", "\\lbrack", true);
    defineSymbol(math, main, close, "]", "\\rbrack", true);
    defineSymbol(text, main, textord, "]", "\\rbrack", true);
    defineSymbol(math, main, open, "(", "\\lparen", true);
    defineSymbol(math, main, close, ")", "\\rparen", true);
    defineSymbol(text, main, textord, "<", "\\textless", true);
    defineSymbol(text, main, textord, ">", "\\textgreater", true);
    defineSymbol(math, main, open, "\u230a", "\\lfloor", true);
    defineSymbol(math, main, close, "\u230b", "\\rfloor", true);
    defineSymbol(math, main, open, "\u2308", "\\lceil", true);
    defineSymbol(math, main, close, "\u2309", "\\rceil", true);
    defineSymbol(math, main, textord, "\\", "\\backslash");
    defineSymbol(math, main, textord, "\u2223", "|");
    defineSymbol(math, main, textord, "\u2223", "\\vert");
    defineSymbol(text, main, textord, "|", "\\textbar", true);
    defineSymbol(math, main, textord, "\u2225", "\\|");
    defineSymbol(math, main, textord, "\u2225", "\\Vert");
    defineSymbol(text, main, textord, "\u2225", "\\textbardbl");
    defineSymbol(text, main, textord, "~", "\\textasciitilde");
    defineSymbol(text, main, textord, "\\", "\\textbackslash");
    defineSymbol(text, main, textord, "^", "\\textasciicircum");
    defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
    defineSymbol(math, main, rel, "\u21d1", "\\Uparrow", true);
    defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
    defineSymbol(math, main, rel, "\u21d3", "\\Downarrow", true);
    defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
    defineSymbol(math, main, rel, "\u21d5", "\\Updownarrow", true);
    defineSymbol(math, main, op, "\u2210", "\\coprod");
    defineSymbol(math, main, op, "\u22c1", "\\bigvee");
    defineSymbol(math, main, op, "\u22c0", "\\bigwedge");
    defineSymbol(math, main, op, "\u2a04", "\\biguplus");
    defineSymbol(math, main, op, "\u22c2", "\\bigcap");
    defineSymbol(math, main, op, "\u22c3", "\\bigcup");
    defineSymbol(math, main, op, "\u222b", "\\int");
    defineSymbol(math, main, op, "\u222b", "\\intop");
    defineSymbol(math, main, op, "\u222c", "\\iint");
    defineSymbol(math, main, op, "\u222d", "\\iiint");
    defineSymbol(math, main, op, "\u220f", "\\prod");
    defineSymbol(math, main, op, "\u2211", "\\sum");
    defineSymbol(math, main, op, "\u2a02", "\\bigotimes");
    defineSymbol(math, main, op, "\u2a01", "\\bigoplus");
    defineSymbol(math, main, op, "\u2a00", "\\bigodot");
    defineSymbol(math, main, op, "\u222e", "\\oint");
    defineSymbol(math, main, op, "\u222f", "\\oiint");
    defineSymbol(math, main, op, "\u2230", "\\oiiint");
    defineSymbol(math, main, op, "\u2a06", "\\bigsqcup");
    defineSymbol(math, main, op, "\u222b", "\\smallint");
    defineSymbol(text, main, inner, "\u2026", "\\textellipsis");
    defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
    defineSymbol(text, main, inner, "\u2026", "\\ldots", true);
    defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
    defineSymbol(math, main, inner, "\u22ef", "\\@cdots", true);
    defineSymbol(math, main, inner, "\u22f1", "\\ddots", true);
    defineSymbol(math, main, textord, "\u22ee", "\\varvdots");
    defineSymbol(math, main, accent, "\u02ca", "\\acute");
    defineSymbol(math, main, accent, "\u02cb", "\\grave");
    defineSymbol(math, main, accent, "\u00a8", "\\ddot");
    defineSymbol(math, main, accent, "\u007e", "\\tilde");
    defineSymbol(math, main, accent, "\u02c9", "\\bar");
    defineSymbol(math, main, accent, "\u02d8", "\\breve");
    defineSymbol(math, main, accent, "\u02c7", "\\check");
    defineSymbol(math, main, accent, "\u005e", "\\hat");
    defineSymbol(math, main, accent, "\u20d7", "\\vec");
    defineSymbol(math, main, accent, "\u02d9", "\\dot");
    defineSymbol(math, main, accent, "\u02da", "\\mathring");
    defineSymbol(math, main, mathord, "\ue131", "\\@imath");
    defineSymbol(math, main, mathord, "\ue237", "\\@jmath");
    defineSymbol(math, main, textord, "\u0131", "\u0131");
    defineSymbol(math, main, textord, "\u0237", "\u0237");
    defineSymbol(text, main, textord, "\u0131", "\\i", true);
    defineSymbol(text, main, textord, "\u0237", "\\j", true);
    defineSymbol(text, main, textord, "\u00df", "\\ss", true);
    defineSymbol(text, main, textord, "\u00e6", "\\ae", true);
    defineSymbol(text, main, textord, "\u0153", "\\oe", true);
    defineSymbol(text, main, textord, "\u00f8", "\\o", true);
    defineSymbol(text, main, textord, "\u00c6", "\\AE", true);
    defineSymbol(text, main, textord, "\u0152", "\\OE", true);
    defineSymbol(text, main, textord, "\u00d8", "\\O", true);
    defineSymbol(text, main, accent, "\u02ca", "\\'");
    defineSymbol(text, main, accent, "\u02cb", "\\`");
    defineSymbol(text, main, accent, "\u02c6", "\\^");
    defineSymbol(text, main, accent, "\u02dc", "\\~");
    defineSymbol(text, main, accent, "\u02c9", "\\=");
    defineSymbol(text, main, accent, "\u02d8", "\\u");
    defineSymbol(text, main, accent, "\u02d9", "\\.");
    defineSymbol(text, main, accent, "\u00b8", "\\c");
    defineSymbol(text, main, accent, "\u02da", "\\r");
    defineSymbol(text, main, accent, "\u02c7", "\\v");
    defineSymbol(text, main, accent, "\u00a8", '\\"');
    defineSymbol(text, main, accent, "\u02dd", "\\H");
    defineSymbol(text, main, accent, "\u25ef", "\\textcircled");
    var ligatures = {
      "--": true,
      "---": true,
      "``": true,
      "''": true
    };
    defineSymbol(text, main, textord, "\u2013", "--", true);
    defineSymbol(text, main, textord, "\u2013", "\\textendash");
    defineSymbol(text, main, textord, "\u2014", "---", true);
    defineSymbol(text, main, textord, "\u2014", "\\textemdash");
    defineSymbol(text, main, textord, "\u2018", "`", true);
    defineSymbol(text, main, textord, "\u2018", "\\textquoteleft");
    defineSymbol(text, main, textord, "\u2019", "'", true);
    defineSymbol(text, main, textord, "\u2019", "\\textquoteright");
    defineSymbol(text, main, textord, "\u201c", "``", true);
    defineSymbol(text, main, textord, "\u201c", "\\textquotedblleft");
    defineSymbol(text, main, textord, "\u201d", "''", true);
    defineSymbol(text, main, textord, "\u201d", "\\textquotedblright");
    defineSymbol(math, main, textord, "\u00b0", "\\degree", true);
    defineSymbol(text, main, textord, "\u00b0", "\\degree");
    defineSymbol(text, main, textord, "\u00b0", "\\textdegree", true);
    defineSymbol(math, main, textord, "\u00a3", "\\pounds");
    defineSymbol(math, main, textord, "\u00a3", "\\mathsterling", true);
    defineSymbol(text, main, textord, "\u00a3", "\\pounds");
    defineSymbol(text, main, textord, "\u00a3", "\\textsterling", true);
    defineSymbol(math, ams, textord, "\u2720", "\\maltese");
    defineSymbol(text, ams, textord, "\u2720", "\\maltese");
    var mathTextSymbols = "0123456789/@.\"";
    for (var i = 0; i < mathTextSymbols.length; i++) {
      var ch = mathTextSymbols.charAt(i);
      defineSymbol(math, main, textord, ch, ch);
    }
    var textSymbols = "0123456789!@*()-=+\";:?/.,";
    for (var _i = 0; _i < textSymbols.length; _i++) {
      var _ch = textSymbols.charAt(_i);
      defineSymbol(text, main, textord, _ch, _ch);
    }
    var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    for (var _i2 = 0; _i2 < letters.length; _i2++) {
      var _ch2 = letters.charAt(_i2);
      defineSymbol(math, main, mathord, _ch2, _ch2);
      defineSymbol(text, main, textord, _ch2, _ch2);
    }
    defineSymbol(math, ams, textord, "C", "\u2102");
    defineSymbol(text, ams, textord, "C", "\u2102");
    defineSymbol(math, ams, textord, "H", "\u210D");
    defineSymbol(text, ams, textord, "H", "\u210D");
    defineSymbol(math, ams, textord, "N", "\u2115");
    defineSymbol(text, ams, textord, "N", "\u2115");
    defineSymbol(math, ams, textord, "P", "\u2119");
    defineSymbol(text, ams, textord, "P", "\u2119");
    defineSymbol(math, ams, textord, "Q", "\u211A");
    defineSymbol(text, ams, textord, "Q", "\u211A");
    defineSymbol(math, ams, textord, "R", "\u211D");
    defineSymbol(text, ams, textord, "R", "\u211D");
    defineSymbol(math, ams, textord, "Z", "\u2124");
    defineSymbol(text, ams, textord, "Z", "\u2124");
    defineSymbol(math, main, mathord, "h", "\u210E");
    defineSymbol(text, main, mathord, "h", "\u210E");
    var wideChar = "";
    for (var _i3 = 0; _i3 < letters.length; _i3++) {
      var _ch3 = letters.charAt(_i3);
      wideChar = String.fromCharCode(0xD835, 0xDC00 + _i3);
      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDC34 + _i3);
      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDC68 + _i3);
      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDD04 + _i3);
      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDDA0 + _i3);
      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDDD4 + _i3);
      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDE08 + _i3);
      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDE70 + _i3);
      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      if (_i3 < 26) {
        wideChar = String.fromCharCode(0xD835, 0xDD38 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(0xD835, 0xDC9C + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text, main, textord, _ch3, wideChar);
      }
    }
    wideChar = String.fromCharCode(0xD835, 0xDD5C);
    defineSymbol(math, main, mathord, "k", wideChar);
    defineSymbol(text, main, textord, "k", wideChar);
    for (var _i4 = 0; _i4 < 10; _i4++) {
      var _ch4 = _i4.toString();
      wideChar = String.fromCharCode(0xD835, 0xDFCE + _i4);
      defineSymbol(math, main, mathord, _ch4, wideChar);
      defineSymbol(text, main, textord, _ch4, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDFE2 + _i4);
      defineSymbol(math, main, mathord, _ch4, wideChar);
      defineSymbol(text, main, textord, _ch4, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDFEC + _i4);
      defineSymbol(math, main, mathord, _ch4, wideChar);
      defineSymbol(text, main, textord, _ch4, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDFF6 + _i4);
      defineSymbol(math, main, mathord, _ch4, wideChar);
      defineSymbol(text, main, textord, _ch4, wideChar);
    }
    var extraLatin = "\u00d0\u00de\u00fe";
    for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
      var _ch5 = extraLatin.charAt(_i5);
      defineSymbol(math, main, mathord, _ch5, _ch5);
      defineSymbol(text, main, textord, _ch5, _ch5);
    }
    var wideLatinLetterData = [["mathbf", "textbf", "Main-Bold"],
    ["mathbf", "textbf", "Main-Bold"],
    ["mathnormal", "textit", "Math-Italic"],
    ["mathnormal", "textit", "Math-Italic"],
    ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
    ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
    ["mathscr", "textscr", "Script-Regular"],
    ["", "", ""],
    ["", "", ""],
    ["", "", ""],
    ["mathfrak", "textfrak", "Fraktur-Regular"],
    ["mathfrak", "textfrak", "Fraktur-Regular"],
    ["mathbb", "textbb", "AMS-Regular"],
    ["mathbb", "textbb", "AMS-Regular"],
    ["", "", ""],
    ["", "", ""],
    ["mathsf", "textsf", "SansSerif-Regular"],
    ["mathsf", "textsf", "SansSerif-Regular"],
    ["mathboldsf", "textboldsf", "SansSerif-Bold"],
    ["mathboldsf", "textboldsf", "SansSerif-Bold"],
    ["mathitsf", "textitsf", "SansSerif-Italic"],
    ["mathitsf", "textitsf", "SansSerif-Italic"],
    ["", "", ""],
    ["", "", ""],
    ["mathtt", "texttt", "Typewriter-Regular"],
    ["mathtt", "texttt", "Typewriter-Regular"]
    ];
    var wideNumeralData = [["mathbf", "textbf", "Main-Bold"],
    ["", "", ""],
    ["mathsf", "textsf", "SansSerif-Regular"],
    ["mathboldsf", "textboldsf", "SansSerif-Bold"],
    ["mathtt", "texttt", "Typewriter-Regular"]
    ];
    var wideCharacterFont = function wideCharacterFont(wideChar, mode) {
      var H = wideChar.charCodeAt(0);
      var L = wideChar.charCodeAt(1);
      var codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000;
      var j = mode === "math" ? 0 : 1;
      if (0x1D400 <= codePoint && codePoint < 0x1D6A4) {
        var i = Math.floor((codePoint - 0x1D400) / 26);
        return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
      } else if (0x1D7CE <= codePoint && codePoint <= 0x1D7FF) {
        var _i = Math.floor((codePoint - 0x1D7CE) / 10);
        return [wideNumeralData[_i][2], wideNumeralData[_i][j]];
      } else if (codePoint === 0x1D6A5 || codePoint === 0x1D6A6) {
        return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
      } else if (0x1D6A6 < codePoint && codePoint < 0x1D7CE) {
        return ["", ""];
      } else {
        throw new ParseError("Unsupported character: " + wideChar);
      }
    };
    var lookupSymbol = function lookupSymbol(value,
    fontName, mode) {
      if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
      }
      return {
        value: value,
        metrics: getCharacterMetrics(value, fontName, mode)
      };
    };
    var makeSymbol = function makeSymbol(value, fontName, mode, options, classes) {
      var lookup = lookupSymbol(value, fontName, mode);
      var metrics = lookup.metrics;
      value = lookup.value;
      var symbolNode;
      if (metrics) {
        var italic = metrics.italic;
        if (mode === "text" || options && options.font === "mathit") {
          italic = 0;
        }
        symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
      } else {
        typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
        symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
      }
      if (options) {
        symbolNode.maxFontSize = options.sizeMultiplier;
        if (options.style.isTight()) {
          symbolNode.classes.push("mtight");
        }
        var color = options.getColor();
        if (color) {
          symbolNode.style.color = color;
        }
      }
      return symbolNode;
    };
    var mathsym = function mathsym(value, mode, options, classes) {
      if (classes === void 0) {
        classes = [];
      }
      if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
        return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
      } else if (value === "\\" || symbols[mode][value].font === "main") {
        return makeSymbol(value, "Main-Regular", mode, options, classes);
      } else {
        return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
      }
    };
    var boldsymbol = function boldsymbol(value, mode, options, classes, type) {
      if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
        return {
          fontName: "Math-BoldItalic",
          fontClass: "boldsymbol"
        };
      } else {
        return {
          fontName: "Main-Bold",
          fontClass: "mathbf"
        };
      }
    };
    var makeOrd = function makeOrd(group, options, type) {
      var mode = group.mode;
      var text = group.text;
      var classes = ["mord"];
      var isFont = mode === "math" || mode === "text" && options.font;
      var fontOrFamily = isFont ? options.font : options.fontFamily;
      if (text.charCodeAt(0) === 0xD835) {
        var [wideFontName, wideFontClass] = wideCharacterFont(text, mode);
        return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));
      } else if (fontOrFamily) {
        var fontName;
        var fontClasses;
        if (fontOrFamily === "boldsymbol") {
          var fontData = boldsymbol(text, mode, options, classes, type);
          fontName = fontData.fontName;
          fontClasses = [fontData.fontClass];
        } else if (isFont) {
          fontName = fontMap[fontOrFamily].fontName;
          fontClasses = [fontOrFamily];
        } else {
          fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
          fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
        }
        if (lookupSymbol(text, fontName, mode).metrics) {
          return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));
        } else if (ligatures.hasOwnProperty(text) && fontName.slice(0, 10) === "Typewriter") {
          var parts = [];
          for (var i = 0; i < text.length; i++) {
            parts.push(makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));
          }
          return makeFragment(parts);
        }
      }
      if (type === "mathord") {
        return makeSymbol(text, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
      } else if (type === "textord") {
        var font = symbols[mode][text] && symbols[mode][text].font;
        if (font === "ams") {
          var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
          return makeSymbol(text, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
        } else if (font === "main" || !font) {
          var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
          return makeSymbol(text, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
        } else {
          var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
          return makeSymbol(text, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
        }
      } else {
        throw new Error("unexpected type: " + type + " in makeOrd");
      }
    };
    var canCombine = (prev, next) => {
      if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
        return false;
      }
      if (prev.classes.length === 1) {
        var cls = prev.classes[0];
        if (cls === "mbin" || cls === "mord") {
          return false;
        }
      }
      for (var style in prev.style) {
        if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
          return false;
        }
      }
      for (var _style in next.style) {
        if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
          return false;
        }
      }
      return true;
    };
    var tryCombineChars = chars => {
      for (var i = 0; i < chars.length - 1; i++) {
        var prev = chars[i];
        var next = chars[i + 1];
        if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
          prev.text += next.text;
          prev.height = Math.max(prev.height, next.height);
          prev.depth = Math.max(prev.depth, next.depth);
          prev.italic = next.italic;
          chars.splice(i + 1, 1);
          i--;
        }
      }
      return chars;
    };
    var sizeElementFromChildren = function sizeElementFromChildren(elem) {
      var height = 0;
      var depth = 0;
      var maxFontSize = 0;
      for (var i = 0; i < elem.children.length; i++) {
        var child = elem.children[i];
        if (child.height > height) {
          height = child.height;
        }
        if (child.depth > depth) {
          depth = child.depth;
        }
        if (child.maxFontSize > maxFontSize) {
          maxFontSize = child.maxFontSize;
        }
      }
      elem.height = height;
      elem.depth = depth;
      elem.maxFontSize = maxFontSize;
    };
    var makeSpan$2 = function makeSpan(classes, children, options, style) {
      var span = new Span(classes, children, options, style);
      sizeElementFromChildren(span);
      return span;
    };
    var makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);
    var makeLineSpan = function makeLineSpan(className, options, thickness) {
      var line = makeSpan$2([className], [], options);
      line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
      line.style.borderBottomWidth = makeEm(line.height);
      line.maxFontSize = 1.0;
      return line;
    };
    var makeAnchor = function makeAnchor(href, classes, children, options) {
      var anchor = new Anchor(href, classes, children, options);
      sizeElementFromChildren(anchor);
      return anchor;
    };
    var makeFragment = function makeFragment(children) {
      var fragment = new DocumentFragment(children);
      sizeElementFromChildren(fragment);
      return fragment;
    };
    var wrapFragment = function wrapFragment(group, options) {
      if (group instanceof DocumentFragment) {
        return makeSpan$2([], [group], options);
      }
      return group;
    };
    var getVListChildrenAndDepth = function getVListChildrenAndDepth(params) {
      if (params.positionType === "individualShift") {
        var oldChildren = params.children;
        var children = [oldChildren[0]];
        var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
        var currPos = _depth;
        for (var i = 1; i < oldChildren.length; i++) {
          var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
          var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
          currPos = currPos + diff;
          children.push({
            type: "kern",
            size
          });
          children.push(oldChildren[i]);
        }
        return {
          children,
          depth: _depth
        };
      }
      var depth;
      if (params.positionType === "top") {
        var bottom = params.positionData;
        for (var _i = 0; _i < params.children.length; _i++) {
          var child = params.children[_i];
          bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
        }
        depth = bottom;
      } else if (params.positionType === "bottom") {
        depth = -params.positionData;
      } else {
        var firstChild = params.children[0];
        if (firstChild.type !== "elem") {
          throw new Error('First child must have type "elem".');
        }
        if (params.positionType === "shift") {
          depth = -firstChild.elem.depth - params.positionData;
        } else if (params.positionType === "firstBaseline") {
          depth = -firstChild.elem.depth;
        } else {
          throw new Error("Invalid positionType " + params.positionType + ".");
        }
      }
      return {
        children: params.children,
        depth
      };
    };
    var makeVList = function makeVList(params, options) {
      var {
        children,
        depth
      } = getVListChildrenAndDepth(params);
      var pstrutSize = 0;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.type === "elem") {
          var elem = child.elem;
          pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
        }
      }
      pstrutSize += 2;
      var pstrut = makeSpan$2(["pstrut"], []);
      pstrut.style.height = makeEm(pstrutSize);
      var realChildren = [];
      var minPos = depth;
      var maxPos = depth;
      var currPos = depth;
      for (var _i2 = 0; _i2 < children.length; _i2++) {
        var _child = children[_i2];
        if (_child.type === "kern") {
          currPos += _child.size;
        } else {
          var _elem = _child.elem;
          var classes = _child.wrapperClasses || [];
          var style = _child.wrapperStyle || {};
          var childWrap = makeSpan$2(classes, [pstrut, _elem], undefined, style);
          childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);
          if (_child.marginLeft) {
            childWrap.style.marginLeft = _child.marginLeft;
          }
          if (_child.marginRight) {
            childWrap.style.marginRight = _child.marginRight;
          }
          realChildren.push(childWrap);
          currPos += _elem.height + _elem.depth;
        }
        minPos = Math.min(minPos, currPos);
        maxPos = Math.max(maxPos, currPos);
      }
      var vlist = makeSpan$2(["vlist"], realChildren);
      vlist.style.height = makeEm(maxPos);
      var rows;
      if (minPos < 0) {
        var emptySpan = makeSpan$2([], []);
        var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
        depthStrut.style.height = makeEm(-minPos);
        var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("\u200b")]);
        rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
      } else {
        rows = [makeSpan$2(["vlist-r"], [vlist])];
      }
      var vtable = makeSpan$2(["vlist-t"], rows);
      if (rows.length === 2) {
        vtable.classes.push("vlist-t2");
      }
      vtable.height = maxPos;
      vtable.depth = -minPos;
      return vtable;
    };
    var makeGlue = (measurement, options) => {
      var rule = makeSpan$2(["mspace"], [], options);
      var size = calculateSize(measurement, options);
      rule.style.marginRight = makeEm(size);
      return rule;
    };
    var retrieveTextFontName = function retrieveTextFontName(fontFamily, fontWeight, fontShape) {
      var baseFontName = "";
      switch (fontFamily) {
        case "amsrm":
          baseFontName = "AMS";
          break;
        case "textrm":
          baseFontName = "Main";
          break;
        case "textsf":
          baseFontName = "SansSerif";
          break;
        case "texttt":
          baseFontName = "Typewriter";
          break;
        default:
          baseFontName = fontFamily;
      }
      var fontStylesName;
      if (fontWeight === "textbf" && fontShape === "textit") {
        fontStylesName = "BoldItalic";
      } else if (fontWeight === "textbf") {
        fontStylesName = "Bold";
      } else if (fontWeight === "textit") {
        fontStylesName = "Italic";
      } else {
        fontStylesName = "Regular";
      }
      return baseFontName + "-" + fontStylesName;
    };
    var fontMap = {
      "mathbf": {
        variant: "bold",
        fontName: "Main-Bold"
      },
      "mathrm": {
        variant: "normal",
        fontName: "Main-Regular"
      },
      "textit": {
        variant: "italic",
        fontName: "Main-Italic"
      },
      "mathit": {
        variant: "italic",
        fontName: "Main-Italic"
      },
      "mathnormal": {
        variant: "italic",
        fontName: "Math-Italic"
      },
      "mathbb": {
        variant: "double-struck",
        fontName: "AMS-Regular"
      },
      "mathcal": {
        variant: "script",
        fontName: "Caligraphic-Regular"
      },
      "mathfrak": {
        variant: "fraktur",
        fontName: "Fraktur-Regular"
      },
      "mathscr": {
        variant: "script",
        fontName: "Script-Regular"
      },
      "mathsf": {
        variant: "sans-serif",
        fontName: "SansSerif-Regular"
      },
      "mathtt": {
        variant: "monospace",
        fontName: "Typewriter-Regular"
      }
    };
    var svgData = {
      vec: ["vec", 0.471, 0.714],
      oiintSize1: ["oiintSize1", 0.957, 0.499],
      oiintSize2: ["oiintSize2", 1.472, 0.659],
      oiiintSize1: ["oiiintSize1", 1.304, 0.499],
      oiiintSize2: ["oiiintSize2", 1.98, 0.659]
    };
    var staticSvg = function staticSvg(value, options) {
      var [pathName, width, height] = svgData[value];
      var path = new PathNode(pathName);
      var svgNode = new SvgNode([path], {
        "width": makeEm(width),
        "height": makeEm(height),
        "style": "width:" + makeEm(width),
        "viewBox": "0 0 " + 1000 * width + " " + 1000 * height,
        "preserveAspectRatio": "xMinYMin"
      });
      var span = makeSvgSpan(["overlay"], [svgNode], options);
      span.height = height;
      span.style.height = makeEm(height);
      span.style.width = makeEm(width);
      return span;
    };
    var buildCommon = {
      fontMap,
      makeSymbol,
      mathsym,
      makeSpan: makeSpan$2,
      makeSvgSpan,
      makeLineSpan,
      makeAnchor,
      makeFragment,
      wrapFragment,
      makeVList,
      makeOrd,
      makeGlue,
      staticSvg,
      svgData,
      tryCombineChars
    };
    var thinspace = {
      number: 3,
      unit: "mu"
    };
    var mediumspace = {
      number: 4,
      unit: "mu"
    };
    var thickspace = {
      number: 5,
      unit: "mu"
    };
    var spacings = {
      mord: {
        mop: thinspace,
        mbin: mediumspace,
        mrel: thickspace,
        minner: thinspace
      },
      mop: {
        mord: thinspace,
        mop: thinspace,
        mrel: thickspace,
        minner: thinspace
      },
      mbin: {
        mord: mediumspace,
        mop: mediumspace,
        mopen: mediumspace,
        minner: mediumspace
      },
      mrel: {
        mord: thickspace,
        mop: thickspace,
        mopen: thickspace,
        minner: thickspace
      },
      mopen: {},
      mclose: {
        mop: thinspace,
        mbin: mediumspace,
        mrel: thickspace,
        minner: thinspace
      },
      mpunct: {
        mord: thinspace,
        mop: thinspace,
        mrel: thickspace,
        mopen: thinspace,
        mclose: thinspace,
        mpunct: thinspace,
        minner: thinspace
      },
      minner: {
        mord: thinspace,
        mop: thinspace,
        mbin: mediumspace,
        mrel: thickspace,
        mopen: thinspace,
        mpunct: thinspace,
        minner: thinspace
      }
    };
    var tightSpacings = {
      mord: {
        mop: thinspace
      },
      mop: {
        mord: thinspace,
        mop: thinspace
      },
      mbin: {},
      mrel: {},
      mopen: {},
      mclose: {
        mop: thinspace
      },
      mpunct: {},
      minner: {
        mop: thinspace
      }
    };
    var _functions = {};
    var _htmlGroupBuilders = {};
    var _mathmlGroupBuilders = {};
    function defineFunction(_ref) {
      var {
        type,
        names,
        props,
        handler,
        htmlBuilder,
        mathmlBuilder
      } = _ref;
      var data = {
        type,
        numArgs: props.numArgs,
        argTypes: props.argTypes,
        allowedInArgument: !!props.allowedInArgument,
        allowedInText: !!props.allowedInText,
        allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,
        numOptionalArgs: props.numOptionalArgs || 0,
        infix: !!props.infix,
        primitive: !!props.primitive,
        handler: handler
      };
      for (var i = 0; i < names.length; ++i) {
        _functions[names[i]] = data;
      }
      if (type) {
        if (htmlBuilder) {
          _htmlGroupBuilders[type] = htmlBuilder;
        }
        if (mathmlBuilder) {
          _mathmlGroupBuilders[type] = mathmlBuilder;
        }
      }
    }
    function defineFunctionBuilders(_ref2) {
      var {
        type,
        htmlBuilder,
        mathmlBuilder
      } = _ref2;
      defineFunction({
        type,
        names: [],
        props: {
          numArgs: 0
        },
        handler() {
          throw new Error('Should never be called.');
        },
        htmlBuilder,
        mathmlBuilder
      });
    }
    var normalizeArgument = function normalizeArgument(arg) {
      return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
    };
    var ordargument = function ordargument(arg) {
      return arg.type === "ordgroup" ? arg.body : [arg];
    };
    var makeSpan$1 = buildCommon.makeSpan;
    var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
    var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
    var styleMap$1 = {
      "display": Style$1.DISPLAY,
      "text": Style$1.TEXT,
      "script": Style$1.SCRIPT,
      "scriptscript": Style$1.SCRIPTSCRIPT
    };
    var DomEnum = {
      mord: "mord",
      mop: "mop",
      mbin: "mbin",
      mrel: "mrel",
      mopen: "mopen",
      mclose: "mclose",
      mpunct: "mpunct",
      minner: "minner"
    };
    var buildExpression$1 = function buildExpression(expression, options, isRealGroup, surrounding) {
      if (surrounding === void 0) {
        surrounding = [null, null];
      }
      var groups = [];
      for (var i = 0; i < expression.length; i++) {
        var output = buildGroup$1(expression[i], options);
        if (output instanceof DocumentFragment) {
          var children = output.children;
          groups.push(...children);
        } else {
          groups.push(output);
        }
      }
      buildCommon.tryCombineChars(groups);
      if (!isRealGroup) {
        return groups;
      }
      var glueOptions = options;
      if (expression.length === 1) {
        var node = expression[0];
        if (node.type === "sizing") {
          glueOptions = options.havingSize(node.size);
        } else if (node.type === "styling") {
          glueOptions = options.havingStyle(styleMap$1[node.style]);
        }
      }
      var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options);
      var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options);
      var isRoot = isRealGroup === "root";
      traverseNonSpaceNodes(groups, (node, prev) => {
        var prevType = prev.classes[0];
        var type = node.classes[0];
        if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
          prev.classes[0] = "mord";
        } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
          node.classes[0] = "mord";
        }
      }, {
        node: dummyPrev
      }, dummyNext, isRoot);
      traverseNonSpaceNodes(groups, (node, prev) => {
        var prevType = getTypeOfDomTree(prev);
        var type = getTypeOfDomTree(node);
        var space = prevType && type ? node.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
        if (space) {
          return buildCommon.makeGlue(space, glueOptions);
        }
      }, {
        node: dummyPrev
      }, dummyNext, isRoot);
      return groups;
    };
    var traverseNonSpaceNodes = function traverseNonSpaceNodes(nodes, callback, prev, next, isRoot) {
      if (next) {
        nodes.push(next);
      }
      var i = 0;
      for (; i < nodes.length; i++) {
        var node = nodes[i];
        var partialGroup = checkPartialGroup(node);
        if (partialGroup) {
          traverseNonSpaceNodes(partialGroup.children, callback, prev, null, isRoot);
          continue;
        }
        var nonspace = !node.hasClass("mspace");
        if (nonspace) {
          var result = callback(node, prev.node);
          if (result) {
            if (prev.insertAfter) {
              prev.insertAfter(result);
            } else {
              nodes.unshift(result);
              i++;
            }
          }
        }
        if (nonspace) {
          prev.node = node;
        } else if (isRoot && node.hasClass("newline")) {
          prev.node = makeSpan$1(["leftmost"]);
        }
        prev.insertAfter = (index => n => {
          nodes.splice(index + 1, 0, n);
          i++;
        })(i);
      }
      if (next) {
        nodes.pop();
      }
    };
    var checkPartialGroup = function checkPartialGroup(node) {
      if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
        return node;
      }
      return null;
    };
    var getOutermostNode = function getOutermostNode(node, side) {
      var partialGroup = checkPartialGroup(node);
      if (partialGroup) {
        var children = partialGroup.children;
        if (children.length) {
          if (side === "right") {
            return getOutermostNode(children[children.length - 1], "right");
          } else if (side === "left") {
            return getOutermostNode(children[0], "left");
          }
        }
      }
      return node;
    };
    var getTypeOfDomTree = function getTypeOfDomTree(node, side) {
      if (!node) {
        return null;
      }
      if (side) {
        node = getOutermostNode(node, side);
      }
      return DomEnum[node.classes[0]] || null;
    };
    var makeNullDelimiter = function makeNullDelimiter(options, classes) {
      var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
      return makeSpan$1(classes.concat(moreClasses));
    };
    var buildGroup$1 = function buildGroup(group, options, baseOptions) {
      if (!group) {
        return makeSpan$1();
      }
      if (_htmlGroupBuilders[group.type]) {
        var groupNode = _htmlGroupBuilders[group.type](group, options);
        if (baseOptions && options.size !== baseOptions.size) {
          groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);
          var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
          groupNode.height *= multiplier;
          groupNode.depth *= multiplier;
        }
        return groupNode;
      } else {
        throw new ParseError("Got group of unknown type: '" + group.type + "'");
      }
    };
    function buildHTMLUnbreakable(children, options) {
      var body = makeSpan$1(["base"], children, options);
      var strut = makeSpan$1(["strut"]);
      strut.style.height = makeEm(body.height + body.depth);
      if (body.depth) {
        strut.style.verticalAlign = makeEm(-body.depth);
      }
      body.children.unshift(strut);
      return body;
    }
    function buildHTML(tree, options) {
      var tag = null;
      if (tree.length === 1 && tree[0].type === "tag") {
        tag = tree[0].tag;
        tree = tree[0].body;
      }
      var expression = buildExpression$1(tree, options, "root");
      var eqnNum;
      if (expression.length === 2 && expression[1].hasClass("tag")) {
        eqnNum = expression.pop();
      }
      var children = [];
      var parts = [];
      for (var i = 0; i < expression.length; i++) {
        parts.push(expression[i]);
        if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
          var nobreak = false;
          while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
            i++;
            parts.push(expression[i]);
            if (expression[i].hasClass("nobreak")) {
              nobreak = true;
            }
          }
          if (!nobreak) {
            children.push(buildHTMLUnbreakable(parts, options));
            parts = [];
          }
        } else if (expression[i].hasClass("newline")) {
          parts.pop();
          if (parts.length > 0) {
            children.push(buildHTMLUnbreakable(parts, options));
            parts = [];
          }
          children.push(expression[i]);
        }
      }
      if (parts.length > 0) {
        children.push(buildHTMLUnbreakable(parts, options));
      }
      var tagChild;
      if (tag) {
        tagChild = buildHTMLUnbreakable(buildExpression$1(tag, options, true));
        tagChild.classes = ["tag"];
        children.push(tagChild);
      } else if (eqnNum) {
        children.push(eqnNum);
      }
      var htmlNode = makeSpan$1(["katex-html"], children);
      htmlNode.setAttribute("aria-hidden", "true");
      if (tagChild) {
        var strut = tagChild.children[0];
        strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
        if (htmlNode.depth) {
          strut.style.verticalAlign = makeEm(-htmlNode.depth);
        }
      }
      return htmlNode;
    }
    function newDocumentFragment(children) {
      return new DocumentFragment(children);
    }
    class MathNode {
      constructor(type, children, classes) {
        this.type = void 0;
        this.attributes = void 0;
        this.children = void 0;
        this.classes = void 0;
        this.type = type;
        this.attributes = {};
        this.children = children || [];
        this.classes = classes || [];
      }
      setAttribute(name, value) {
        this.attributes[name] = value;
      }
      getAttribute(name) {
        return this.attributes[name];
      }
      toNode() {
        var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
        for (var attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            node.setAttribute(attr, this.attributes[attr]);
          }
        }
        if (this.classes.length > 0) {
          node.className = createClass(this.classes);
        }
        for (var i = 0; i < this.children.length; i++) {
          node.appendChild(this.children[i].toNode());
        }
        return node;
      }
      toMarkup() {
        var markup = "<" + this.type;
        for (var attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "=\"";
            markup += utils.escape(this.attributes[attr]);
            markup += "\"";
          }
        }
        if (this.classes.length > 0) {
          markup += " class =\"" + utils.escape(createClass(this.classes)) + "\"";
        }
        markup += ">";
        for (var i = 0; i < this.children.length; i++) {
          markup += this.children[i].toMarkup();
        }
        markup += "</" + this.type + ">";
        return markup;
      }
      toText() {
        return this.children.map(child => child.toText()).join("");
      }
    }
    class TextNode {
      constructor(text) {
        this.text = void 0;
        this.text = text;
      }
      toNode() {
        return document.createTextNode(this.text);
      }
      toMarkup() {
        return utils.escape(this.toText());
      }
      toText() {
        return this.text;
      }
    }
    class SpaceNode {
      constructor(width) {
        this.width = void 0;
        this.character = void 0;
        this.width = width;
        if (width >= 0.05555 && width <= 0.05556) {
          this.character = "\u200a";
        } else if (width >= 0.1666 && width <= 0.1667) {
          this.character = "\u2009";
        } else if (width >= 0.2222 && width <= 0.2223) {
          this.character = "\u2005";
        } else if (width >= 0.2777 && width <= 0.2778) {
          this.character = "\u2005\u200a";
        } else if (width >= -0.05556 && width <= -0.05555) {
          this.character = "\u200a\u2063";
        } else if (width >= -0.1667 && width <= -0.1666) {
          this.character = "\u2009\u2063";
        } else if (width >= -0.2223 && width <= -0.2222) {
          this.character = "\u205f\u2063";
        } else if (width >= -0.2778 && width <= -0.2777) {
          this.character = "\u2005\u2063";
        } else {
          this.character = null;
        }
      }
      toNode() {
        if (this.character) {
          return document.createTextNode(this.character);
        } else {
          var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
          node.setAttribute("width", makeEm(this.width));
          return node;
        }
      }
      toMarkup() {
        if (this.character) {
          return "<mtext>" + this.character + "</mtext>";
        } else {
          return "<mspace width=\"" + makeEm(this.width) + "\"/>";
        }
      }
      toText() {
        if (this.character) {
          return this.character;
        } else {
          return " ";
        }
      }
    }
    var mathMLTree = {
      MathNode,
      TextNode,
      SpaceNode,
      newDocumentFragment
    };
    var makeText = function makeText(text, mode, options) {
      if (symbols[mode][text] && symbols[mode][text].replace && text.charCodeAt(0) !== 0xD835 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
        text = symbols[mode][text].replace;
      }
      return new mathMLTree.TextNode(text);
    };
    var makeRow = function makeRow(body) {
      if (body.length === 1) {
        return body[0];
      } else {
        return new mathMLTree.MathNode("mrow", body);
      }
    };
    var getVariant = function getVariant(group, options) {
      if (options.fontFamily === "texttt") {
        return "monospace";
      } else if (options.fontFamily === "textsf") {
        if (options.fontShape === "textit" && options.fontWeight === "textbf") {
          return "sans-serif-bold-italic";
        } else if (options.fontShape === "textit") {
          return "sans-serif-italic";
        } else if (options.fontWeight === "textbf") {
          return "bold-sans-serif";
        } else {
          return "sans-serif";
        }
      } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
        return "bold-italic";
      } else if (options.fontShape === "textit") {
        return "italic";
      } else if (options.fontWeight === "textbf") {
        return "bold";
      }
      var font = options.font;
      if (!font || font === "mathnormal") {
        return null;
      }
      var mode = group.mode;
      if (font === "mathit") {
        return "italic";
      } else if (font === "boldsymbol") {
        return group.type === "textord" ? "bold" : "bold-italic";
      } else if (font === "mathbf") {
        return "bold";
      } else if (font === "mathbb") {
        return "double-struck";
      } else if (font === "mathfrak") {
        return "fraktur";
      } else if (font === "mathscr" || font === "mathcal") {
        return "script";
      } else if (font === "mathsf") {
        return "sans-serif";
      } else if (font === "mathtt") {
        return "monospace";
      }
      var text = group.text;
      if (utils.contains(["\\imath", "\\jmath"], text)) {
        return null;
      }
      if (symbols[mode][text] && symbols[mode][text].replace) {
        text = symbols[mode][text].replace;
      }
      var fontName = buildCommon.fontMap[font].fontName;
      if (getCharacterMetrics(text, fontName, mode)) {
        return buildCommon.fontMap[font].variant;
      }
      return null;
    };
    var buildExpression = function buildExpression(expression, options, isOrdgroup) {
      if (expression.length === 1) {
        var group = buildGroup(expression[0], options);
        if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
          group.setAttribute("lspace", "0em");
          group.setAttribute("rspace", "0em");
        }
        return [group];
      }
      var groups = [];
      var lastGroup;
      for (var i = 0; i < expression.length; i++) {
        var _group = buildGroup(expression[i], options);
        if (_group instanceof MathNode && lastGroup instanceof MathNode) {
          if (_group.type === 'mtext' && lastGroup.type === 'mtext' && _group.getAttribute('mathvariant') === lastGroup.getAttribute('mathvariant')) {
            lastGroup.children.push(..._group.children);
            continue;
          } else if (_group.type === 'mn' && lastGroup.type === 'mn') {
            lastGroup.children.push(..._group.children);
            continue;
          } else if (_group.type === 'mi' && _group.children.length === 1 && lastGroup.type === 'mn') {
            var child = _group.children[0];
            if (child instanceof TextNode && child.text === '.') {
              lastGroup.children.push(..._group.children);
              continue;
            }
          } else if (lastGroup.type === 'mi' && lastGroup.children.length === 1) {
            var lastChild = lastGroup.children[0];
            if (lastChild instanceof TextNode && lastChild.text === '\u0338' && (_group.type === 'mo' || _group.type === 'mi' || _group.type === 'mn')) {
              var _child = _group.children[0];
              if (_child instanceof TextNode && _child.text.length > 0) {
                _child.text = _child.text.slice(0, 1) + "\u0338" + _child.text.slice(1);
                groups.pop();
              }
            }
          }
        }
        groups.push(_group);
        lastGroup = _group;
      }
      return groups;
    };
    var buildExpressionRow = function buildExpressionRow(expression, options, isOrdgroup) {
      return makeRow(buildExpression(expression, options, isOrdgroup));
    };
    var buildGroup = function buildGroup(group, options) {
      if (!group) {
        return new mathMLTree.MathNode("mrow");
      }
      if (_mathmlGroupBuilders[group.type]) {
        var result = _mathmlGroupBuilders[group.type](group, options);
        return result;
      } else {
        throw new ParseError("Got group of unknown type: '" + group.type + "'");
      }
    };
    function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
      var expression = buildExpression(tree, options);
      var wrapper;
      if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
        wrapper = expression[0];
      } else {
        wrapper = new mathMLTree.MathNode("mrow", expression);
      }
      var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
      annotation.setAttribute("encoding", "application/x-tex");
      var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
      var math = new mathMLTree.MathNode("math", [semantics]);
      math.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
      if (isDisplayMode) {
        math.setAttribute("display", "block");
      }
      var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
      return buildCommon.makeSpan([wrapperClass], [math]);
    }
    var optionsFromSettings = function optionsFromSettings(settings) {
      return new Options({
        style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
        maxSize: settings.maxSize,
        minRuleThickness: settings.minRuleThickness
      });
    };
    var displayWrap = function displayWrap(node, settings) {
      if (settings.displayMode) {
        var classes = ["katex-display"];
        if (settings.leqno) {
          classes.push("leqno");
        }
        if (settings.fleqn) {
          classes.push("fleqn");
        }
        node = buildCommon.makeSpan(classes, [node]);
      }
      return node;
    };
    var buildTree = function buildTree(tree, expression, settings) {
      var options = optionsFromSettings(settings);
      var katexNode;
      if (settings.output === "mathml") {
        return buildMathML(tree, expression, options, settings.displayMode, true);
      } else if (settings.output === "html") {
        var htmlNode = buildHTML(tree, options);
        katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
      } else {
        var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
        var _htmlNode = buildHTML(tree, options);
        katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
      }
      return displayWrap(katexNode, settings);
    };
    var buildHTMLTree = function buildHTMLTree(tree, expression, settings) {
      var options = optionsFromSettings(settings);
      var htmlNode = buildHTML(tree, options);
      var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
      return displayWrap(katexNode, settings);
    };
    var stretchyCodePoint = {
      widehat: "^",
      widecheck: "",
      widetilde: "~",
      utilde: "~",
      overleftarrow: "\u2190",
      underleftarrow: "\u2190",
      xleftarrow: "\u2190",
      overrightarrow: "\u2192",
      underrightarrow: "\u2192",
      xrightarrow: "\u2192",
      underbrace: "\u23df",
      overbrace: "\u23de",
      overgroup: "\u23e0",
      undergroup: "\u23e1",
      overleftrightarrow: "\u2194",
      underleftrightarrow: "\u2194",
      xleftrightarrow: "\u2194",
      Overrightarrow: "\u21d2",
      xRightarrow: "\u21d2",
      overleftharpoon: "\u21bc",
      xleftharpoonup: "\u21bc",
      overrightharpoon: "\u21c0",
      xrightharpoonup: "\u21c0",
      xLeftarrow: "\u21d0",
      xLeftrightarrow: "\u21d4",
      xhookleftarrow: "\u21a9",
      xhookrightarrow: "\u21aa",
      xmapsto: "\u21a6",
      xrightharpoondown: "\u21c1",
      xleftharpoondown: "\u21bd",
      xrightleftharpoons: "\u21cc",
      xleftrightharpoons: "\u21cb",
      xtwoheadleftarrow: "\u219e",
      xtwoheadrightarrow: "\u21a0",
      xlongequal: "=",
      xtofrom: "\u21c4",
      xrightleftarrows: "\u21c4",
      xrightequilibrium: "\u21cc",
      xleftequilibrium: "\u21cb",
      "\\cdrightarrow": "\u2192",
      "\\cdleftarrow": "\u2190",
      "\\cdlongequal": "="
    };
    var mathMLnode = function mathMLnode(label) {
      var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, '')])]);
      node.setAttribute("stretchy", "true");
      return node;
    };
    var katexImagesData = {
      overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
      overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
      underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
      underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
      xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
      "\\cdrightarrow": [["rightarrow"], 3.0, 522, "xMaxYMin"],
      xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
      "\\cdleftarrow": [["leftarrow"], 3.0, 522, "xMinYMin"],
      Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
      xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
      xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
      overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
      xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
      xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
      overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
      xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
      xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
      xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
      "\\cdlongequal": [["longequal"], 3.0, 334, "xMinYMin"],
      xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
      xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
      overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
      overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
      underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
      underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
      xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
      xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
      xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
      xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
      xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
      xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
      overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
      underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
      overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
      undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
      xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
      xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
      xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
      xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
      xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
    };
    var groupLength = function groupLength(arg) {
      if (arg.type === "ordgroup") {
        return arg.body.length;
      } else {
        return 1;
      }
    };
    var svgSpan = function svgSpan(group, options) {
      function buildSvgSpan_() {
        var viewBoxWidth = 400000;
        var label = group.label.slice(1);
        if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
          var grp = group;
          var numChars = groupLength(grp.base);
          var viewBoxHeight;
          var pathName;
          var _height;
          if (numChars > 5) {
            if (label === "widehat" || label === "widecheck") {
              viewBoxHeight = 420;
              viewBoxWidth = 2364;
              _height = 0.42;
              pathName = label + "4";
            } else {
              viewBoxHeight = 312;
              viewBoxWidth = 2340;
              _height = 0.34;
              pathName = "tilde4";
            }
          } else {
            var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
            if (label === "widehat" || label === "widecheck") {
              viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
              viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
              _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
              pathName = label + imgIndex;
            } else {
              viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
              viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
              _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
              pathName = "tilde" + imgIndex;
            }
          }
          var path = new PathNode(pathName);
          var svgNode = new SvgNode([path], {
            "width": "100%",
            "height": makeEm(_height),
            "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
            "preserveAspectRatio": "none"
          });
          return {
            span: buildCommon.makeSvgSpan([], [svgNode], options),
            minWidth: 0,
            height: _height
          };
        } else {
          var spans = [];
          var data = katexImagesData[label];
          var [paths, _minWidth, _viewBoxHeight] = data;
          var _height2 = _viewBoxHeight / 1000;
          var numSvgChildren = paths.length;
          var widthClasses;
          var aligns;
          if (numSvgChildren === 1) {
            var align1 = data[3];
            widthClasses = ["hide-tail"];
            aligns = [align1];
          } else if (numSvgChildren === 2) {
            widthClasses = ["halfarrow-left", "halfarrow-right"];
            aligns = ["xMinYMin", "xMaxYMin"];
          } else if (numSvgChildren === 3) {
            widthClasses = ["brace-left", "brace-center", "brace-right"];
            aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
          } else {
            throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
          }
          for (var i = 0; i < numSvgChildren; i++) {
            var _path = new PathNode(paths[i]);
            var _svgNode = new SvgNode([_path], {
              "width": "400em",
              "height": makeEm(_height2),
              "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
              "preserveAspectRatio": aligns[i] + " slice"
            });
            var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);
            if (numSvgChildren === 1) {
              return {
                span: _span,
                minWidth: _minWidth,
                height: _height2
              };
            } else {
              _span.style.height = makeEm(_height2);
              spans.push(_span);
            }
          }
          return {
            span: buildCommon.makeSpan(["stretchy"], spans, options),
            minWidth: _minWidth,
            height: _height2
          };
        }
      }
      var {
        span,
        minWidth,
        height
      } = buildSvgSpan_();
      span.height = height;
      span.style.height = makeEm(height);
      if (minWidth > 0) {
        span.style.minWidth = makeEm(minWidth);
      }
      return span;
    };
    var encloseSpan = function encloseSpan(inner, label, topPad, bottomPad, options) {
      var img;
      var totalHeight = inner.height + inner.depth + topPad + bottomPad;
      if (/fbox|color|angl/.test(label)) {
        img = buildCommon.makeSpan(["stretchy", label], [], options);
        if (label === "fbox") {
          var color = options.color && options.getColor();
          if (color) {
            img.style.borderColor = color;
          }
        }
      } else {
        var lines = [];
        if (/^[bx]cancel$/.test(label)) {
          lines.push(new LineNode({
            "x1": "0",
            "y1": "0",
            "x2": "100%",
            "y2": "100%",
            "stroke-width": "0.046em"
          }));
        }
        if (/^x?cancel$/.test(label)) {
          lines.push(new LineNode({
            "x1": "0",
            "y1": "100%",
            "x2": "100%",
            "y2": "0",
            "stroke-width": "0.046em"
          }));
        }
        var svgNode = new SvgNode(lines, {
          "width": "100%",
          "height": makeEm(totalHeight)
        });
        img = buildCommon.makeSvgSpan([], [svgNode], options);
      }
      img.height = totalHeight;
      img.style.height = makeEm(totalHeight);
      return img;
    };
    var stretchy = {
      encloseSpan,
      mathMLnode,
      svgSpan
    };
    function assertNodeType(node, type) {
      if (!node || node.type !== type) {
        throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
      }
      return node;
    }
    function assertSymbolNodeType(node) {
      var typedNode = checkSymbolNodeType(node);
      if (!typedNode) {
        throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
      }
      return typedNode;
    }
    function checkSymbolNodeType(node) {
      if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
        return node;
      }
      return null;
    }
    var htmlBuilder$a = (grp, options) => {
      var base;
      var group;
      var supSubGroup;
      if (grp && grp.type === "supsub") {
        group = assertNodeType(grp.base, "accent");
        base = group.base;
        grp.base = base;
        supSubGroup = assertSpan(buildGroup$1(grp, options));
        grp.base = group;
      } else {
        group = assertNodeType(grp, "accent");
        base = group.base;
      }
      var body = buildGroup$1(base, options.havingCrampedStyle());
      var mustShift = group.isShifty && utils.isCharacterBox(base);
      var skew = 0;
      if (mustShift) {
        var baseChar = utils.getBaseElem(base);
        var baseGroup = buildGroup$1(baseChar, options.havingCrampedStyle());
        skew = assertSymbolDomNode(baseGroup).skew;
      }
      var accentBelow = group.label === "\\c";
      var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
      var accentBody;
      if (!group.isStretchy) {
        var accent;
        var width;
        if (group.label === "\\vec") {
          accent = buildCommon.staticSvg("vec", options);
          width = buildCommon.svgData.vec[1];
        } else {
          accent = buildCommon.makeOrd({
            mode: group.mode,
            text: group.label
          }, options, "textord");
          accent = assertSymbolDomNode(accent);
          accent.italic = 0;
          width = accent.width;
          if (accentBelow) {
            clearance += accent.depth;
          }
        }
        accentBody = buildCommon.makeSpan(["accent-body"], [accent]);
        var accentFull = group.label === "\\textcircled";
        if (accentFull) {
          accentBody.classes.push('accent-full');
          clearance = body.height;
        }
        var left = skew;
        if (!accentFull) {
          left -= width / 2;
        }
        accentBody.style.left = makeEm(left);
        if (group.label === "\\textcircled") {
          accentBody.style.top = ".2em";
        }
        accentBody = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: body
          }, {
            type: "kern",
            size: -clearance
          }, {
            type: "elem",
            elem: accentBody
          }]
        }, options);
      } else {
        accentBody = stretchy.svgSpan(group, options);
        accentBody = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: body
          }, {
            type: "elem",
            elem: accentBody,
            wrapperClasses: ["svg-align"],
            wrapperStyle: skew > 0 ? {
              width: "calc(100% - " + makeEm(2 * skew) + ")",
              marginLeft: makeEm(2 * skew)
            } : undefined
          }]
        }, options);
      }
      var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
      if (supSubGroup) {
        supSubGroup.children[0] = accentWrap;
        supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
        supSubGroup.classes[0] = "mord";
        return supSubGroup;
      } else {
        return accentWrap;
      }
    };
    var mathmlBuilder$9 = (group, options) => {
      var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
      var node = new mathMLTree.MathNode("mover", [buildGroup(group.base, options), accentNode]);
      node.setAttribute("accent", "true");
      return node;
    };
    var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(accent => "\\" + accent).join("|"));
    defineFunction({
      type: "accent",
      names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
      props: {
        numArgs: 1
      },
      handler: (context, args) => {
        var base = normalizeArgument(args[0]);
        var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
        var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
        return {
          type: "accent",
          mode: context.parser.mode,
          label: context.funcName,
          isStretchy: isStretchy,
          isShifty: isShifty,
          base: base
        };
      },
      htmlBuilder: htmlBuilder$a,
      mathmlBuilder: mathmlBuilder$9
    });
    defineFunction({
      type: "accent",
      names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
      props: {
        numArgs: 1,
        allowedInText: true,
        allowedInMath: true,
        argTypes: ["primitive"]
      },
      handler: (context, args) => {
        var base = args[0];
        var mode = context.parser.mode;
        if (mode === "math") {
          context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
          mode = "text";
        }
        return {
          type: "accent",
          mode: mode,
          label: context.funcName,
          isStretchy: false,
          isShifty: true,
          base: base
        };
      },
      htmlBuilder: htmlBuilder$a,
      mathmlBuilder: mathmlBuilder$9
    });
    defineFunction({
      type: "accentUnder",
      names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
      props: {
        numArgs: 1
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName
        } = _ref;
        var base = args[0];
        return {
          type: "accentUnder",
          mode: parser.mode,
          label: funcName,
          base: base
        };
      },
      htmlBuilder: (group, options) => {
        var innerGroup = buildGroup$1(group.base, options);
        var accentBody = stretchy.svgSpan(group, options);
        var kern = group.label === "\\utilde" ? 0.12 : 0;
        var vlist = buildCommon.makeVList({
          positionType: "top",
          positionData: innerGroup.height,
          children: [{
            type: "elem",
            elem: accentBody,
            wrapperClasses: ["svg-align"]
          }, {
            type: "kern",
            size: kern
          }, {
            type: "elem",
            elem: innerGroup
          }]
        }, options);
        return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
      },
      mathmlBuilder: (group, options) => {
        var accentNode = stretchy.mathMLnode(group.label);
        var node = new mathMLTree.MathNode("munder", [buildGroup(group.base, options), accentNode]);
        node.setAttribute("accentunder", "true");
        return node;
      }
    });
    var paddedNode = group => {
      var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
      node.setAttribute("width", "+0.6em");
      node.setAttribute("lspace", "0.3em");
      return node;
    };
    defineFunction({
      type: "xArrow",
      names: ["\\xleftarrow", "\\xrightarrow", "\\xLeftarrow", "\\xRightarrow", "\\xleftrightarrow", "\\xLeftrightarrow", "\\xhookleftarrow", "\\xhookrightarrow", "\\xmapsto", "\\xrightharpoondown", "\\xrightharpoonup", "\\xleftharpoondown", "\\xleftharpoonup", "\\xrightleftharpoons", "\\xleftrightharpoons", "\\xlongequal", "\\xtwoheadrightarrow", "\\xtwoheadleftarrow", "\\xtofrom",
      "\\xrightleftarrows", "\\xrightequilibrium", "\\xleftequilibrium",
      "\\\\cdrightarrow", "\\\\cdleftarrow", "\\\\cdlongequal"],
      props: {
        numArgs: 1,
        numOptionalArgs: 1
      },
      handler(_ref, args, optArgs) {
        var {
          parser,
          funcName
        } = _ref;
        return {
          type: "xArrow",
          mode: parser.mode,
          label: funcName,
          body: args[0],
          below: optArgs[0]
        };
      },
      htmlBuilder(group, options) {
        var style = options.style;
        var newOptions = options.havingStyle(style.sup());
        var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options), options);
        var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
        upperGroup.classes.push(arrowPrefix + "-arrow-pad");
        var lowerGroup;
        if (group.below) {
          newOptions = options.havingStyle(style.sub());
          lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options), options);
          lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
        }
        var arrowBody = stretchy.svgSpan(group, options);
        var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
        var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
        if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
          upperShift -= upperGroup.depth;
        }
        var vlist;
        if (lowerGroup) {
          var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: upperGroup,
              shift: upperShift
            }, {
              type: "elem",
              elem: arrowBody,
              shift: arrowShift
            }, {
              type: "elem",
              elem: lowerGroup,
              shift: lowerShift
            }]
          }, options);
        } else {
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: upperGroup,
              shift: upperShift
            }, {
              type: "elem",
              elem: arrowBody,
              shift: arrowShift
            }]
          }, options);
        }
        vlist.children[0].children[0].children[1].classes.push("svg-align");
        return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
      },
      mathmlBuilder(group, options) {
        var arrowNode = stretchy.mathMLnode(group.label);
        arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
        var node;
        if (group.body) {
          var upperNode = paddedNode(buildGroup(group.body, options));
          if (group.below) {
            var lowerNode = paddedNode(buildGroup(group.below, options));
            node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
          } else {
            node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
          }
        } else if (group.below) {
          var _lowerNode = paddedNode(buildGroup(group.below, options));
          node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
        } else {
          node = paddedNode();
          node = new mathMLTree.MathNode("mover", [arrowNode, node]);
        }
        return node;
      }
    });
    var makeSpan = buildCommon.makeSpan;
    function htmlBuilder$9(group, options) {
      var elements = buildExpression$1(group.body, options, true);
      return makeSpan([group.mclass], elements, options);
    }
    function mathmlBuilder$8(group, options) {
      var node;
      var inner = buildExpression(group.body, options);
      if (group.mclass === "minner") {
        node = new mathMLTree.MathNode("mpadded", inner);
      } else if (group.mclass === "mord") {
        if (group.isCharacterBox) {
          node = inner[0];
          node.type = "mi";
        } else {
          node = new mathMLTree.MathNode("mi", inner);
        }
      } else {
        if (group.isCharacterBox) {
          node = inner[0];
          node.type = "mo";
        } else {
          node = new mathMLTree.MathNode("mo", inner);
        }
        if (group.mclass === "mbin") {
          node.attributes.lspace = "0.22em";
          node.attributes.rspace = "0.22em";
        } else if (group.mclass === "mpunct") {
          node.attributes.lspace = "0em";
          node.attributes.rspace = "0.17em";
        } else if (group.mclass === "mopen" || group.mclass === "mclose") {
          node.attributes.lspace = "0em";
          node.attributes.rspace = "0em";
        } else if (group.mclass === "minner") {
          node.attributes.lspace = "0.0556em";
          node.attributes.width = "+0.1111em";
        }
      }
      return node;
    }
    defineFunction({
      type: "mclass",
      names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
      props: {
        numArgs: 1,
        primitive: true
      },
      handler(_ref, args) {
        var {
          parser,
          funcName
        } = _ref;
        var body = args[0];
        return {
          type: "mclass",
          mode: parser.mode,
          mclass: "m" + funcName.slice(5),
          body: ordargument(body),
          isCharacterBox: utils.isCharacterBox(body)
        };
      },
      htmlBuilder: htmlBuilder$9,
      mathmlBuilder: mathmlBuilder$8
    });
    var binrelClass = arg => {
      var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
      if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
        return "m" + atom.family;
      } else {
        return "mord";
      }
    };
    defineFunction({
      type: "mclass",
      names: ["\\@binrel"],
      props: {
        numArgs: 2
      },
      handler(_ref2, args) {
        var {
          parser
        } = _ref2;
        return {
          type: "mclass",
          mode: parser.mode,
          mclass: binrelClass(args[0]),
          body: ordargument(args[1]),
          isCharacterBox: utils.isCharacterBox(args[1])
        };
      }
    });
    defineFunction({
      type: "mclass",
      names: ["\\stackrel", "\\overset", "\\underset"],
      props: {
        numArgs: 2
      },
      handler(_ref3, args) {
        var {
          parser,
          funcName
        } = _ref3;
        var baseArg = args[1];
        var shiftedArg = args[0];
        var mclass;
        if (funcName !== "\\stackrel") {
          mclass = binrelClass(baseArg);
        } else {
          mclass = "mrel";
        }
        var baseOp = {
          type: "op",
          mode: baseArg.mode,
          limits: true,
          alwaysHandleSupSub: true,
          parentIsSupSub: false,
          symbol: false,
          suppressBaseShift: funcName !== "\\stackrel",
          body: ordargument(baseArg)
        };
        var supsub = {
          type: "supsub",
          mode: shiftedArg.mode,
          base: baseOp,
          sup: funcName === "\\underset" ? null : shiftedArg,
          sub: funcName === "\\underset" ? shiftedArg : null
        };
        return {
          type: "mclass",
          mode: parser.mode,
          mclass,
          body: [supsub],
          isCharacterBox: utils.isCharacterBox(supsub)
        };
      },
      htmlBuilder: htmlBuilder$9,
      mathmlBuilder: mathmlBuilder$8
    });
    defineFunction({
      type: "pmb",
      names: ["\\pmb"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler(_ref, args) {
        var {
          parser
        } = _ref;
        return {
          type: "pmb",
          mode: parser.mode,
          mclass: binrelClass(args[0]),
          body: ordargument(args[0])
        };
      },
      htmlBuilder(group, options) {
        var elements = buildExpression$1(group.body, options, true);
        var node = buildCommon.makeSpan([group.mclass], elements, options);
        node.style.textShadow = "0.02em 0.01em 0.04px";
        return node;
      },
      mathmlBuilder(group, style) {
        var inner = buildExpression(group.body, style);
        var node = new mathMLTree.MathNode("mstyle", inner);
        node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
        return node;
      }
    });
    var cdArrowFunctionName = {
      ">": "\\\\cdrightarrow",
      "<": "\\\\cdleftarrow",
      "=": "\\\\cdlongequal",
      "A": "\\uparrow",
      "V": "\\downarrow",
      "|": "\\Vert",
      ".": "no arrow"
    };
    var newCell = () => {
      return {
        type: "styling",
        body: [],
        mode: "math",
        style: "display"
      };
    };
    var isStartOfArrow = node => {
      return node.type === "textord" && node.text === "@";
    };
    var isLabelEnd = (node, endChar) => {
      return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
    };
    function cdArrow(arrowChar, labels, parser) {
      var funcName = cdArrowFunctionName[arrowChar];
      switch (funcName) {
        case "\\\\cdrightarrow":
        case "\\\\cdleftarrow":
          return parser.callFunction(funcName, [labels[0]], [labels[1]]);
        case "\\uparrow":
        case "\\downarrow":
          {
            var leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
            var bareArrow = {
              type: "atom",
              text: funcName,
              mode: "math",
              family: "rel"
            };
            var sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
            var rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
            var arrowGroup = {
              type: "ordgroup",
              mode: "math",
              body: [leftLabel, sizedArrow, rightLabel]
            };
            return parser.callFunction("\\\\cdparent", [arrowGroup], []);
          }
        case "\\\\cdlongequal":
          return parser.callFunction("\\\\cdlongequal", [], []);
        case "\\Vert":
          {
            var arrow = {
              type: "textord",
              text: "\\Vert",
              mode: "math"
            };
            return parser.callFunction("\\Big", [arrow], []);
          }
        default:
          return {
            type: "textord",
            text: " ",
            mode: "math"
          };
      }
    }
    function parseCD(parser) {
      var parsedRows = [];
      parser.gullet.beginGroup();
      parser.gullet.macros.set("\\cr", "\\\\\\relax");
      parser.gullet.beginGroup();
      while (true) {
        parsedRows.push(parser.parseExpression(false, "\\\\"));
        parser.gullet.endGroup();
        parser.gullet.beginGroup();
        var next = parser.fetch().text;
        if (next === "&" || next === "\\\\") {
          parser.consume();
        } else if (next === "\\end") {
          if (parsedRows[parsedRows.length - 1].length === 0) {
            parsedRows.pop();
          }
          break;
        } else {
          throw new ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
        }
      }
      var row = [];
      var body = [row];
      for (var i = 0; i < parsedRows.length; i++) {
        var rowNodes = parsedRows[i];
        var cell = newCell();
        for (var j = 0; j < rowNodes.length; j++) {
          if (!isStartOfArrow(rowNodes[j])) {
            cell.body.push(rowNodes[j]);
          } else {
            row.push(cell);
            j += 1;
            var arrowChar = assertSymbolNodeType(rowNodes[j]).text;
            var labels = new Array(2);
            labels[0] = {
              type: "ordgroup",
              mode: "math",
              body: []
            };
            labels[1] = {
              type: "ordgroup",
              mode: "math",
              body: []
            };
            if ("=|.".indexOf(arrowChar) > -1) ; else if ("<>AV".indexOf(arrowChar) > -1) {
              for (var labelNum = 0; labelNum < 2; labelNum++) {
                var inLabel = true;
                for (var k = j + 1; k < rowNodes.length; k++) {
                  if (isLabelEnd(rowNodes[k], arrowChar)) {
                    inLabel = false;
                    j = k;
                    break;
                  }
                  if (isStartOfArrow(rowNodes[k])) {
                    throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
                  }
                  labels[labelNum].body.push(rowNodes[k]);
                }
                if (inLabel) {
                  throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
                }
              }
            } else {
              throw new ParseError("Expected one of \"<>AV=|.\" after @", rowNodes[j]);
            }
            var arrow = cdArrow(arrowChar, labels, parser);
            var wrappedArrow = {
              type: "styling",
              body: [arrow],
              mode: "math",
              style: "display"
            };
            row.push(wrappedArrow);
            cell = newCell();
          }
        }
        if (i % 2 === 0) {
          row.push(cell);
        } else {
          row.shift();
        }
        row = [];
        body.push(row);
      }
      parser.gullet.endGroup();
      parser.gullet.endGroup();
      var cols = new Array(body[0].length).fill({
        type: "align",
        align: "c",
        pregap: 0.25,
        postgap: 0.25
      });
      return {
        type: "array",
        mode: "math",
        body,
        arraystretch: 1,
        addJot: true,
        rowGaps: [null],
        cols,
        colSeparationType: "CD",
        hLinesBeforeRow: new Array(body.length + 1).fill([])
      };
    }
    defineFunction({
      type: "cdlabel",
      names: ["\\\\cdleft", "\\\\cdright"],
      props: {
        numArgs: 1
      },
      handler(_ref, args) {
        var {
          parser,
          funcName
        } = _ref;
        return {
          type: "cdlabel",
          mode: parser.mode,
          side: funcName.slice(4),
          label: args[0]
        };
      },
      htmlBuilder(group, options) {
        var newOptions = options.havingStyle(options.style.sup());
        var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options), options);
        label.classes.push("cd-label-" + group.side);
        label.style.bottom = makeEm(0.8 - label.depth);
        label.height = 0;
        label.depth = 0;
        return label;
      },
      mathmlBuilder(group, options) {
        var label = new mathMLTree.MathNode("mrow", [buildGroup(group.label, options)]);
        label = new mathMLTree.MathNode("mpadded", [label]);
        label.setAttribute("width", "0");
        if (group.side === "left") {
          label.setAttribute("lspace", "-1width");
        }
        label.setAttribute("voffset", "0.7em");
        label = new mathMLTree.MathNode("mstyle", [label]);
        label.setAttribute("displaystyle", "false");
        label.setAttribute("scriptlevel", "1");
        return label;
      }
    });
    defineFunction({
      type: "cdlabelparent",
      names: ["\\\\cdparent"],
      props: {
        numArgs: 1
      },
      handler(_ref2, args) {
        var {
          parser
        } = _ref2;
        return {
          type: "cdlabelparent",
          mode: parser.mode,
          fragment: args[0]
        };
      },
      htmlBuilder(group, options) {
        var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options), options);
        parent.classes.push("cd-vert-arrow");
        return parent;
      },
      mathmlBuilder(group, options) {
        return new mathMLTree.MathNode("mrow", [buildGroup(group.fragment, options)]);
      }
    });
    defineFunction({
      type: "textord",
      names: ["\\@char"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler(_ref, args) {
        var {
          parser
        } = _ref;
        var arg = assertNodeType(args[0], "ordgroup");
        var group = arg.body;
        var number = "";
        for (var i = 0; i < group.length; i++) {
          var node = assertNodeType(group[i], "textord");
          number += node.text;
        }
        var code = parseInt(number);
        var text;
        if (isNaN(code)) {
          throw new ParseError("\\@char has non-numeric argument " + number);
        } else if (code < 0 || code >= 0x10ffff) {
          throw new ParseError("\\@char with invalid code point " + number);
        } else if (code <= 0xffff) {
          text = String.fromCharCode(code);
        } else {
          code -= 0x10000;
          text = String.fromCharCode((code >> 10) + 0xd800, (code & 0x3ff) + 0xdc00);
        }
        return {
          type: "textord",
          mode: parser.mode,
          text: text
        };
      }
    });
    var htmlBuilder$8 = (group, options) => {
      var elements = buildExpression$1(group.body, options.withColor(group.color), false);
      return buildCommon.makeFragment(elements);
    };
    var mathmlBuilder$7 = (group, options) => {
      var inner = buildExpression(group.body, options.withColor(group.color));
      var node = new mathMLTree.MathNode("mstyle", inner);
      node.setAttribute("mathcolor", group.color);
      return node;
    };
    defineFunction({
      type: "color",
      names: ["\\textcolor"],
      props: {
        numArgs: 2,
        allowedInText: true,
        argTypes: ["color", "original"]
      },
      handler(_ref, args) {
        var {
          parser
        } = _ref;
        var color = assertNodeType(args[0], "color-token").color;
        var body = args[1];
        return {
          type: "color",
          mode: parser.mode,
          color,
          body: ordargument(body)
        };
      },
      htmlBuilder: htmlBuilder$8,
      mathmlBuilder: mathmlBuilder$7
    });
    defineFunction({
      type: "color",
      names: ["\\color"],
      props: {
        numArgs: 1,
        allowedInText: true,
        argTypes: ["color"]
      },
      handler(_ref2, args) {
        var {
          parser,
          breakOnTokenText
        } = _ref2;
        var color = assertNodeType(args[0], "color-token").color;
        parser.gullet.macros.set("\\current@color", color);
        var body = parser.parseExpression(true, breakOnTokenText);
        return {
          type: "color",
          mode: parser.mode,
          color,
          body
        };
      },
      htmlBuilder: htmlBuilder$8,
      mathmlBuilder: mathmlBuilder$7
    });
    defineFunction({
      type: "cr",
      names: ["\\\\"],
      props: {
        numArgs: 0,
        numOptionalArgs: 0,
        allowedInText: true
      },
      handler(_ref, args, optArgs) {
        var {
          parser
        } = _ref;
        var size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
        var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline " + "does nothing in display mode");
        return {
          type: "cr",
          mode: parser.mode,
          newLine,
          size: size && assertNodeType(size, "size").value
        };
      },
      htmlBuilder(group, options) {
        var span = buildCommon.makeSpan(["mspace"], [], options);
        if (group.newLine) {
          span.classes.push("newline");
          if (group.size) {
            span.style.marginTop = makeEm(calculateSize(group.size, options));
          }
        }
        return span;
      },
      mathmlBuilder(group, options) {
        var node = new mathMLTree.MathNode("mspace");
        if (group.newLine) {
          node.setAttribute("linebreak", "newline");
          if (group.size) {
            node.setAttribute("height", makeEm(calculateSize(group.size, options)));
          }
        }
        return node;
      }
    });
    var globalMap = {
      "\\global": "\\global",
      "\\long": "\\\\globallong",
      "\\\\globallong": "\\\\globallong",
      "\\def": "\\gdef",
      "\\gdef": "\\gdef",
      "\\edef": "\\xdef",
      "\\xdef": "\\xdef",
      "\\let": "\\\\globallet",
      "\\futurelet": "\\\\globalfuture"
    };
    var checkControlSequence = tok => {
      var name = tok.text;
      if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
        throw new ParseError("Expected a control sequence", tok);
      }
      return name;
    };
    var getRHS = parser => {
      var tok = parser.gullet.popToken();
      if (tok.text === "=") {
        tok = parser.gullet.popToken();
        if (tok.text === " ") {
          tok = parser.gullet.popToken();
        }
      }
      return tok;
    };
    var letCommand = (parser, name, tok, global) => {
      var macro = parser.gullet.macros.get(tok.text);
      if (macro == null) {
        tok.noexpand = true;
        macro = {
          tokens: [tok],
          numArgs: 0,
          unexpandable: !parser.gullet.isExpandable(tok.text)
        };
      }
      parser.gullet.macros.set(name, macro, global);
    };
    defineFunction({
      type: "internal",
      names: ["\\global", "\\long", "\\\\globallong"
      ],
      props: {
        numArgs: 0,
        allowedInText: true
      },
      handler(_ref) {
        var {
          parser,
          funcName
        } = _ref;
        parser.consumeSpaces();
        var token = parser.fetch();
        if (globalMap[token.text]) {
          if (funcName === "\\global" || funcName === "\\\\globallong") {
            token.text = globalMap[token.text];
          }
          return assertNodeType(parser.parseFunction(), "internal");
        }
        throw new ParseError("Invalid token after macro prefix", token);
      }
    });
    defineFunction({
      type: "internal",
      names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
      props: {
        numArgs: 0,
        allowedInText: true,
        primitive: true
      },
      handler(_ref2) {
        var {
          parser,
          funcName
        } = _ref2;
        var tok = parser.gullet.popToken();
        var name = tok.text;
        if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
          throw new ParseError("Expected a control sequence", tok);
        }
        var numArgs = 0;
        var insert;
        var delimiters = [[]];
        while (parser.gullet.future().text !== "{") {
          tok = parser.gullet.popToken();
          if (tok.text === "#") {
            if (parser.gullet.future().text === "{") {
              insert = parser.gullet.future();
              delimiters[numArgs].push("{");
              break;
            }
            tok = parser.gullet.popToken();
            if (!/^[1-9]$/.test(tok.text)) {
              throw new ParseError("Invalid argument number \"" + tok.text + "\"");
            }
            if (parseInt(tok.text) !== numArgs + 1) {
              throw new ParseError("Argument number \"" + tok.text + "\" out of order");
            }
            numArgs++;
            delimiters.push([]);
          } else if (tok.text === "EOF") {
            throw new ParseError("Expected a macro definition");
          } else {
            delimiters[numArgs].push(tok.text);
          }
        }
        var {
          tokens
        } = parser.gullet.consumeArg();
        if (insert) {
          tokens.unshift(insert);
        }
        if (funcName === "\\edef" || funcName === "\\xdef") {
          tokens = parser.gullet.expandTokens(tokens);
          tokens.reverse();
        }
        parser.gullet.macros.set(name, {
          tokens,
          numArgs,
          delimiters
        }, funcName === globalMap[funcName]);
        return {
          type: "internal",
          mode: parser.mode
        };
      }
    });
    defineFunction({
      type: "internal",
      names: ["\\let", "\\\\globallet"
      ],
      props: {
        numArgs: 0,
        allowedInText: true,
        primitive: true
      },
      handler(_ref3) {
        var {
          parser,
          funcName
        } = _ref3;
        var name = checkControlSequence(parser.gullet.popToken());
        parser.gullet.consumeSpaces();
        var tok = getRHS(parser);
        letCommand(parser, name, tok, funcName === "\\\\globallet");
        return {
          type: "internal",
          mode: parser.mode
        };
      }
    });
    defineFunction({
      type: "internal",
      names: ["\\futurelet", "\\\\globalfuture"
      ],
      props: {
        numArgs: 0,
        allowedInText: true,
        primitive: true
      },
      handler(_ref4) {
        var {
          parser,
          funcName
        } = _ref4;
        var name = checkControlSequence(parser.gullet.popToken());
        var middle = parser.gullet.popToken();
        var tok = parser.gullet.popToken();
        letCommand(parser, name, tok, funcName === "\\\\globalfuture");
        parser.gullet.pushToken(tok);
        parser.gullet.pushToken(middle);
        return {
          type: "internal",
          mode: parser.mode
        };
      }
    });
    var getMetrics = function getMetrics(symbol, font, mode) {
      var replace = symbols.math[symbol] && symbols.math[symbol].replace;
      var metrics = getCharacterMetrics(replace || symbol, font, mode);
      if (!metrics) {
        throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
      }
      return metrics;
    };
    var styleWrap = function styleWrap(delim, toStyle, options, classes) {
      var newOptions = options.havingBaseStyle(toStyle);
      var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
      var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
      span.height *= delimSizeMultiplier;
      span.depth *= delimSizeMultiplier;
      span.maxFontSize = newOptions.sizeMultiplier;
      return span;
    };
    var centerSpan = function centerSpan(span, options, style) {
      var newOptions = options.havingBaseStyle(style);
      var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
      span.classes.push("delimcenter");
      span.style.top = makeEm(shift);
      span.height -= shift;
      span.depth += shift;
    };
    var makeSmallDelim = function makeSmallDelim(delim, style, center, options, mode, classes) {
      var text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
      var span = styleWrap(text, style, options, classes);
      if (center) {
        centerSpan(span, options, style);
      }
      return span;
    };
    var mathrmSize = function mathrmSize(value, size, mode, options) {
      return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
    };
    var makeLargeDelim = function makeLargeDelim(delim, size, center, options, mode, classes) {
      var inner = mathrmSize(delim, size, mode, options);
      var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner], options), Style$1.TEXT, options, classes);
      if (center) {
        centerSpan(span, options, Style$1.TEXT);
      }
      return span;
    };
    var makeGlyphSpan = function makeGlyphSpan(symbol, font, mode) {
      var sizeClass;
      if (font === "Size1-Regular") {
        sizeClass = "delim-size1";
      } else
        {
          sizeClass = "delim-size4";
        }
      var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
      return {
        type: "elem",
        elem: corner
      };
    };
    var makeInner = function makeInner(ch, height, options) {
      var width = fontMetricsData['Size4-Regular'][ch.charCodeAt(0)] ? fontMetricsData['Size4-Regular'][ch.charCodeAt(0)][4] : fontMetricsData['Size1-Regular'][ch.charCodeAt(0)][4];
      var path = new PathNode("inner", innerPath(ch, Math.round(1000 * height)));
      var svgNode = new SvgNode([path], {
        "width": makeEm(width),
        "height": makeEm(height),
        "style": "width:" + makeEm(width),
        "viewBox": "0 0 " + 1000 * width + " " + Math.round(1000 * height),
        "preserveAspectRatio": "xMinYMin"
      });
      var span = buildCommon.makeSvgSpan([], [svgNode], options);
      span.height = height;
      span.style.height = makeEm(height);
      span.style.width = makeEm(width);
      return {
        type: "elem",
        elem: span
      };
    };
    var lapInEms = 0.008;
    var lap = {
      type: "kern",
      size: -1 * lapInEms
    };
    var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
    var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
    var makeStackedDelim = function makeStackedDelim(delim, heightTotal, center, options, mode, classes) {
      var top;
      var middle;
      var repeat;
      var bottom;
      var svgLabel = "";
      var viewBoxWidth = 0;
      top = repeat = bottom = delim;
      middle = null;
      var font = "Size1-Regular";
      if (delim === "\\uparrow") {
        repeat = bottom = "\u23d0";
      } else if (delim === "\\Uparrow") {
        repeat = bottom = "\u2016";
      } else if (delim === "\\downarrow") {
        top = repeat = "\u23d0";
      } else if (delim === "\\Downarrow") {
        top = repeat = "\u2016";
      } else if (delim === "\\updownarrow") {
        top = "\\uparrow";
        repeat = "\u23d0";
        bottom = "\\downarrow";
      } else if (delim === "\\Updownarrow") {
        top = "\\Uparrow";
        repeat = "\u2016";
        bottom = "\\Downarrow";
      } else if (utils.contains(verts, delim)) {
        repeat = "\u2223";
        svgLabel = "vert";
        viewBoxWidth = 333;
      } else if (utils.contains(doubleVerts, delim)) {
        repeat = "\u2225";
        svgLabel = "doublevert";
        viewBoxWidth = 556;
      } else if (delim === "[" || delim === "\\lbrack") {
        top = "\u23a1";
        repeat = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
        svgLabel = "lbrack";
        viewBoxWidth = 667;
      } else if (delim === "]" || delim === "\\rbrack") {
        top = "\u23a4";
        repeat = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
        svgLabel = "rbrack";
        viewBoxWidth = 667;
      } else if (delim === "\\lfloor" || delim === "\u230a") {
        repeat = top = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
        svgLabel = "lfloor";
        viewBoxWidth = 667;
      } else if (delim === "\\lceil" || delim === "\u2308") {
        top = "\u23a1";
        repeat = bottom = "\u23a2";
        font = "Size4-Regular";
        svgLabel = "lceil";
        viewBoxWidth = 667;
      } else if (delim === "\\rfloor" || delim === "\u230b") {
        repeat = top = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
        svgLabel = "rfloor";
        viewBoxWidth = 667;
      } else if (delim === "\\rceil" || delim === "\u2309") {
        top = "\u23a4";
        repeat = bottom = "\u23a5";
        font = "Size4-Regular";
        svgLabel = "rceil";
        viewBoxWidth = 667;
      } else if (delim === "(" || delim === "\\lparen") {
        top = "\u239b";
        repeat = "\u239c";
        bottom = "\u239d";
        font = "Size4-Regular";
        svgLabel = "lparen";
        viewBoxWidth = 875;
      } else if (delim === ")" || delim === "\\rparen") {
        top = "\u239e";
        repeat = "\u239f";
        bottom = "\u23a0";
        font = "Size4-Regular";
        svgLabel = "rparen";
        viewBoxWidth = 875;
      } else if (delim === "\\{" || delim === "\\lbrace") {
        top = "\u23a7";
        middle = "\u23a8";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\}" || delim === "\\rbrace") {
        top = "\u23ab";
        middle = "\u23ac";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\lgroup" || delim === "\u27ee") {
        top = "\u23a7";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\rgroup" || delim === "\u27ef") {
        top = "\u23ab";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\lmoustache" || delim === "\u23b0") {
        top = "\u23a7";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\rmoustache" || delim === "\u23b1") {
        top = "\u23ab";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
      }
      var topMetrics = getMetrics(top, font, mode);
      var topHeightTotal = topMetrics.height + topMetrics.depth;
      var repeatMetrics = getMetrics(repeat, font, mode);
      var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
      var bottomMetrics = getMetrics(bottom, font, mode);
      var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
      var middleHeightTotal = 0;
      var middleFactor = 1;
      if (middle !== null) {
        var middleMetrics = getMetrics(middle, font, mode);
        middleHeightTotal = middleMetrics.height + middleMetrics.depth;
        middleFactor = 2;
      }
      var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
      var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
      var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
      var axisHeight = options.fontMetrics().axisHeight;
      if (center) {
        axisHeight *= options.sizeMultiplier;
      }
      var depth = realHeightTotal / 2 - axisHeight;
      var stack = [];
      if (svgLabel.length > 0) {
        var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
        var viewBoxHeight = Math.round(realHeightTotal * 1000);
        var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1000));
        var path = new PathNode(svgLabel, pathStr);
        var width = (viewBoxWidth / 1000).toFixed(3) + "em";
        var height = (viewBoxHeight / 1000).toFixed(3) + "em";
        var svg = new SvgNode([path], {
          "width": width,
          "height": height,
          "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
        });
        var wrapper = buildCommon.makeSvgSpan([], [svg], options);
        wrapper.height = viewBoxHeight / 1000;
        wrapper.style.width = width;
        wrapper.style.height = height;
        stack.push({
          type: "elem",
          elem: wrapper
        });
      } else {
        stack.push(makeGlyphSpan(bottom, font, mode));
        stack.push(lap);
        if (middle === null) {
          var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
          stack.push(makeInner(repeat, innerHeight, options));
        } else {
          var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
          stack.push(makeInner(repeat, _innerHeight, options));
          stack.push(lap);
          stack.push(makeGlyphSpan(middle, font, mode));
          stack.push(lap);
          stack.push(makeInner(repeat, _innerHeight, options));
        }
        stack.push(lap);
        stack.push(makeGlyphSpan(top, font, mode));
      }
      var newOptions = options.havingBaseStyle(Style$1.TEXT);
      var inner = buildCommon.makeVList({
        positionType: "bottom",
        positionData: depth,
        children: stack
      }, newOptions);
      return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner], newOptions), Style$1.TEXT, options, classes);
    };
    var vbPad = 80;
    var emPad = 0.08;
    var sqrtSvg = function sqrtSvg(sqrtName, height, viewBoxHeight, extraViniculum, options) {
      var path = sqrtPath(sqrtName, extraViniculum, viewBoxHeight);
      var pathNode = new PathNode(sqrtName, path);
      var svg = new SvgNode([pathNode], {
        "width": "400em",
        "height": makeEm(height),
        "viewBox": "0 0 400000 " + viewBoxHeight,
        "preserveAspectRatio": "xMinYMin slice"
      });
      return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
    };
    var makeSqrtImage = function makeSqrtImage(height, options) {
      var newOptions = options.havingBaseSizing();
      var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
      var sizeMultiplier = newOptions.sizeMultiplier;
      var extraViniculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
      var span;
      var spanHeight = 0;
      var texHeight = 0;
      var viewBoxHeight = 0;
      var advanceWidth;
      if (delim.type === "small") {
        viewBoxHeight = 1000 + 1000 * extraViniculum + vbPad;
        if (height < 1.0) {
          sizeMultiplier = 1.0;
        } else if (height < 1.4) {
          sizeMultiplier = 0.7;
        }
        spanHeight = (1.0 + extraViniculum + emPad) / sizeMultiplier;
        texHeight = (1.00 + extraViniculum) / sizeMultiplier;
        span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraViniculum, options);
        span.style.minWidth = "0.853em";
        advanceWidth = 0.833 / sizeMultiplier;
      } else if (delim.type === "large") {
        viewBoxHeight = (1000 + vbPad) * sizeToMaxHeight[delim.size];
        texHeight = (sizeToMaxHeight[delim.size] + extraViniculum) / sizeMultiplier;
        spanHeight = (sizeToMaxHeight[delim.size] + extraViniculum + emPad) / sizeMultiplier;
        span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraViniculum, options);
        span.style.minWidth = "1.02em";
        advanceWidth = 1.0 / sizeMultiplier;
      } else {
        spanHeight = height + extraViniculum + emPad;
        texHeight = height + extraViniculum;
        viewBoxHeight = Math.floor(1000 * height + extraViniculum) + vbPad;
        span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraViniculum, options);
        span.style.minWidth = "0.742em";
        advanceWidth = 1.056;
      }
      span.height = texHeight;
      span.style.height = makeEm(spanHeight);
      return {
        span,
        advanceWidth,
        ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraViniculum) * sizeMultiplier
      };
    };
    var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230a", "\u230b", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
    var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27ee", "\u27ef", "\\lmoustache", "\\rmoustache", "\u23b0", "\u23b1"];
    var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
    var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];
    var makeSizedDelim = function makeSizedDelim(delim, size, options, mode, classes) {
      if (delim === "<" || delim === "\\lt" || delim === "\u27e8") {
        delim = "\\langle";
      } else if (delim === ">" || delim === "\\gt" || delim === "\u27e9") {
        delim = "\\rangle";
      }
      if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
        return makeLargeDelim(delim, size, false, options, mode, classes);
      } else if (utils.contains(stackAlwaysDelimiters, delim)) {
        return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
      } else {
        throw new ParseError("Illegal delimiter: '" + delim + "'");
      }
    };
    var stackNeverDelimiterSequence = [{
      type: "small",
      style: Style$1.SCRIPTSCRIPT
    }, {
      type: "small",
      style: Style$1.SCRIPT
    }, {
      type: "small",
      style: Style$1.TEXT
    }, {
      type: "large",
      size: 1
    }, {
      type: "large",
      size: 2
    }, {
      type: "large",
      size: 3
    }, {
      type: "large",
      size: 4
    }];
    var stackAlwaysDelimiterSequence = [{
      type: "small",
      style: Style$1.SCRIPTSCRIPT
    }, {
      type: "small",
      style: Style$1.SCRIPT
    }, {
      type: "small",
      style: Style$1.TEXT
    }, {
      type: "stack"
    }];
    var stackLargeDelimiterSequence = [{
      type: "small",
      style: Style$1.SCRIPTSCRIPT
    }, {
      type: "small",
      style: Style$1.SCRIPT
    }, {
      type: "small",
      style: Style$1.TEXT
    }, {
      type: "large",
      size: 1
    }, {
      type: "large",
      size: 2
    }, {
      type: "large",
      size: 3
    }, {
      type: "large",
      size: 4
    }, {
      type: "stack"
    }];
    var delimTypeToFont = function delimTypeToFont(type) {
      if (type.type === "small") {
        return "Main-Regular";
      } else if (type.type === "large") {
        return "Size" + type.size + "-Regular";
      } else if (type.type === "stack") {
        return "Size4-Regular";
      } else {
        throw new Error("Add support for delim type '" + type.type + "' here.");
      }
    };
    var traverseSequence = function traverseSequence(delim, height, sequence, options) {
      var start = Math.min(2, 3 - options.style.size);
      for (var i = start; i < sequence.length; i++) {
        if (sequence[i].type === "stack") {
          break;
        }
        var metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
        var heightDepth = metrics.height + metrics.depth;
        if (sequence[i].type === "small") {
          var newOptions = options.havingBaseStyle(sequence[i].style);
          heightDepth *= newOptions.sizeMultiplier;
        }
        if (heightDepth > height) {
          return sequence[i];
        }
      }
      return sequence[sequence.length - 1];
    };
    var makeCustomSizedDelim = function makeCustomSizedDelim(delim, height, center, options, mode, classes) {
      if (delim === "<" || delim === "\\lt" || delim === "\u27e8") {
        delim = "\\langle";
      } else if (delim === ">" || delim === "\\gt" || delim === "\u27e9") {
        delim = "\\rangle";
      }
      var sequence;
      if (utils.contains(stackNeverDelimiters, delim)) {
        sequence = stackNeverDelimiterSequence;
      } else if (utils.contains(stackLargeDelimiters, delim)) {
        sequence = stackLargeDelimiterSequence;
      } else {
        sequence = stackAlwaysDelimiterSequence;
      }
      var delimType = traverseSequence(delim, height, sequence, options);
      if (delimType.type === "small") {
        return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
      } else if (delimType.type === "large") {
        return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
      } else
        {
          return makeStackedDelim(delim, height, center, options, mode, classes);
        }
    };
    var makeLeftRightDelim = function makeLeftRightDelim(delim, height, depth, options, mode, classes) {
      var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
      var delimiterFactor = 901;
      var delimiterExtend = 5.0 / options.fontMetrics().ptPerEm;
      var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
      var totalHeight = Math.max(
      maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend);
      return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
    };
    var delimiter = {
      sqrtImage: makeSqrtImage,
      sizedDelim: makeSizedDelim,
      sizeToMaxHeight: sizeToMaxHeight,
      customSizedDelim: makeCustomSizedDelim,
      leftRightDelim: makeLeftRightDelim
    };
    var delimiterSizes = {
      "\\bigl": {
        mclass: "mopen",
        size: 1
      },
      "\\Bigl": {
        mclass: "mopen",
        size: 2
      },
      "\\biggl": {
        mclass: "mopen",
        size: 3
      },
      "\\Biggl": {
        mclass: "mopen",
        size: 4
      },
      "\\bigr": {
        mclass: "mclose",
        size: 1
      },
      "\\Bigr": {
        mclass: "mclose",
        size: 2
      },
      "\\biggr": {
        mclass: "mclose",
        size: 3
      },
      "\\Biggr": {
        mclass: "mclose",
        size: 4
      },
      "\\bigm": {
        mclass: "mrel",
        size: 1
      },
      "\\Bigm": {
        mclass: "mrel",
        size: 2
      },
      "\\biggm": {
        mclass: "mrel",
        size: 3
      },
      "\\Biggm": {
        mclass: "mrel",
        size: 4
      },
      "\\big": {
        mclass: "mord",
        size: 1
      },
      "\\Big": {
        mclass: "mord",
        size: 2
      },
      "\\bigg": {
        mclass: "mord",
        size: 3
      },
      "\\Bigg": {
        mclass: "mord",
        size: 4
      }
    };
    var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230a", "\u230b", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27e8", "\\rangle", "\u27e9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27ee", "\u27ef", "\\lmoustache", "\\rmoustache", "\u23b0", "\u23b1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
    function checkDelimiter(delim, context) {
      var symDelim = checkSymbolNodeType(delim);
      if (symDelim && utils.contains(delimiters, symDelim.text)) {
        return symDelim;
      } else if (symDelim) {
        throw new ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
      } else {
        throw new ParseError("Invalid delimiter type '" + delim.type + "'", delim);
      }
    }
    defineFunction({
      type: "delimsizing",
      names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
      props: {
        numArgs: 1,
        argTypes: ["primitive"]
      },
      handler: (context, args) => {
        var delim = checkDelimiter(args[0], context);
        return {
          type: "delimsizing",
          mode: context.parser.mode,
          size: delimiterSizes[context.funcName].size,
          mclass: delimiterSizes[context.funcName].mclass,
          delim: delim.text
        };
      },
      htmlBuilder: (group, options) => {
        if (group.delim === ".") {
          return buildCommon.makeSpan([group.mclass]);
        }
        return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
      },
      mathmlBuilder: group => {
        var children = [];
        if (group.delim !== ".") {
          children.push(makeText(group.delim, group.mode));
        }
        var node = new mathMLTree.MathNode("mo", children);
        if (group.mclass === "mopen" || group.mclass === "mclose") {
          node.setAttribute("fence", "true");
        } else {
          node.setAttribute("fence", "false");
        }
        node.setAttribute("stretchy", "true");
        var size = makeEm(delimiter.sizeToMaxHeight[group.size]);
        node.setAttribute("minsize", size);
        node.setAttribute("maxsize", size);
        return node;
      }
    });
    function assertParsed(group) {
      if (!group.body) {
        throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
      }
    }
    defineFunction({
      type: "leftright-right",
      names: ["\\right"],
      props: {
        numArgs: 1,
        primitive: true
      },
      handler: (context, args) => {
        var color = context.parser.gullet.macros.get("\\current@color");
        if (color && typeof color !== "string") {
          throw new ParseError("\\current@color set to non-string in \\right");
        }
        return {
          type: "leftright-right",
          mode: context.parser.mode,
          delim: checkDelimiter(args[0], context).text,
          color
        };
      }
    });
    defineFunction({
      type: "leftright",
      names: ["\\left"],
      props: {
        numArgs: 1,
        primitive: true
      },
      handler: (context, args) => {
        var delim = checkDelimiter(args[0], context);
        var parser = context.parser;
        ++parser.leftrightDepth;
        var body = parser.parseExpression(false);
        --parser.leftrightDepth;
        parser.expect("\\right", false);
        var right = assertNodeType(parser.parseFunction(), "leftright-right");
        return {
          type: "leftright",
          mode: parser.mode,
          body,
          left: delim.text,
          right: right.delim,
          rightColor: right.color
        };
      },
      htmlBuilder: (group, options) => {
        assertParsed(group);
        var inner = buildExpression$1(group.body, options, true, ["mopen", "mclose"]);
        var innerHeight = 0;
        var innerDepth = 0;
        var hadMiddle = false;
        for (var i = 0; i < inner.length; i++) {
          if (inner[i].isMiddle) {
            hadMiddle = true;
          } else {
            innerHeight = Math.max(inner[i].height, innerHeight);
            innerDepth = Math.max(inner[i].depth, innerDepth);
          }
        }
        innerHeight *= options.sizeMultiplier;
        innerDepth *= options.sizeMultiplier;
        var leftDelim;
        if (group.left === ".") {
          leftDelim = makeNullDelimiter(options, ["mopen"]);
        } else {
          leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
        }
        inner.unshift(leftDelim);
        if (hadMiddle) {
          for (var _i = 1; _i < inner.length; _i++) {
            var middleDelim = inner[_i];
            var isMiddle = middleDelim.isMiddle;
            if (isMiddle) {
              inner[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
            }
          }
        }
        var rightDelim;
        if (group.right === ".") {
          rightDelim = makeNullDelimiter(options, ["mclose"]);
        } else {
          var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
          rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
        }
        inner.push(rightDelim);
        return buildCommon.makeSpan(["minner"], inner, options);
      },
      mathmlBuilder: (group, options) => {
        assertParsed(group);
        var inner = buildExpression(group.body, options);
        if (group.left !== ".") {
          var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
          leftNode.setAttribute("fence", "true");
          inner.unshift(leftNode);
        }
        if (group.right !== ".") {
          var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
          rightNode.setAttribute("fence", "true");
          if (group.rightColor) {
            rightNode.setAttribute("mathcolor", group.rightColor);
          }
          inner.push(rightNode);
        }
        return makeRow(inner);
      }
    });
    defineFunction({
      type: "middle",
      names: ["\\middle"],
      props: {
        numArgs: 1,
        primitive: true
      },
      handler: (context, args) => {
        var delim = checkDelimiter(args[0], context);
        if (!context.parser.leftrightDepth) {
          throw new ParseError("\\middle without preceding \\left", delim);
        }
        return {
          type: "middle",
          mode: context.parser.mode,
          delim: delim.text
        };
      },
      htmlBuilder: (group, options) => {
        var middleDelim;
        if (group.delim === ".") {
          middleDelim = makeNullDelimiter(options, []);
        } else {
          middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
          var isMiddle = {
            delim: group.delim,
            options
          };
          middleDelim.isMiddle = isMiddle;
        }
        return middleDelim;
      },
      mathmlBuilder: (group, options) => {
        var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
        var middleNode = new mathMLTree.MathNode("mo", [textNode]);
        middleNode.setAttribute("fence", "true");
        middleNode.setAttribute("lspace", "0.05em");
        middleNode.setAttribute("rspace", "0.05em");
        return middleNode;
      }
    });
    var htmlBuilder$7 = (group, options) => {
      var inner = buildCommon.wrapFragment(buildGroup$1(group.body, options), options);
      var label = group.label.slice(1);
      var scale = options.sizeMultiplier;
      var img;
      var imgShift = 0;
      var isSingleChar = utils.isCharacterBox(group.body);
      if (label === "sout") {
        img = buildCommon.makeSpan(["stretchy", "sout"]);
        img.height = options.fontMetrics().defaultRuleThickness / scale;
        imgShift = -0.5 * options.fontMetrics().xHeight;
      } else if (label === "phase") {
        var lineWeight = calculateSize({
          number: 0.6,
          unit: "pt"
        }, options);
        var clearance = calculateSize({
          number: 0.35,
          unit: "ex"
        }, options);
        var newOptions = options.havingBaseSizing();
        scale = scale / newOptions.sizeMultiplier;
        var angleHeight = inner.height + inner.depth + lineWeight + clearance;
        inner.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
        var viewBoxHeight = Math.floor(1000 * angleHeight * scale);
        var path = phasePath(viewBoxHeight);
        var svgNode = new SvgNode([new PathNode("phase", path)], {
          "width": "400em",
          "height": makeEm(viewBoxHeight / 1000),
          "viewBox": "0 0 400000 " + viewBoxHeight,
          "preserveAspectRatio": "xMinYMin slice"
        });
        img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
        img.style.height = makeEm(angleHeight);
        imgShift = inner.depth + lineWeight + clearance;
      } else {
        if (/cancel/.test(label)) {
          if (!isSingleChar) {
            inner.classes.push("cancel-pad");
          }
        } else if (label === "angl") {
          inner.classes.push("anglpad");
        } else {
          inner.classes.push("boxpad");
        }
        var topPad = 0;
        var bottomPad = 0;
        var ruleThickness = 0;
        if (/box/.test(label)) {
          ruleThickness = Math.max(options.fontMetrics().fboxrule,
          options.minRuleThickness
          );
          topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
          bottomPad = topPad;
        } else if (label === "angl") {
          ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
          topPad = 4 * ruleThickness;
          bottomPad = Math.max(0, 0.25 - inner.depth);
        } else {
          topPad = isSingleChar ? 0.2 : 0;
          bottomPad = topPad;
        }
        img = stretchy.encloseSpan(inner, label, topPad, bottomPad, options);
        if (/fbox|boxed|fcolorbox/.test(label)) {
          img.style.borderStyle = "solid";
          img.style.borderWidth = makeEm(ruleThickness);
        } else if (label === "angl" && ruleThickness !== 0.049) {
          img.style.borderTopWidth = makeEm(ruleThickness);
          img.style.borderRightWidth = makeEm(ruleThickness);
        }
        imgShift = inner.depth + bottomPad;
        if (group.backgroundColor) {
          img.style.backgroundColor = group.backgroundColor;
          if (group.borderColor) {
            img.style.borderColor = group.borderColor;
          }
        }
      }
      var vlist;
      if (group.backgroundColor) {
        vlist = buildCommon.makeVList({
          positionType: "individualShift",
          children: [
          {
            type: "elem",
            elem: img,
            shift: imgShift
          }, {
            type: "elem",
            elem: inner,
            shift: 0
          }]
        }, options);
      } else {
        var classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
        vlist = buildCommon.makeVList({
          positionType: "individualShift",
          children: [
          {
            type: "elem",
            elem: inner,
            shift: 0
          }, {
            type: "elem",
            elem: img,
            shift: imgShift,
            wrapperClasses: classes
          }]
        }, options);
      }
      if (/cancel/.test(label)) {
        vlist.height = inner.height;
        vlist.depth = inner.depth;
      }
      if (/cancel/.test(label) && !isSingleChar) {
        return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
      } else {
        return buildCommon.makeSpan(["mord"], [vlist], options);
      }
    };
    var mathmlBuilder$6 = (group, options) => {
      var fboxsep = 0;
      var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup(group.body, options)]);
      switch (group.label) {
        case "\\cancel":
          node.setAttribute("notation", "updiagonalstrike");
          break;
        case "\\bcancel":
          node.setAttribute("notation", "downdiagonalstrike");
          break;
        case "\\phase":
          node.setAttribute("notation", "phasorangle");
          break;
        case "\\sout":
          node.setAttribute("notation", "horizontalstrike");
          break;
        case "\\fbox":
          node.setAttribute("notation", "box");
          break;
        case "\\angl":
          node.setAttribute("notation", "actuarial");
          break;
        case "\\fcolorbox":
        case "\\colorbox":
          fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
          node.setAttribute("width", "+" + 2 * fboxsep + "pt");
          node.setAttribute("height", "+" + 2 * fboxsep + "pt");
          node.setAttribute("lspace", fboxsep + "pt");
          node.setAttribute("voffset", fboxsep + "pt");
          if (group.label === "\\fcolorbox") {
            var thk = Math.max(options.fontMetrics().fboxrule,
            options.minRuleThickness
            );
            node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
          }
          break;
        case "\\xcancel":
          node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
          break;
      }
      if (group.backgroundColor) {
        node.setAttribute("mathbackground", group.backgroundColor);
      }
      return node;
    };
    defineFunction({
      type: "enclose",
      names: ["\\colorbox"],
      props: {
        numArgs: 2,
        allowedInText: true,
        argTypes: ["color", "text"]
      },
      handler(_ref, args, optArgs) {
        var {
          parser,
          funcName
        } = _ref;
        var color = assertNodeType(args[0], "color-token").color;
        var body = args[1];
        return {
          type: "enclose",
          mode: parser.mode,
          label: funcName,
          backgroundColor: color,
          body
        };
      },
      htmlBuilder: htmlBuilder$7,
      mathmlBuilder: mathmlBuilder$6
    });
    defineFunction({
      type: "enclose",
      names: ["\\fcolorbox"],
      props: {
        numArgs: 3,
        allowedInText: true,
        argTypes: ["color", "color", "text"]
      },
      handler(_ref2, args, optArgs) {
        var {
          parser,
          funcName
        } = _ref2;
        var borderColor = assertNodeType(args[0], "color-token").color;
        var backgroundColor = assertNodeType(args[1], "color-token").color;
        var body = args[2];
        return {
          type: "enclose",
          mode: parser.mode,
          label: funcName,
          backgroundColor,
          borderColor,
          body
        };
      },
      htmlBuilder: htmlBuilder$7,
      mathmlBuilder: mathmlBuilder$6
    });
    defineFunction({
      type: "enclose",
      names: ["\\fbox"],
      props: {
        numArgs: 1,
        argTypes: ["hbox"],
        allowedInText: true
      },
      handler(_ref3, args) {
        var {
          parser
        } = _ref3;
        return {
          type: "enclose",
          mode: parser.mode,
          label: "\\fbox",
          body: args[0]
        };
      }
    });
    defineFunction({
      type: "enclose",
      names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
      props: {
        numArgs: 1
      },
      handler(_ref4, args) {
        var {
          parser,
          funcName
        } = _ref4;
        var body = args[0];
        return {
          type: "enclose",
          mode: parser.mode,
          label: funcName,
          body
        };
      },
      htmlBuilder: htmlBuilder$7,
      mathmlBuilder: mathmlBuilder$6
    });
    defineFunction({
      type: "enclose",
      names: ["\\angl"],
      props: {
        numArgs: 1,
        argTypes: ["hbox"],
        allowedInText: false
      },
      handler(_ref5, args) {
        var {
          parser
        } = _ref5;
        return {
          type: "enclose",
          mode: parser.mode,
          label: "\\angl",
          body: args[0]
        };
      }
    });
    var _environments = {};
    function defineEnvironment(_ref) {
      var {
        type,
        names,
        props,
        handler,
        htmlBuilder,
        mathmlBuilder
      } = _ref;
      var data = {
        type,
        numArgs: props.numArgs || 0,
        allowedInText: false,
        numOptionalArgs: 0,
        handler
      };
      for (var i = 0; i < names.length; ++i) {
        _environments[names[i]] = data;
      }
      if (htmlBuilder) {
        _htmlGroupBuilders[type] = htmlBuilder;
      }
      if (mathmlBuilder) {
        _mathmlGroupBuilders[type] = mathmlBuilder;
      }
    }
    var _macros = {};
    function defineMacro(name, body) {
      _macros[name] = body;
    }
    function getHLines(parser) {
      var hlineInfo = [];
      parser.consumeSpaces();
      var nxt = parser.fetch().text;
      if (nxt === "\\relax") {
        parser.consume();
        parser.consumeSpaces();
        nxt = parser.fetch().text;
      }
      while (nxt === "\\hline" || nxt === "\\hdashline") {
        parser.consume();
        hlineInfo.push(nxt === "\\hdashline");
        parser.consumeSpaces();
        nxt = parser.fetch().text;
      }
      return hlineInfo;
    }
    var validateAmsEnvironmentContext = context => {
      var settings = context.parser.settings;
      if (!settings.displayMode) {
        throw new ParseError("{" + context.envName + "} can be used only in" + " display mode.");
      }
    };
    function getAutoTag(name) {
      if (name.indexOf("ed") === -1) {
        return name.indexOf("*") === -1;
      }
    }
    function parseArray(parser, _ref, style) {
      var {
        hskipBeforeAndAfter,
        addJot,
        cols,
        arraystretch,
        colSeparationType,
        autoTag,
        singleRow,
        emptySingleRow,
        maxNumCols,
        leqno
      } = _ref;
      parser.gullet.beginGroup();
      if (!singleRow) {
        parser.gullet.macros.set("\\cr", "\\\\\\relax");
      }
      if (!arraystretch) {
        var stretch = parser.gullet.expandMacroAsText("\\arraystretch");
        if (stretch == null) {
          arraystretch = 1;
        } else {
          arraystretch = parseFloat(stretch);
          if (!arraystretch || arraystretch < 0) {
            throw new ParseError("Invalid \\arraystretch: " + stretch);
          }
        }
      }
      parser.gullet.beginGroup();
      var row = [];
      var body = [row];
      var rowGaps = [];
      var hLinesBeforeRow = [];
      var tags = autoTag != null ? [] : undefined;
      function beginRow() {
        if (autoTag) {
          parser.gullet.macros.set("\\@eqnsw", "1", true);
        }
      }
      function endRow() {
        if (tags) {
          if (parser.gullet.macros.get("\\df@tag")) {
            tags.push(parser.subparse([new Token("\\df@tag")]));
            parser.gullet.macros.set("\\df@tag", undefined, true);
          } else {
            tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
          }
        }
      }
      beginRow();
      hLinesBeforeRow.push(getHLines(parser));
      while (true) {
        var cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
        parser.gullet.endGroup();
        parser.gullet.beginGroup();
        cell = {
          type: "ordgroup",
          mode: parser.mode,
          body: cell
        };
        if (style) {
          cell = {
            type: "styling",
            mode: parser.mode,
            style,
            body: [cell]
          };
        }
        row.push(cell);
        var next = parser.fetch().text;
        if (next === "&") {
          if (maxNumCols && row.length === maxNumCols) {
            if (singleRow || colSeparationType) {
              throw new ParseError("Too many tab characters: &", parser.nextToken);
            } else {
              parser.settings.reportNonstrict("textEnv", "Too few columns " + "specified in the {array} column argument.");
            }
          }
          parser.consume();
        } else if (next === "\\end") {
          endRow();
          if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
            body.pop();
          }
          if (hLinesBeforeRow.length < body.length + 1) {
            hLinesBeforeRow.push([]);
          }
          break;
        } else if (next === "\\\\") {
          parser.consume();
          var size = void 0;
          if (parser.gullet.future().text !== " ") {
            size = parser.parseSizeGroup(true);
          }
          rowGaps.push(size ? size.value : null);
          endRow();
          hLinesBeforeRow.push(getHLines(parser));
          row = [];
          body.push(row);
          beginRow();
        } else {
          throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
        }
      }
      parser.gullet.endGroup();
      parser.gullet.endGroup();
      return {
        type: "array",
        mode: parser.mode,
        addJot,
        arraystretch,
        body,
        cols,
        rowGaps,
        hskipBeforeAndAfter,
        hLinesBeforeRow,
        colSeparationType,
        tags,
        leqno
      };
    }
    function dCellStyle(envName) {
      if (envName.slice(0, 1) === "d") {
        return "display";
      } else {
        return "text";
      }
    }
    var htmlBuilder$6 = function htmlBuilder(group, options) {
      var r;
      var c;
      var nr = group.body.length;
      var hLinesBeforeRow = group.hLinesBeforeRow;
      var nc = 0;
      var body = new Array(nr);
      var hlines = [];
      var ruleThickness = Math.max(
      options.fontMetrics().arrayRuleWidth, options.minRuleThickness
      );
      var pt = 1 / options.fontMetrics().ptPerEm;
      var arraycolsep = 5 * pt;
      if (group.colSeparationType && group.colSeparationType === "small") {
        var localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;
        arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
      }
      var baselineskip = group.colSeparationType === "CD" ? calculateSize({
        number: 3,
        unit: "ex"
      }, options) : 12 * pt;
      var jot = 3 * pt;
      var arrayskip = group.arraystretch * baselineskip;
      var arstrutHeight = 0.7 * arrayskip;
      var arstrutDepth = 0.3 * arrayskip;
      var totalHeight = 0;
      function setHLinePos(hlinesInGap) {
        for (var i = 0; i < hlinesInGap.length; ++i) {
          if (i > 0) {
            totalHeight += 0.25;
          }
          hlines.push({
            pos: totalHeight,
            isDashed: hlinesInGap[i]
          });
        }
      }
      setHLinePos(hLinesBeforeRow[0]);
      for (r = 0; r < group.body.length; ++r) {
        var inrow = group.body[r];
        var height = arstrutHeight;
        var depth = arstrutDepth;
        if (nc < inrow.length) {
          nc = inrow.length;
        }
        var outrow = new Array(inrow.length);
        for (c = 0; c < inrow.length; ++c) {
          var elt = buildGroup$1(inrow[c], options);
          if (depth < elt.depth) {
            depth = elt.depth;
          }
          if (height < elt.height) {
            height = elt.height;
          }
          outrow[c] = elt;
        }
        var rowGap = group.rowGaps[r];
        var gap = 0;
        if (rowGap) {
          gap = calculateSize(rowGap, options);
          if (gap > 0) {
            gap += arstrutDepth;
            if (depth < gap) {
              depth = gap;
            }
            gap = 0;
          }
        }
        if (group.addJot) {
          depth += jot;
        }
        outrow.height = height;
        outrow.depth = depth;
        totalHeight += height;
        outrow.pos = totalHeight;
        totalHeight += depth + gap;
        body[r] = outrow;
        setHLinePos(hLinesBeforeRow[r + 1]);
      }
      var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
      var colDescriptions = group.cols || [];
      var cols = [];
      var colSep;
      var colDescrNum;
      var tagSpans = [];
      if (group.tags && group.tags.some(tag => tag)) {
        for (r = 0; r < nr; ++r) {
          var rw = body[r];
          var shift = rw.pos - offset;
          var tag = group.tags[r];
          var tagSpan = void 0;
          if (tag === true) {
            tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
          } else if (tag === false) {
            tagSpan = buildCommon.makeSpan([], [], options);
          } else {
            tagSpan = buildCommon.makeSpan([], buildExpression$1(tag, options, true), options);
          }
          tagSpan.depth = rw.depth;
          tagSpan.height = rw.height;
          tagSpans.push({
            type: "elem",
            elem: tagSpan,
            shift
          });
        }
      }
      for (c = 0, colDescrNum = 0;
      c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {
        var colDescr = colDescriptions[colDescrNum] || {};
        var firstSeparator = true;
        while (colDescr.type === "separator") {
          if (!firstSeparator) {
            colSep = buildCommon.makeSpan(["arraycolsep"], []);
            colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
            cols.push(colSep);
          }
          if (colDescr.separator === "|" || colDescr.separator === ":") {
            var lineType = colDescr.separator === "|" ? "solid" : "dashed";
            var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
            separator.style.height = makeEm(totalHeight);
            separator.style.borderRightWidth = makeEm(ruleThickness);
            separator.style.borderRightStyle = lineType;
            separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
            var _shift = totalHeight - offset;
            if (_shift) {
              separator.style.verticalAlign = makeEm(-_shift);
            }
            cols.push(separator);
          } else {
            throw new ParseError("Invalid separator type: " + colDescr.separator);
          }
          colDescrNum++;
          colDescr = colDescriptions[colDescrNum] || {};
          firstSeparator = false;
        }
        if (c >= nc) {
          continue;
        }
        var sepwidth = void 0;
        if (c > 0 || group.hskipBeforeAndAfter) {
          sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
          if (sepwidth !== 0) {
            colSep = buildCommon.makeSpan(["arraycolsep"], []);
            colSep.style.width = makeEm(sepwidth);
            cols.push(colSep);
          }
        }
        var col = [];
        for (r = 0; r < nr; ++r) {
          var row = body[r];
          var elem = row[c];
          if (!elem) {
            continue;
          }
          var _shift2 = row.pos - offset;
          elem.depth = row.depth;
          elem.height = row.height;
          col.push({
            type: "elem",
            elem: elem,
            shift: _shift2
          });
        }
        col = buildCommon.makeVList({
          positionType: "individualShift",
          children: col
        }, options);
        col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
        cols.push(col);
        if (c < nc - 1 || group.hskipBeforeAndAfter) {
          sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
          if (sepwidth !== 0) {
            colSep = buildCommon.makeSpan(["arraycolsep"], []);
            colSep.style.width = makeEm(sepwidth);
            cols.push(colSep);
          }
        }
      }
      body = buildCommon.makeSpan(["mtable"], cols);
      if (hlines.length > 0) {
        var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
        var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
        var vListElems = [{
          type: "elem",
          elem: body,
          shift: 0
        }];
        while (hlines.length > 0) {
          var hline = hlines.pop();
          var lineShift = hline.pos - offset;
          if (hline.isDashed) {
            vListElems.push({
              type: "elem",
              elem: dashes,
              shift: lineShift
            });
          } else {
            vListElems.push({
              type: "elem",
              elem: line,
              shift: lineShift
            });
          }
        }
        body = buildCommon.makeVList({
          positionType: "individualShift",
          children: vListElems
        }, options);
      }
      if (tagSpans.length === 0) {
        return buildCommon.makeSpan(["mord"], [body], options);
      } else {
        var eqnNumCol = buildCommon.makeVList({
          positionType: "individualShift",
          children: tagSpans
        }, options);
        eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
        return buildCommon.makeFragment([body, eqnNumCol]);
      }
    };
    var alignMap = {
      c: "center ",
      l: "left ",
      r: "right "
    };
    var mathmlBuilder$5 = function mathmlBuilder(group, options) {
      var tbl = [];
      var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
      var tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
      for (var i = 0; i < group.body.length; i++) {
        var rw = group.body[i];
        var row = [];
        for (var j = 0; j < rw.length; j++) {
          row.push(new mathMLTree.MathNode("mtd", [buildGroup(rw[j], options)]));
        }
        if (group.tags && group.tags[i]) {
          row.unshift(glue);
          row.push(glue);
          if (group.leqno) {
            row.unshift(tag);
          } else {
            row.push(tag);
          }
        }
        tbl.push(new mathMLTree.MathNode("mtr", row));
      }
      var table = new mathMLTree.MathNode("mtable", tbl);
      var gap = group.arraystretch === 0.5 ? 0.1
      : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
      table.setAttribute("rowspacing", makeEm(gap));
      var menclose = "";
      var align = "";
      if (group.cols && group.cols.length > 0) {
        var cols = group.cols;
        var columnLines = "";
        var prevTypeWasAlign = false;
        var iStart = 0;
        var iEnd = cols.length;
        if (cols[0].type === "separator") {
          menclose += "top ";
          iStart = 1;
        }
        if (cols[cols.length - 1].type === "separator") {
          menclose += "bottom ";
          iEnd -= 1;
        }
        for (var _i = iStart; _i < iEnd; _i++) {
          if (cols[_i].type === "align") {
            align += alignMap[cols[_i].align];
            if (prevTypeWasAlign) {
              columnLines += "none ";
            }
            prevTypeWasAlign = true;
          } else if (cols[_i].type === "separator") {
            if (prevTypeWasAlign) {
              columnLines += cols[_i].separator === "|" ? "solid " : "dashed ";
              prevTypeWasAlign = false;
            }
          }
        }
        table.setAttribute("columnalign", align.trim());
        if (/[sd]/.test(columnLines)) {
          table.setAttribute("columnlines", columnLines.trim());
        }
      }
      if (group.colSeparationType === "align") {
        var _cols = group.cols || [];
        var spacing = "";
        for (var _i2 = 1; _i2 < _cols.length; _i2++) {
          spacing += _i2 % 2 ? "0em " : "1em ";
        }
        table.setAttribute("columnspacing", spacing.trim());
      } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
        table.setAttribute("columnspacing", "0em");
      } else if (group.colSeparationType === "small") {
        table.setAttribute("columnspacing", "0.2778em");
      } else if (group.colSeparationType === "CD") {
        table.setAttribute("columnspacing", "0.5em");
      } else {
        table.setAttribute("columnspacing", "1em");
      }
      var rowLines = "";
      var hlines = group.hLinesBeforeRow;
      menclose += hlines[0].length > 0 ? "left " : "";
      menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
      for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {
        rowLines += hlines[_i3].length === 0 ? "none "
        : hlines[_i3][0] ? "dashed " : "solid ";
      }
      if (/[sd]/.test(rowLines)) {
        table.setAttribute("rowlines", rowLines.trim());
      }
      if (menclose !== "") {
        table = new mathMLTree.MathNode("menclose", [table]);
        table.setAttribute("notation", menclose.trim());
      }
      if (group.arraystretch && group.arraystretch < 1) {
        table = new mathMLTree.MathNode("mstyle", [table]);
        table.setAttribute("scriptlevel", "1");
      }
      return table;
    };
    var alignedHandler = function alignedHandler(context, args) {
      if (context.envName.indexOf("ed") === -1) {
        validateAmsEnvironmentContext(context);
      }
      var cols = [];
      var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
      var isSplit = context.envName === "split";
      var res = parseArray(context.parser, {
        cols,
        addJot: true,
        autoTag: isSplit ? undefined : getAutoTag(context.envName),
        emptySingleRow: true,
        colSeparationType: separationType,
        maxNumCols: isSplit ? 2 : undefined,
        leqno: context.parser.settings.leqno
      }, "display");
      var numMaths;
      var numCols = 0;
      var emptyGroup = {
        type: "ordgroup",
        mode: context.mode,
        body: []
      };
      if (args[0] && args[0].type === "ordgroup") {
        var arg0 = "";
        for (var i = 0; i < args[0].body.length; i++) {
          var textord = assertNodeType(args[0].body[i], "textord");
          arg0 += textord.text;
        }
        numMaths = Number(arg0);
        numCols = numMaths * 2;
      }
      var isAligned = !numCols;
      res.body.forEach(function (row) {
        for (var _i4 = 1; _i4 < row.length; _i4 += 2) {
          var styling = assertNodeType(row[_i4], "styling");
          var ordgroup = assertNodeType(styling.body[0], "ordgroup");
          ordgroup.body.unshift(emptyGroup);
        }
        if (!isAligned) {
          var curMaths = row.length / 2;
          if (numMaths < curMaths) {
            throw new ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
          }
        } else if (numCols < row.length) {
          numCols = row.length;
        }
      });
      for (var _i5 = 0; _i5 < numCols; ++_i5) {
        var align = "r";
        var pregap = 0;
        if (_i5 % 2 === 1) {
          align = "l";
        } else if (_i5 > 0 && isAligned) {
          pregap = 1;
        }
        cols[_i5] = {
          type: "align",
          align: align,
          pregap: pregap,
          postgap: 0
        };
      }
      res.colSeparationType = isAligned ? "align" : "alignat";
      return res;
    };
    defineEnvironment({
      type: "array",
      names: ["array", "darray"],
      props: {
        numArgs: 1
      },
      handler(context, args) {
        var symNode = checkSymbolNodeType(args[0]);
        var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
        var cols = colalign.map(function (nde) {
          var node = assertSymbolNodeType(nde);
          var ca = node.text;
          if ("lcr".indexOf(ca) !== -1) {
            return {
              type: "align",
              align: ca
            };
          } else if (ca === "|") {
            return {
              type: "separator",
              separator: "|"
            };
          } else if (ca === ":") {
            return {
              type: "separator",
              separator: ":"
            };
          }
          throw new ParseError("Unknown column alignment: " + ca, nde);
        });
        var res = {
          cols,
          hskipBeforeAndAfter: true,
          maxNumCols: cols.length
        };
        return parseArray(context.parser, res, dCellStyle(context.envName));
      },
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineEnvironment({
      type: "array",
      names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
      props: {
        numArgs: 0
      },
      handler(context) {
        var delimiters = {
          "matrix": null,
          "pmatrix": ["(", ")"],
          "bmatrix": ["[", "]"],
          "Bmatrix": ["\\{", "\\}"],
          "vmatrix": ["|", "|"],
          "Vmatrix": ["\\Vert", "\\Vert"]
        }[context.envName.replace("*", "")];
        var colAlign = "c";
        var payload = {
          hskipBeforeAndAfter: false,
          cols: [{
            type: "align",
            align: colAlign
          }]
        };
        if (context.envName.charAt(context.envName.length - 1) === "*") {
          var parser = context.parser;
          parser.consumeSpaces();
          if (parser.fetch().text === "[") {
            parser.consume();
            parser.consumeSpaces();
            colAlign = parser.fetch().text;
            if ("lcr".indexOf(colAlign) === -1) {
              throw new ParseError("Expected l or c or r", parser.nextToken);
            }
            parser.consume();
            parser.consumeSpaces();
            parser.expect("]");
            parser.consume();
            payload.cols = [{
              type: "align",
              align: colAlign
            }];
          }
        }
        var res = parseArray(context.parser, payload, dCellStyle(context.envName));
        var numCols = Math.max(0, ...res.body.map(row => row.length));
        res.cols = new Array(numCols).fill({
          type: "align",
          align: colAlign
        });
        return delimiters ? {
          type: "leftright",
          mode: context.mode,
          body: [res],
          left: delimiters[0],
          right: delimiters[1],
          rightColor: undefined
        } : res;
      },
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineEnvironment({
      type: "array",
      names: ["smallmatrix"],
      props: {
        numArgs: 0
      },
      handler(context) {
        var payload = {
          arraystretch: 0.5
        };
        var res = parseArray(context.parser, payload, "script");
        res.colSeparationType = "small";
        return res;
      },
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineEnvironment({
      type: "array",
      names: ["subarray"],
      props: {
        numArgs: 1
      },
      handler(context, args) {
        var symNode = checkSymbolNodeType(args[0]);
        var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
        var cols = colalign.map(function (nde) {
          var node = assertSymbolNodeType(nde);
          var ca = node.text;
          if ("lc".indexOf(ca) !== -1) {
            return {
              type: "align",
              align: ca
            };
          }
          throw new ParseError("Unknown column alignment: " + ca, nde);
        });
        if (cols.length > 1) {
          throw new ParseError("{subarray} can contain only one column");
        }
        var res = {
          cols,
          hskipBeforeAndAfter: false,
          arraystretch: 0.5
        };
        res = parseArray(context.parser, res, "script");
        if (res.body.length > 0 && res.body[0].length > 1) {
          throw new ParseError("{subarray} can contain only one column");
        }
        return res;
      },
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineEnvironment({
      type: "array",
      names: ["cases", "dcases", "rcases", "drcases"],
      props: {
        numArgs: 0
      },
      handler(context) {
        var payload = {
          arraystretch: 1.2,
          cols: [{
            type: "align",
            align: "l",
            pregap: 0,
            postgap: 1.0
          }, {
            type: "align",
            align: "l",
            pregap: 0,
            postgap: 0
          }]
        };
        var res = parseArray(context.parser, payload, dCellStyle(context.envName));
        return {
          type: "leftright",
          mode: context.mode,
          body: [res],
          left: context.envName.indexOf("r") > -1 ? "." : "\\{",
          right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
          rightColor: undefined
        };
      },
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineEnvironment({
      type: "array",
      names: ["align", "align*", "aligned", "split"],
      props: {
        numArgs: 0
      },
      handler: alignedHandler,
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineEnvironment({
      type: "array",
      names: ["gathered", "gather", "gather*"],
      props: {
        numArgs: 0
      },
      handler(context) {
        if (utils.contains(["gather", "gather*"], context.envName)) {
          validateAmsEnvironmentContext(context);
        }
        var res = {
          cols: [{
            type: "align",
            align: "c"
          }],
          addJot: true,
          colSeparationType: "gather",
          autoTag: getAutoTag(context.envName),
          emptySingleRow: true,
          leqno: context.parser.settings.leqno
        };
        return parseArray(context.parser, res, "display");
      },
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineEnvironment({
      type: "array",
      names: ["alignat", "alignat*", "alignedat"],
      props: {
        numArgs: 1
      },
      handler: alignedHandler,
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineEnvironment({
      type: "array",
      names: ["equation", "equation*"],
      props: {
        numArgs: 0
      },
      handler(context) {
        validateAmsEnvironmentContext(context);
        var res = {
          autoTag: getAutoTag(context.envName),
          emptySingleRow: true,
          singleRow: true,
          maxNumCols: 1,
          leqno: context.parser.settings.leqno
        };
        return parseArray(context.parser, res, "display");
      },
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineEnvironment({
      type: "array",
      names: ["CD"],
      props: {
        numArgs: 0
      },
      handler(context) {
        validateAmsEnvironmentContext(context);
        return parseCD(context.parser);
      },
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
    defineMacro("\\notag", "\\nonumber");
    defineFunction({
      type: "text",
      names: ["\\hline", "\\hdashline"],
      props: {
        numArgs: 0,
        allowedInText: true,
        allowedInMath: true
      },
      handler(context, args) {
        throw new ParseError(context.funcName + " valid only within array environment");
      }
    });
    var environments = _environments;
    defineFunction({
      type: "environment",
      names: ["\\begin", "\\end"],
      props: {
        numArgs: 1,
        argTypes: ["text"]
      },
      handler(_ref, args) {
        var {
          parser,
          funcName
        } = _ref;
        var nameGroup = args[0];
        if (nameGroup.type !== "ordgroup") {
          throw new ParseError("Invalid environment name", nameGroup);
        }
        var envName = "";
        for (var i = 0; i < nameGroup.body.length; ++i) {
          envName += assertNodeType(nameGroup.body[i], "textord").text;
        }
        if (funcName === "\\begin") {
          if (!environments.hasOwnProperty(envName)) {
            throw new ParseError("No such environment: " + envName, nameGroup);
          }
          var env = environments[envName];
          var {
            args: _args,
            optArgs
          } = parser.parseArguments("\\begin{" + envName + "}", env);
          var context = {
            mode: parser.mode,
            envName,
            parser
          };
          var result = env.handler(context, _args, optArgs);
          parser.expect("\\end", false);
          var endNameToken = parser.nextToken;
          var end = assertNodeType(parser.parseFunction(), "environment");
          if (end.name !== envName) {
            throw new ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
          }
          return result;
        }
        return {
          type: "environment",
          mode: parser.mode,
          name: envName,
          nameGroup
        };
      }
    });
    var htmlBuilder$5 = (group, options) => {
      var font = group.font;
      var newOptions = options.withFont(font);
      return buildGroup$1(group.body, newOptions);
    };
    var mathmlBuilder$4 = (group, options) => {
      var font = group.font;
      var newOptions = options.withFont(font);
      return buildGroup(group.body, newOptions);
    };
    var fontAliases = {
      "\\Bbb": "\\mathbb",
      "\\bold": "\\mathbf",
      "\\frak": "\\mathfrak",
      "\\bm": "\\boldsymbol"
    };
    defineFunction({
      type: "font",
      names: [
      "\\mathrm", "\\mathit", "\\mathbf", "\\mathnormal",
      "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf", "\\mathtt",
      "\\Bbb", "\\bold", "\\frak"],
      props: {
        numArgs: 1,
        allowedInArgument: true
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName
        } = _ref;
        var body = normalizeArgument(args[0]);
        var func = funcName;
        if (func in fontAliases) {
          func = fontAliases[func];
        }
        return {
          type: "font",
          mode: parser.mode,
          font: func.slice(1),
          body
        };
      },
      htmlBuilder: htmlBuilder$5,
      mathmlBuilder: mathmlBuilder$4
    });
    defineFunction({
      type: "mclass",
      names: ["\\boldsymbol", "\\bm"],
      props: {
        numArgs: 1
      },
      handler: (_ref2, args) => {
        var {
          parser
        } = _ref2;
        var body = args[0];
        var isCharacterBox = utils.isCharacterBox(body);
        return {
          type: "mclass",
          mode: parser.mode,
          mclass: binrelClass(body),
          body: [{
            type: "font",
            mode: parser.mode,
            font: "boldsymbol",
            body
          }],
          isCharacterBox: isCharacterBox
        };
      }
    });
    defineFunction({
      type: "font",
      names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
      props: {
        numArgs: 0,
        allowedInText: true
      },
      handler: (_ref3, args) => {
        var {
          parser,
          funcName,
          breakOnTokenText
        } = _ref3;
        var {
          mode
        } = parser;
        var body = parser.parseExpression(true, breakOnTokenText);
        var style = "math" + funcName.slice(1);
        return {
          type: "font",
          mode: mode,
          font: style,
          body: {
            type: "ordgroup",
            mode: parser.mode,
            body
          }
        };
      },
      htmlBuilder: htmlBuilder$5,
      mathmlBuilder: mathmlBuilder$4
    });
    var adjustStyle = (size, originalStyle) => {
      var style = originalStyle;
      if (size === "display") {
        style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;
      } else if (size === "text" && style.size === Style$1.DISPLAY.size) {
        style = Style$1.TEXT;
      } else if (size === "script") {
        style = Style$1.SCRIPT;
      } else if (size === "scriptscript") {
        style = Style$1.SCRIPTSCRIPT;
      }
      return style;
    };
    var htmlBuilder$4 = (group, options) => {
      var style = adjustStyle(group.size, options.style);
      var nstyle = style.fracNum();
      var dstyle = style.fracDen();
      var newOptions;
      newOptions = options.havingStyle(nstyle);
      var numerm = buildGroup$1(group.numer, newOptions, options);
      if (group.continued) {
        var hStrut = 8.5 / options.fontMetrics().ptPerEm;
        var dStrut = 3.5 / options.fontMetrics().ptPerEm;
        numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
        numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
      }
      newOptions = options.havingStyle(dstyle);
      var denomm = buildGroup$1(group.denom, newOptions, options);
      var rule;
      var ruleWidth;
      var ruleSpacing;
      if (group.hasBarLine) {
        if (group.barSize) {
          ruleWidth = calculateSize(group.barSize, options);
          rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
        } else {
          rule = buildCommon.makeLineSpan("frac-line", options);
        }
        ruleWidth = rule.height;
        ruleSpacing = rule.height;
      } else {
        rule = null;
        ruleWidth = 0;
        ruleSpacing = options.fontMetrics().defaultRuleThickness;
      }
      var numShift;
      var clearance;
      var denomShift;
      if (style.size === Style$1.DISPLAY.size || group.size === "display") {
        numShift = options.fontMetrics().num1;
        if (ruleWidth > 0) {
          clearance = 3 * ruleSpacing;
        } else {
          clearance = 7 * ruleSpacing;
        }
        denomShift = options.fontMetrics().denom1;
      } else {
        if (ruleWidth > 0) {
          numShift = options.fontMetrics().num2;
          clearance = ruleSpacing;
        } else {
          numShift = options.fontMetrics().num3;
          clearance = 3 * ruleSpacing;
        }
        denomShift = options.fontMetrics().denom2;
      }
      var frac;
      if (!rule) {
        var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
        if (candidateClearance < clearance) {
          numShift += 0.5 * (clearance - candidateClearance);
          denomShift += 0.5 * (clearance - candidateClearance);
        }
        frac = buildCommon.makeVList({
          positionType: "individualShift",
          children: [{
            type: "elem",
            elem: denomm,
            shift: denomShift
          }, {
            type: "elem",
            elem: numerm,
            shift: -numShift
          }]
        }, options);
      } else {
        var axisHeight = options.fontMetrics().axisHeight;
        if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
          numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
        }
        if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
          denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
        }
        var midShift = -(axisHeight - 0.5 * ruleWidth);
        frac = buildCommon.makeVList({
          positionType: "individualShift",
          children: [{
            type: "elem",
            elem: denomm,
            shift: denomShift
          }, {
            type: "elem",
            elem: rule,
            shift: midShift
          }, {
            type: "elem",
            elem: numerm,
            shift: -numShift
          }]
        }, options);
      }
      newOptions = options.havingStyle(style);
      frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
      frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
      var delimSize;
      if (style.size === Style$1.DISPLAY.size) {
        delimSize = options.fontMetrics().delim1;
      } else if (style.size === Style$1.SCRIPTSCRIPT.size) {
        delimSize = options.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
      } else {
        delimSize = options.fontMetrics().delim2;
      }
      var leftDelim;
      var rightDelim;
      if (group.leftDelim == null) {
        leftDelim = makeNullDelimiter(options, ["mopen"]);
      } else {
        leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
      }
      if (group.continued) {
        rightDelim = buildCommon.makeSpan([]);
      } else if (group.rightDelim == null) {
        rightDelim = makeNullDelimiter(options, ["mclose"]);
      } else {
        rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
      }
      return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
    };
    var mathmlBuilder$3 = (group, options) => {
      var node = new mathMLTree.MathNode("mfrac", [buildGroup(group.numer, options), buildGroup(group.denom, options)]);
      if (!group.hasBarLine) {
        node.setAttribute("linethickness", "0px");
      } else if (group.barSize) {
        var ruleWidth = calculateSize(group.barSize, options);
        node.setAttribute("linethickness", makeEm(ruleWidth));
      }
      var style = adjustStyle(group.size, options.style);
      if (style.size !== options.style.size) {
        node = new mathMLTree.MathNode("mstyle", [node]);
        var isDisplay = style.size === Style$1.DISPLAY.size ? "true" : "false";
        node.setAttribute("displaystyle", isDisplay);
        node.setAttribute("scriptlevel", "0");
      }
      if (group.leftDelim != null || group.rightDelim != null) {
        var withDelims = [];
        if (group.leftDelim != null) {
          var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
          leftOp.setAttribute("fence", "true");
          withDelims.push(leftOp);
        }
        withDelims.push(node);
        if (group.rightDelim != null) {
          var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
          rightOp.setAttribute("fence", "true");
          withDelims.push(rightOp);
        }
        return makeRow(withDelims);
      }
      return node;
    };
    defineFunction({
      type: "genfrac",
      names: ["\\dfrac", "\\frac", "\\tfrac", "\\dbinom", "\\binom", "\\tbinom", "\\\\atopfrac",
      "\\\\bracefrac", "\\\\brackfrac"
      ],
      props: {
        numArgs: 2,
        allowedInArgument: true
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName
        } = _ref;
        var numer = args[0];
        var denom = args[1];
        var hasBarLine;
        var leftDelim = null;
        var rightDelim = null;
        var size = "auto";
        switch (funcName) {
          case "\\dfrac":
          case "\\frac":
          case "\\tfrac":
            hasBarLine = true;
            break;
          case "\\\\atopfrac":
            hasBarLine = false;
            break;
          case "\\dbinom":
          case "\\binom":
          case "\\tbinom":
            hasBarLine = false;
            leftDelim = "(";
            rightDelim = ")";
            break;
          case "\\\\bracefrac":
            hasBarLine = false;
            leftDelim = "\\{";
            rightDelim = "\\}";
            break;
          case "\\\\brackfrac":
            hasBarLine = false;
            leftDelim = "[";
            rightDelim = "]";
            break;
          default:
            throw new Error("Unrecognized genfrac command");
        }
        switch (funcName) {
          case "\\dfrac":
          case "\\dbinom":
            size = "display";
            break;
          case "\\tfrac":
          case "\\tbinom":
            size = "text";
            break;
        }
        return {
          type: "genfrac",
          mode: parser.mode,
          continued: false,
          numer,
          denom,
          hasBarLine,
          leftDelim,
          rightDelim,
          size,
          barSize: null
        };
      },
      htmlBuilder: htmlBuilder$4,
      mathmlBuilder: mathmlBuilder$3
    });
    defineFunction({
      type: "genfrac",
      names: ["\\cfrac"],
      props: {
        numArgs: 2
      },
      handler: (_ref2, args) => {
        var {
          parser,
          funcName
        } = _ref2;
        var numer = args[0];
        var denom = args[1];
        return {
          type: "genfrac",
          mode: parser.mode,
          continued: true,
          numer,
          denom,
          hasBarLine: true,
          leftDelim: null,
          rightDelim: null,
          size: "display",
          barSize: null
        };
      }
    });
    defineFunction({
      type: "infix",
      names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
      props: {
        numArgs: 0,
        infix: true
      },
      handler(_ref3) {
        var {
          parser,
          funcName,
          token
        } = _ref3;
        var replaceWith;
        switch (funcName) {
          case "\\over":
            replaceWith = "\\frac";
            break;
          case "\\choose":
            replaceWith = "\\binom";
            break;
          case "\\atop":
            replaceWith = "\\\\atopfrac";
            break;
          case "\\brace":
            replaceWith = "\\\\bracefrac";
            break;
          case "\\brack":
            replaceWith = "\\\\brackfrac";
            break;
          default:
            throw new Error("Unrecognized infix genfrac command");
        }
        return {
          type: "infix",
          mode: parser.mode,
          replaceWith,
          token
        };
      }
    });
    var stylArray = ["display", "text", "script", "scriptscript"];
    var delimFromValue = function delimFromValue(delimString) {
      var delim = null;
      if (delimString.length > 0) {
        delim = delimString;
        delim = delim === "." ? null : delim;
      }
      return delim;
    };
    defineFunction({
      type: "genfrac",
      names: ["\\genfrac"],
      props: {
        numArgs: 6,
        allowedInArgument: true,
        argTypes: ["math", "math", "size", "text", "math", "math"]
      },
      handler(_ref4, args) {
        var {
          parser
        } = _ref4;
        var numer = args[4];
        var denom = args[5];
        var leftNode = normalizeArgument(args[0]);
        var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
        var rightNode = normalizeArgument(args[1]);
        var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
        var barNode = assertNodeType(args[2], "size");
        var hasBarLine;
        var barSize = null;
        if (barNode.isBlank) {
          hasBarLine = true;
        } else {
          barSize = barNode.value;
          hasBarLine = barSize.number > 0;
        }
        var size = "auto";
        var styl = args[3];
        if (styl.type === "ordgroup") {
          if (styl.body.length > 0) {
            var textOrd = assertNodeType(styl.body[0], "textord");
            size = stylArray[Number(textOrd.text)];
          }
        } else {
          styl = assertNodeType(styl, "textord");
          size = stylArray[Number(styl.text)];
        }
        return {
          type: "genfrac",
          mode: parser.mode,
          numer,
          denom,
          continued: false,
          hasBarLine,
          barSize,
          leftDelim,
          rightDelim,
          size
        };
      },
      htmlBuilder: htmlBuilder$4,
      mathmlBuilder: mathmlBuilder$3
    });
    defineFunction({
      type: "infix",
      names: ["\\above"],
      props: {
        numArgs: 1,
        argTypes: ["size"],
        infix: true
      },
      handler(_ref5, args) {
        var {
          parser,
          funcName,
          token
        } = _ref5;
        return {
          type: "infix",
          mode: parser.mode,
          replaceWith: "\\\\abovefrac",
          size: assertNodeType(args[0], "size").value,
          token
        };
      }
    });
    defineFunction({
      type: "genfrac",
      names: ["\\\\abovefrac"],
      props: {
        numArgs: 3,
        argTypes: ["math", "size", "math"]
      },
      handler: (_ref6, args) => {
        var {
          parser,
          funcName
        } = _ref6;
        var numer = args[0];
        var barSize = assert(assertNodeType(args[1], "infix").size);
        var denom = args[2];
        var hasBarLine = barSize.number > 0;
        return {
          type: "genfrac",
          mode: parser.mode,
          numer,
          denom,
          continued: false,
          hasBarLine,
          barSize,
          leftDelim: null,
          rightDelim: null,
          size: "auto"
        };
      },
      htmlBuilder: htmlBuilder$4,
      mathmlBuilder: mathmlBuilder$3
    });
    var htmlBuilder$3 = (grp, options) => {
      var style = options.style;
      var supSubGroup;
      var group;
      if (grp.type === "supsub") {
        supSubGroup = grp.sup ? buildGroup$1(grp.sup, options.havingStyle(style.sup()), options) : buildGroup$1(grp.sub, options.havingStyle(style.sub()), options);
        group = assertNodeType(grp.base, "horizBrace");
      } else {
        group = assertNodeType(grp, "horizBrace");
      }
      var body = buildGroup$1(group.base, options.havingBaseStyle(Style$1.DISPLAY));
      var braceBody = stretchy.svgSpan(group, options);
      var vlist;
      if (group.isOver) {
        vlist = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: body
          }, {
            type: "kern",
            size: 0.1
          }, {
            type: "elem",
            elem: braceBody
          }]
        }, options);
        vlist.children[0].children[0].children[1].classes.push("svg-align");
      } else {
        vlist = buildCommon.makeVList({
          positionType: "bottom",
          positionData: body.depth + 0.1 + braceBody.height,
          children: [{
            type: "elem",
            elem: braceBody
          }, {
            type: "kern",
            size: 0.1
          }, {
            type: "elem",
            elem: body
          }]
        }, options);
        vlist.children[0].children[0].children[0].classes.push("svg-align");
      }
      if (supSubGroup) {
        var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
        if (group.isOver) {
          vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: vSpan
            }, {
              type: "kern",
              size: 0.2
            }, {
              type: "elem",
              elem: supSubGroup
            }]
          }, options);
        } else {
          vlist = buildCommon.makeVList({
            positionType: "bottom",
            positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
            children: [{
              type: "elem",
              elem: supSubGroup
            }, {
              type: "kern",
              size: 0.2
            }, {
              type: "elem",
              elem: vSpan
            }]
          }, options);
        }
      }
      return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
    };
    var mathmlBuilder$2 = (group, options) => {
      var accentNode = stretchy.mathMLnode(group.label);
      return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup(group.base, options), accentNode]);
    };
    defineFunction({
      type: "horizBrace",
      names: ["\\overbrace", "\\underbrace"],
      props: {
        numArgs: 1
      },
      handler(_ref, args) {
        var {
          parser,
          funcName
        } = _ref;
        return {
          type: "horizBrace",
          mode: parser.mode,
          label: funcName,
          isOver: /^\\over/.test(funcName),
          base: args[0]
        };
      },
      htmlBuilder: htmlBuilder$3,
      mathmlBuilder: mathmlBuilder$2
    });
    defineFunction({
      type: "href",
      names: ["\\href"],
      props: {
        numArgs: 2,
        argTypes: ["url", "original"],
        allowedInText: true
      },
      handler: (_ref, args) => {
        var {
          parser
        } = _ref;
        var body = args[1];
        var href = assertNodeType(args[0], "url").url;
        if (!parser.settings.isTrusted({
          command: "\\href",
          url: href
        })) {
          return parser.formatUnsupportedCmd("\\href");
        }
        return {
          type: "href",
          mode: parser.mode,
          href,
          body: ordargument(body)
        };
      },
      htmlBuilder: (group, options) => {
        var elements = buildExpression$1(group.body, options, false);
        return buildCommon.makeAnchor(group.href, [], elements, options);
      },
      mathmlBuilder: (group, options) => {
        var math = buildExpressionRow(group.body, options);
        if (!(math instanceof MathNode)) {
          math = new MathNode("mrow", [math]);
        }
        math.setAttribute("href", group.href);
        return math;
      }
    });
    defineFunction({
      type: "href",
      names: ["\\url"],
      props: {
        numArgs: 1,
        argTypes: ["url"],
        allowedInText: true
      },
      handler: (_ref2, args) => {
        var {
          parser
        } = _ref2;
        var href = assertNodeType(args[0], "url").url;
        if (!parser.settings.isTrusted({
          command: "\\url",
          url: href
        })) {
          return parser.formatUnsupportedCmd("\\url");
        }
        var chars = [];
        for (var i = 0; i < href.length; i++) {
          var c = href[i];
          if (c === "~") {
            c = "\\textasciitilde";
          }
          chars.push({
            type: "textord",
            mode: "text",
            text: c
          });
        }
        var body = {
          type: "text",
          mode: parser.mode,
          font: "\\texttt",
          body: chars
        };
        return {
          type: "href",
          mode: parser.mode,
          href,
          body: ordargument(body)
        };
      }
    });
    defineFunction({
      type: "hbox",
      names: ["\\hbox"],
      props: {
        numArgs: 1,
        argTypes: ["text"],
        allowedInText: true,
        primitive: true
      },
      handler(_ref, args) {
        var {
          parser
        } = _ref;
        return {
          type: "hbox",
          mode: parser.mode,
          body: ordargument(args[0])
        };
      },
      htmlBuilder(group, options) {
        var elements = buildExpression$1(group.body, options, false);
        return buildCommon.makeFragment(elements);
      },
      mathmlBuilder(group, options) {
        return new mathMLTree.MathNode("mrow", buildExpression(group.body, options));
      }
    });
    defineFunction({
      type: "html",
      names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
      props: {
        numArgs: 2,
        argTypes: ["raw", "original"],
        allowedInText: true
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName,
          token
        } = _ref;
        var value = assertNodeType(args[0], "raw").string;
        var body = args[1];
        if (parser.settings.strict) {
          parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
        }
        var trustContext;
        var attributes = {};
        switch (funcName) {
          case "\\htmlClass":
            attributes.class = value;
            trustContext = {
              command: "\\htmlClass",
              class: value
            };
            break;
          case "\\htmlId":
            attributes.id = value;
            trustContext = {
              command: "\\htmlId",
              id: value
            };
            break;
          case "\\htmlStyle":
            attributes.style = value;
            trustContext = {
              command: "\\htmlStyle",
              style: value
            };
            break;
          case "\\htmlData":
            {
              var data = value.split(",");
              for (var i = 0; i < data.length; i++) {
                var keyVal = data[i].split("=");
                if (keyVal.length !== 2) {
                  throw new ParseError("Error parsing key-value for \\htmlData");
                }
                attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
              }
              trustContext = {
                command: "\\htmlData",
                attributes
              };
              break;
            }
          default:
            throw new Error("Unrecognized html command");
        }
        if (!parser.settings.isTrusted(trustContext)) {
          return parser.formatUnsupportedCmd(funcName);
        }
        return {
          type: "html",
          mode: parser.mode,
          attributes,
          body: ordargument(body)
        };
      },
      htmlBuilder: (group, options) => {
        var elements = buildExpression$1(group.body, options, false);
        var classes = ["enclosing"];
        if (group.attributes.class) {
          classes.push(...group.attributes.class.trim().split(/\s+/));
        }
        var span = buildCommon.makeSpan(classes, elements, options);
        for (var attr in group.attributes) {
          if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
            span.setAttribute(attr, group.attributes[attr]);
          }
        }
        return span;
      },
      mathmlBuilder: (group, options) => {
        return buildExpressionRow(group.body, options);
      }
    });
    defineFunction({
      type: "htmlmathml",
      names: ["\\html@mathml"],
      props: {
        numArgs: 2,
        allowedInText: true
      },
      handler: (_ref, args) => {
        var {
          parser
        } = _ref;
        return {
          type: "htmlmathml",
          mode: parser.mode,
          html: ordargument(args[0]),
          mathml: ordargument(args[1])
        };
      },
      htmlBuilder: (group, options) => {
        var elements = buildExpression$1(group.html, options, false);
        return buildCommon.makeFragment(elements);
      },
      mathmlBuilder: (group, options) => {
        return buildExpressionRow(group.mathml, options);
      }
    });
    var sizeData = function sizeData(str) {
      if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
        return {
          number: +str,
          unit: "bp"
        };
      } else {
        var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
        if (!match) {
          throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
        }
        var data = {
          number: +(match[1] + match[2]),
          unit: match[3]
        };
        if (!validUnit(data)) {
          throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
        }
        return data;
      }
    };
    defineFunction({
      type: "includegraphics",
      names: ["\\includegraphics"],
      props: {
        numArgs: 1,
        numOptionalArgs: 1,
        argTypes: ["raw", "url"],
        allowedInText: false
      },
      handler: (_ref, args, optArgs) => {
        var {
          parser
        } = _ref;
        var width = {
          number: 0,
          unit: "em"
        };
        var height = {
          number: 0.9,
          unit: "em"
        };
        var totalheight = {
          number: 0,
          unit: "em"
        };
        var alt = "";
        if (optArgs[0]) {
          var attributeStr = assertNodeType(optArgs[0], "raw").string;
          var attributes = attributeStr.split(",");
          for (var i = 0; i < attributes.length; i++) {
            var keyVal = attributes[i].split("=");
            if (keyVal.length === 2) {
              var str = keyVal[1].trim();
              switch (keyVal[0].trim()) {
                case "alt":
                  alt = str;
                  break;
                case "width":
                  width = sizeData(str);
                  break;
                case "height":
                  height = sizeData(str);
                  break;
                case "totalheight":
                  totalheight = sizeData(str);
                  break;
                default:
                  throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
              }
            }
          }
        }
        var src = assertNodeType(args[0], "url").url;
        if (alt === "") {
          alt = src;
          alt = alt.replace(/^.*[\\/]/, '');
          alt = alt.substring(0, alt.lastIndexOf('.'));
        }
        if (!parser.settings.isTrusted({
          command: "\\includegraphics",
          url: src
        })) {
          return parser.formatUnsupportedCmd("\\includegraphics");
        }
        return {
          type: "includegraphics",
          mode: parser.mode,
          alt: alt,
          width: width,
          height: height,
          totalheight: totalheight,
          src: src
        };
      },
      htmlBuilder: (group, options) => {
        var height = calculateSize(group.height, options);
        var depth = 0;
        if (group.totalheight.number > 0) {
          depth = calculateSize(group.totalheight, options) - height;
        }
        var width = 0;
        if (group.width.number > 0) {
          width = calculateSize(group.width, options);
        }
        var style = {
          height: makeEm(height + depth)
        };
        if (width > 0) {
          style.width = makeEm(width);
        }
        if (depth > 0) {
          style.verticalAlign = makeEm(-depth);
        }
        var node = new Img(group.src, group.alt, style);
        node.height = height;
        node.depth = depth;
        return node;
      },
      mathmlBuilder: (group, options) => {
        var node = new mathMLTree.MathNode("mglyph", []);
        node.setAttribute("alt", group.alt);
        var height = calculateSize(group.height, options);
        var depth = 0;
        if (group.totalheight.number > 0) {
          depth = calculateSize(group.totalheight, options) - height;
          node.setAttribute("valign", makeEm(-depth));
        }
        node.setAttribute("height", makeEm(height + depth));
        if (group.width.number > 0) {
          var width = calculateSize(group.width, options);
          node.setAttribute("width", makeEm(width));
        }
        node.setAttribute("src", group.src);
        return node;
      }
    });
    defineFunction({
      type: "kern",
      names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
      props: {
        numArgs: 1,
        argTypes: ["size"],
        primitive: true,
        allowedInText: true
      },
      handler(_ref, args) {
        var {
          parser,
          funcName
        } = _ref;
        var size = assertNodeType(args[0], "size");
        if (parser.settings.strict) {
          var mathFunction = funcName[1] === 'm';
          var muUnit = size.value.unit === 'mu';
          if (mathFunction) {
            if (!muUnit) {
              parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
            }
            if (parser.mode !== "math") {
              parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
            }
          } else {
            if (muUnit) {
              parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
            }
          }
        }
        return {
          type: "kern",
          mode: parser.mode,
          dimension: size.value
        };
      },
      htmlBuilder(group, options) {
        return buildCommon.makeGlue(group.dimension, options);
      },
      mathmlBuilder(group, options) {
        var dimension = calculateSize(group.dimension, options);
        return new mathMLTree.SpaceNode(dimension);
      }
    });
    defineFunction({
      type: "lap",
      names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName
        } = _ref;
        var body = args[0];
        return {
          type: "lap",
          mode: parser.mode,
          alignment: funcName.slice(5),
          body
        };
      },
      htmlBuilder: (group, options) => {
        var inner;
        if (group.alignment === "clap") {
          inner = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
          inner = buildCommon.makeSpan(["inner"], [inner], options);
        } else {
          inner = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options)]);
        }
        var fix = buildCommon.makeSpan(["fix"], []);
        var node = buildCommon.makeSpan([group.alignment], [inner, fix], options);
        var strut = buildCommon.makeSpan(["strut"]);
        strut.style.height = makeEm(node.height + node.depth);
        if (node.depth) {
          strut.style.verticalAlign = makeEm(-node.depth);
        }
        node.children.unshift(strut);
        node = buildCommon.makeSpan(["thinbox"], [node], options);
        return buildCommon.makeSpan(["mord", "vbox"], [node], options);
      },
      mathmlBuilder: (group, options) => {
        var node = new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options)]);
        if (group.alignment !== "rlap") {
          var offset = group.alignment === "llap" ? "-1" : "-0.5";
          node.setAttribute("lspace", offset + "width");
        }
        node.setAttribute("width", "0px");
        return node;
      }
    });
    defineFunction({
      type: "styling",
      names: ["\\(", "$"],
      props: {
        numArgs: 0,
        allowedInText: true,
        allowedInMath: false
      },
      handler(_ref, args) {
        var {
          funcName,
          parser
        } = _ref;
        var outerMode = parser.mode;
        parser.switchMode("math");
        var close = funcName === "\\(" ? "\\)" : "$";
        var body = parser.parseExpression(false, close);
        parser.expect(close);
        parser.switchMode(outerMode);
        return {
          type: "styling",
          mode: parser.mode,
          style: "text",
          body
        };
      }
    });
    defineFunction({
      type: "text",
      names: ["\\)", "\\]"],
      props: {
        numArgs: 0,
        allowedInText: true,
        allowedInMath: false
      },
      handler(context, args) {
        throw new ParseError("Mismatched " + context.funcName);
      }
    });
    var chooseMathStyle = (group, options) => {
      switch (options.style.size) {
        case Style$1.DISPLAY.size:
          return group.display;
        case Style$1.TEXT.size:
          return group.text;
        case Style$1.SCRIPT.size:
          return group.script;
        case Style$1.SCRIPTSCRIPT.size:
          return group.scriptscript;
        default:
          return group.text;
      }
    };
    defineFunction({
      type: "mathchoice",
      names: ["\\mathchoice"],
      props: {
        numArgs: 4,
        primitive: true
      },
      handler: (_ref, args) => {
        var {
          parser
        } = _ref;
        return {
          type: "mathchoice",
          mode: parser.mode,
          display: ordargument(args[0]),
          text: ordargument(args[1]),
          script: ordargument(args[2]),
          scriptscript: ordargument(args[3])
        };
      },
      htmlBuilder: (group, options) => {
        var body = chooseMathStyle(group, options);
        var elements = buildExpression$1(body, options, false);
        return buildCommon.makeFragment(elements);
      },
      mathmlBuilder: (group, options) => {
        var body = chooseMathStyle(group, options);
        return buildExpressionRow(body, options);
      }
    });
    var assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {
      base = buildCommon.makeSpan([], [base]);
      var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
      var sub;
      var sup;
      if (supGroup) {
        var elem = buildGroup$1(supGroup, options.havingStyle(style.sup()), options);
        sup = {
          elem,
          kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
        };
      }
      if (subGroup) {
        var _elem = buildGroup$1(subGroup, options.havingStyle(style.sub()), options);
        sub = {
          elem: _elem,
          kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
        };
      }
      var finalGroup;
      if (sup && sub) {
        var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;
        finalGroup = buildCommon.makeVList({
          positionType: "bottom",
          positionData: bottom,
          children: [{
            type: "kern",
            size: options.fontMetrics().bigOpSpacing5
          }, {
            type: "elem",
            elem: sub.elem,
            marginLeft: makeEm(-slant)
          }, {
            type: "kern",
            size: sub.kern
          }, {
            type: "elem",
            elem: base
          }, {
            type: "kern",
            size: sup.kern
          }, {
            type: "elem",
            elem: sup.elem,
            marginLeft: makeEm(slant)
          }, {
            type: "kern",
            size: options.fontMetrics().bigOpSpacing5
          }]
        }, options);
      } else if (sub) {
        var top = base.height - baseShift;
        finalGroup = buildCommon.makeVList({
          positionType: "top",
          positionData: top,
          children: [{
            type: "kern",
            size: options.fontMetrics().bigOpSpacing5
          }, {
            type: "elem",
            elem: sub.elem,
            marginLeft: makeEm(-slant)
          }, {
            type: "kern",
            size: sub.kern
          }, {
            type: "elem",
            elem: base
          }]
        }, options);
      } else if (sup) {
        var _bottom = base.depth + baseShift;
        finalGroup = buildCommon.makeVList({
          positionType: "bottom",
          positionData: _bottom,
          children: [{
            type: "elem",
            elem: base
          }, {
            type: "kern",
            size: sup.kern
          }, {
            type: "elem",
            elem: sup.elem,
            marginLeft: makeEm(slant)
          }, {
            type: "kern",
            size: options.fontMetrics().bigOpSpacing5
          }]
        }, options);
      } else {
        return base;
      }
      var parts = [finalGroup];
      if (sub && slant !== 0 && !subIsSingleCharacter) {
        var spacer = buildCommon.makeSpan(["mspace"], [], options);
        spacer.style.marginRight = makeEm(slant);
        parts.unshift(spacer);
      }
      return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
    };
    var noSuccessor = ["\\smallint"];
    var htmlBuilder$2 = (grp, options) => {
      var supGroup;
      var subGroup;
      var hasLimits = false;
      var group;
      if (grp.type === "supsub") {
        supGroup = grp.sup;
        subGroup = grp.sub;
        group = assertNodeType(grp.base, "op");
        hasLimits = true;
      } else {
        group = assertNodeType(grp, "op");
      }
      var style = options.style;
      var large = false;
      if (style.size === Style$1.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
        large = true;
      }
      var base;
      if (group.symbol) {
        var fontName = large ? "Size2-Regular" : "Size1-Regular";
        var stash = "";
        if (group.name === "\\oiint" || group.name === "\\oiiint") {
          stash = group.name.slice(1);
          group.name = stash === "oiint" ? "\\iint" : "\\iiint";
        }
        base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
        if (stash.length > 0) {
          var italic = base.italic;
          var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
          base = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: base,
              shift: 0
            }, {
              type: "elem",
              elem: oval,
              shift: large ? 0.08 : 0
            }]
          }, options);
          group.name = "\\" + stash;
          base.classes.unshift("mop");
          base.italic = italic;
        }
      } else if (group.body) {
        var inner = buildExpression$1(group.body, options, true);
        if (inner.length === 1 && inner[0] instanceof SymbolNode) {
          base = inner[0];
          base.classes[0] = "mop";
        } else {
          base = buildCommon.makeSpan(["mop"], inner, options);
        }
      } else {
        var output = [];
        for (var i = 1; i < group.name.length; i++) {
          output.push(buildCommon.mathsym(group.name[i], group.mode, options));
        }
        base = buildCommon.makeSpan(["mop"], output, options);
      }
      var baseShift = 0;
      var slant = 0;
      if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
        baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight;
        slant = base.italic;
      }
      if (hasLimits) {
        return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);
      } else {
        if (baseShift) {
          base.style.position = "relative";
          base.style.top = makeEm(baseShift);
        }
        return base;
      }
    };
    var mathmlBuilder$1 = (group, options) => {
      var node;
      if (group.symbol) {
        node = new MathNode("mo", [makeText(group.name, group.mode)]);
        if (utils.contains(noSuccessor, group.name)) {
          node.setAttribute("largeop", "false");
        }
      } else if (group.body) {
        node = new MathNode("mo", buildExpression(group.body, options));
      } else {
        node = new MathNode("mi", [new TextNode(group.name.slice(1))]);
        var operator = new MathNode("mo", [makeText("\u2061", "text")]);
        if (group.parentIsSupSub) {
          node = new MathNode("mrow", [node, operator]);
        } else {
          node = newDocumentFragment([node, operator]);
        }
      }
      return node;
    };
    var singleCharBigOps = {
      "\u220F": "\\prod",
      "\u2210": "\\coprod",
      "\u2211": "\\sum",
      "\u22c0": "\\bigwedge",
      "\u22c1": "\\bigvee",
      "\u22c2": "\\bigcap",
      "\u22c3": "\\bigcup",
      "\u2a00": "\\bigodot",
      "\u2a01": "\\bigoplus",
      "\u2a02": "\\bigotimes",
      "\u2a04": "\\biguplus",
      "\u2a06": "\\bigsqcup"
    };
    defineFunction({
      type: "op",
      names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22c0", "\u22c1", "\u22c2", "\u22c3", "\u2a00", "\u2a01", "\u2a02", "\u2a04", "\u2a06"],
      props: {
        numArgs: 0
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName
        } = _ref;
        var fName = funcName;
        if (fName.length === 1) {
          fName = singleCharBigOps[fName];
        }
        return {
          type: "op",
          mode: parser.mode,
          limits: true,
          parentIsSupSub: false,
          symbol: true,
          name: fName
        };
      },
      htmlBuilder: htmlBuilder$2,
      mathmlBuilder: mathmlBuilder$1
    });
    defineFunction({
      type: "op",
      names: ["\\mathop"],
      props: {
        numArgs: 1,
        primitive: true
      },
      handler: (_ref2, args) => {
        var {
          parser
        } = _ref2;
        var body = args[0];
        return {
          type: "op",
          mode: parser.mode,
          limits: false,
          parentIsSupSub: false,
          symbol: false,
          body: ordargument(body)
        };
      },
      htmlBuilder: htmlBuilder$2,
      mathmlBuilder: mathmlBuilder$1
    });
    var singleCharIntegrals = {
      "\u222b": "\\int",
      "\u222c": "\\iint",
      "\u222d": "\\iiint",
      "\u222e": "\\oint",
      "\u222f": "\\oiint",
      "\u2230": "\\oiiint"
    };
    defineFunction({
      type: "op",
      names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
      props: {
        numArgs: 0
      },
      handler(_ref3) {
        var {
          parser,
          funcName
        } = _ref3;
        return {
          type: "op",
          mode: parser.mode,
          limits: false,
          parentIsSupSub: false,
          symbol: false,
          name: funcName
        };
      },
      htmlBuilder: htmlBuilder$2,
      mathmlBuilder: mathmlBuilder$1
    });
    defineFunction({
      type: "op",
      names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
      props: {
        numArgs: 0
      },
      handler(_ref4) {
        var {
          parser,
          funcName
        } = _ref4;
        return {
          type: "op",
          mode: parser.mode,
          limits: true,
          parentIsSupSub: false,
          symbol: false,
          name: funcName
        };
      },
      htmlBuilder: htmlBuilder$2,
      mathmlBuilder: mathmlBuilder$1
    });
    defineFunction({
      type: "op",
      names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222b", "\u222c", "\u222d", "\u222e", "\u222f", "\u2230"],
      props: {
        numArgs: 0
      },
      handler(_ref5) {
        var {
          parser,
          funcName
        } = _ref5;
        var fName = funcName;
        if (fName.length === 1) {
          fName = singleCharIntegrals[fName];
        }
        return {
          type: "op",
          mode: parser.mode,
          limits: false,
          parentIsSupSub: false,
          symbol: true,
          name: fName
        };
      },
      htmlBuilder: htmlBuilder$2,
      mathmlBuilder: mathmlBuilder$1
    });
    var htmlBuilder$1 = (grp, options) => {
      var supGroup;
      var subGroup;
      var hasLimits = false;
      var group;
      if (grp.type === "supsub") {
        supGroup = grp.sup;
        subGroup = grp.sub;
        group = assertNodeType(grp.base, "operatorname");
        hasLimits = true;
      } else {
        group = assertNodeType(grp, "operatorname");
      }
      var base;
      if (group.body.length > 0) {
        var body = group.body.map(child => {
          var childText = child.text;
          if (typeof childText === "string") {
            return {
              type: "textord",
              mode: child.mode,
              text: childText
            };
          } else {
            return child;
          }
        });
        var expression = buildExpression$1(body, options.withFont("mathrm"), true);
        for (var i = 0; i < expression.length; i++) {
          var child = expression[i];
          if (child instanceof SymbolNode) {
            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
          }
        }
        base = buildCommon.makeSpan(["mop"], expression, options);
      } else {
        base = buildCommon.makeSpan(["mop"], [], options);
      }
      if (hasLimits) {
        return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
      } else {
        return base;
      }
    };
    var mathmlBuilder = (group, options) => {
      var expression = buildExpression(group.body, options.withFont("mathrm"));
      var isAllString = true;
      for (var i = 0; i < expression.length; i++) {
        var node = expression[i];
        if (node instanceof mathMLTree.SpaceNode) ; else if (node instanceof mathMLTree.MathNode) {
          switch (node.type) {
            case "mi":
            case "mn":
            case "ms":
            case "mspace":
            case "mtext":
              break;
            case "mo":
              {
                var child = node.children[0];
                if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                  child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                } else {
                  isAllString = false;
                }
                break;
              }
            default:
              isAllString = false;
          }
        } else {
          isAllString = false;
        }
      }
      if (isAllString) {
        var word = expression.map(node => node.toText()).join("");
        expression = [new mathMLTree.TextNode(word)];
      }
      var identifier = new mathMLTree.MathNode("mi", expression);
      identifier.setAttribute("mathvariant", "normal");
      var operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
      if (group.parentIsSupSub) {
        return new mathMLTree.MathNode("mrow", [identifier, operator]);
      } else {
        return mathMLTree.newDocumentFragment([identifier, operator]);
      }
    };
    defineFunction({
      type: "operatorname",
      names: ["\\operatorname@", "\\operatornamewithlimits"],
      props: {
        numArgs: 1
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName
        } = _ref;
        var body = args[0];
        return {
          type: "operatorname",
          mode: parser.mode,
          body: ordargument(body),
          alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
          limits: false,
          parentIsSupSub: false
        };
      },
      htmlBuilder: htmlBuilder$1,
      mathmlBuilder
    });
    defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
    defineFunctionBuilders({
      type: "ordgroup",
      htmlBuilder(group, options) {
        if (group.semisimple) {
          return buildCommon.makeFragment(buildExpression$1(group.body, options, false));
        }
        return buildCommon.makeSpan(["mord"], buildExpression$1(group.body, options, true), options);
      },
      mathmlBuilder(group, options) {
        return buildExpressionRow(group.body, options, true);
      }
    });
    defineFunction({
      type: "overline",
      names: ["\\overline"],
      props: {
        numArgs: 1
      },
      handler(_ref, args) {
        var {
          parser
        } = _ref;
        var body = args[0];
        return {
          type: "overline",
          mode: parser.mode,
          body
        };
      },
      htmlBuilder(group, options) {
        var innerGroup = buildGroup$1(group.body, options.havingCrampedStyle());
        var line = buildCommon.makeLineSpan("overline-line", options);
        var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
        var vlist = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: innerGroup
          }, {
            type: "kern",
            size: 3 * defaultRuleThickness
          }, {
            type: "elem",
            elem: line
          }, {
            type: "kern",
            size: defaultRuleThickness
          }]
        }, options);
        return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
      },
      mathmlBuilder(group, options) {
        var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203e")]);
        operator.setAttribute("stretchy", "true");
        var node = new mathMLTree.MathNode("mover", [buildGroup(group.body, options), operator]);
        node.setAttribute("accent", "true");
        return node;
      }
    });
    defineFunction({
      type: "phantom",
      names: ["\\phantom"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler: (_ref, args) => {
        var {
          parser
        } = _ref;
        var body = args[0];
        return {
          type: "phantom",
          mode: parser.mode,
          body: ordargument(body)
        };
      },
      htmlBuilder: (group, options) => {
        var elements = buildExpression$1(group.body, options.withPhantom(), false);
        return buildCommon.makeFragment(elements);
      },
      mathmlBuilder: (group, options) => {
        var inner = buildExpression(group.body, options);
        return new mathMLTree.MathNode("mphantom", inner);
      }
    });
    defineFunction({
      type: "hphantom",
      names: ["\\hphantom"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler: (_ref2, args) => {
        var {
          parser
        } = _ref2;
        var body = args[0];
        return {
          type: "hphantom",
          mode: parser.mode,
          body
        };
      },
      htmlBuilder: (group, options) => {
        var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options.withPhantom())]);
        node.height = 0;
        node.depth = 0;
        if (node.children) {
          for (var i = 0; i < node.children.length; i++) {
            node.children[i].height = 0;
            node.children[i].depth = 0;
          }
        }
        node = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: node
          }]
        }, options);
        return buildCommon.makeSpan(["mord"], [node], options);
      },
      mathmlBuilder: (group, options) => {
        var inner = buildExpression(ordargument(group.body), options);
        var phantom = new mathMLTree.MathNode("mphantom", inner);
        var node = new mathMLTree.MathNode("mpadded", [phantom]);
        node.setAttribute("height", "0px");
        node.setAttribute("depth", "0px");
        return node;
      }
    });
    defineFunction({
      type: "vphantom",
      names: ["\\vphantom"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler: (_ref3, args) => {
        var {
          parser
        } = _ref3;
        var body = args[0];
        return {
          type: "vphantom",
          mode: parser.mode,
          body
        };
      },
      htmlBuilder: (group, options) => {
        var inner = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options.withPhantom())]);
        var fix = buildCommon.makeSpan(["fix"], []);
        return buildCommon.makeSpan(["mord", "rlap"], [inner, fix], options);
      },
      mathmlBuilder: (group, options) => {
        var inner = buildExpression(ordargument(group.body), options);
        var phantom = new mathMLTree.MathNode("mphantom", inner);
        var node = new mathMLTree.MathNode("mpadded", [phantom]);
        node.setAttribute("width", "0px");
        return node;
      }
    });
    defineFunction({
      type: "raisebox",
      names: ["\\raisebox"],
      props: {
        numArgs: 2,
        argTypes: ["size", "hbox"],
        allowedInText: true
      },
      handler(_ref, args) {
        var {
          parser
        } = _ref;
        var amount = assertNodeType(args[0], "size").value;
        var body = args[1];
        return {
          type: "raisebox",
          mode: parser.mode,
          dy: amount,
          body
        };
      },
      htmlBuilder(group, options) {
        var body = buildGroup$1(group.body, options);
        var dy = calculateSize(group.dy, options);
        return buildCommon.makeVList({
          positionType: "shift",
          positionData: -dy,
          children: [{
            type: "elem",
            elem: body
          }]
        }, options);
      },
      mathmlBuilder(group, options) {
        var node = new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options)]);
        var dy = group.dy.number + group.dy.unit;
        node.setAttribute("voffset", dy);
        return node;
      }
    });
    defineFunction({
      type: "internal",
      names: ["\\relax"],
      props: {
        numArgs: 0,
        allowedInText: true
      },
      handler(_ref) {
        var {
          parser
        } = _ref;
        return {
          type: "internal",
          mode: parser.mode
        };
      }
    });
    defineFunction({
      type: "rule",
      names: ["\\rule"],
      props: {
        numArgs: 2,
        numOptionalArgs: 1,
        argTypes: ["size", "size", "size"]
      },
      handler(_ref, args, optArgs) {
        var {
          parser
        } = _ref;
        var shift = optArgs[0];
        var width = assertNodeType(args[0], "size");
        var height = assertNodeType(args[1], "size");
        return {
          type: "rule",
          mode: parser.mode,
          shift: shift && assertNodeType(shift, "size").value,
          width: width.value,
          height: height.value
        };
      },
      htmlBuilder(group, options) {
        var rule = buildCommon.makeSpan(["mord", "rule"], [], options);
        var width = calculateSize(group.width, options);
        var height = calculateSize(group.height, options);
        var shift = group.shift ? calculateSize(group.shift, options) : 0;
        rule.style.borderRightWidth = makeEm(width);
        rule.style.borderTopWidth = makeEm(height);
        rule.style.bottom = makeEm(shift);
        rule.width = width;
        rule.height = height + shift;
        rule.depth = -shift;
        rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
        return rule;
      },
      mathmlBuilder(group, options) {
        var width = calculateSize(group.width, options);
        var height = calculateSize(group.height, options);
        var shift = group.shift ? calculateSize(group.shift, options) : 0;
        var color = options.color && options.getColor() || "black";
        var rule = new mathMLTree.MathNode("mspace");
        rule.setAttribute("mathbackground", color);
        rule.setAttribute("width", makeEm(width));
        rule.setAttribute("height", makeEm(height));
        var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
        if (shift >= 0) {
          wrapper.setAttribute("height", makeEm(shift));
        } else {
          wrapper.setAttribute("height", makeEm(shift));
          wrapper.setAttribute("depth", makeEm(-shift));
        }
        wrapper.setAttribute("voffset", makeEm(shift));
        return wrapper;
      }
    });
    function sizingGroup(value, options, baseOptions) {
      var inner = buildExpression$1(value, options, false);
      var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
      for (var i = 0; i < inner.length; i++) {
        var pos = inner[i].classes.indexOf("sizing");
        if (pos < 0) {
          Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));
        } else if (inner[i].classes[pos + 1] === "reset-size" + options.size) {
          inner[i].classes[pos + 1] = "reset-size" + baseOptions.size;
        }
        inner[i].height *= multiplier;
        inner[i].depth *= multiplier;
      }
      return buildCommon.makeFragment(inner);
    }
    var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
    var htmlBuilder = (group, options) => {
      var newOptions = options.havingSize(group.size);
      return sizingGroup(group.body, newOptions, options);
    };
    defineFunction({
      type: "sizing",
      names: sizeFuncs,
      props: {
        numArgs: 0,
        allowedInText: true
      },
      handler: (_ref, args) => {
        var {
          breakOnTokenText,
          funcName,
          parser
        } = _ref;
        var body = parser.parseExpression(false, breakOnTokenText);
        return {
          type: "sizing",
          mode: parser.mode,
          size: sizeFuncs.indexOf(funcName) + 1,
          body
        };
      },
      htmlBuilder,
      mathmlBuilder: (group, options) => {
        var newOptions = options.havingSize(group.size);
        var inner = buildExpression(group.body, newOptions);
        var node = new mathMLTree.MathNode("mstyle", inner);
        node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
        return node;
      }
    });
    defineFunction({
      type: "smash",
      names: ["\\smash"],
      props: {
        numArgs: 1,
        numOptionalArgs: 1,
        allowedInText: true
      },
      handler: (_ref, args, optArgs) => {
        var {
          parser
        } = _ref;
        var smashHeight = false;
        var smashDepth = false;
        var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
        if (tbArg) {
          var letter = "";
          for (var i = 0; i < tbArg.body.length; ++i) {
            var node = tbArg.body[i];
            letter = node.text;
            if (letter === "t") {
              smashHeight = true;
            } else if (letter === "b") {
              smashDepth = true;
            } else {
              smashHeight = false;
              smashDepth = false;
              break;
            }
          }
        } else {
          smashHeight = true;
          smashDepth = true;
        }
        var body = args[0];
        return {
          type: "smash",
          mode: parser.mode,
          body,
          smashHeight,
          smashDepth
        };
      },
      htmlBuilder: (group, options) => {
        var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
        if (!group.smashHeight && !group.smashDepth) {
          return node;
        }
        if (group.smashHeight) {
          node.height = 0;
          if (node.children) {
            for (var i = 0; i < node.children.length; i++) {
              node.children[i].height = 0;
            }
          }
        }
        if (group.smashDepth) {
          node.depth = 0;
          if (node.children) {
            for (var _i = 0; _i < node.children.length; _i++) {
              node.children[_i].depth = 0;
            }
          }
        }
        var smashedNode = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: node
          }]
        }, options);
        return buildCommon.makeSpan(["mord"], [smashedNode], options);
      },
      mathmlBuilder: (group, options) => {
        var node = new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options)]);
        if (group.smashHeight) {
          node.setAttribute("height", "0px");
        }
        if (group.smashDepth) {
          node.setAttribute("depth", "0px");
        }
        return node;
      }
    });
    defineFunction({
      type: "sqrt",
      names: ["\\sqrt"],
      props: {
        numArgs: 1,
        numOptionalArgs: 1
      },
      handler(_ref, args, optArgs) {
        var {
          parser
        } = _ref;
        var index = optArgs[0];
        var body = args[0];
        return {
          type: "sqrt",
          mode: parser.mode,
          body,
          index
        };
      },
      htmlBuilder(group, options) {
        var inner = buildGroup$1(group.body, options.havingCrampedStyle());
        if (inner.height === 0) {
          inner.height = options.fontMetrics().xHeight;
        }
        inner = buildCommon.wrapFragment(inner, options);
        var metrics = options.fontMetrics();
        var theta = metrics.defaultRuleThickness;
        var phi = theta;
        if (options.style.id < Style$1.TEXT.id) {
          phi = options.fontMetrics().xHeight;
        }
        var lineClearance = theta + phi / 4;
        var minDelimiterHeight = inner.height + inner.depth + lineClearance + theta;
        var {
          span: img,
          ruleWidth,
          advanceWidth
        } = delimiter.sqrtImage(minDelimiterHeight, options);
        var delimDepth = img.height - ruleWidth;
        if (delimDepth > inner.height + inner.depth + lineClearance) {
          lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;
        }
        var imgShift = img.height - inner.height - lineClearance - ruleWidth;
        inner.style.paddingLeft = makeEm(advanceWidth);
        var body = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: inner,
            wrapperClasses: ["svg-align"]
          }, {
            type: "kern",
            size: -(inner.height + imgShift)
          }, {
            type: "elem",
            elem: img
          }, {
            type: "kern",
            size: ruleWidth
          }]
        }, options);
        if (!group.index) {
          return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
        } else {
          var newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);
          var rootm = buildGroup$1(group.index, newOptions, options);
          var toShift = 0.6 * (body.height - body.depth);
          var rootVList = buildCommon.makeVList({
            positionType: "shift",
            positionData: -toShift,
            children: [{
              type: "elem",
              elem: rootm
            }]
          }, options);
          var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
          return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
        }
      },
      mathmlBuilder(group, options) {
        var {
          body,
          index
        } = group;
        return index ? new mathMLTree.MathNode("mroot", [buildGroup(body, options), buildGroup(index, options)]) : new mathMLTree.MathNode("msqrt", [buildGroup(body, options)]);
      }
    });
    var styleMap = {
      "display": Style$1.DISPLAY,
      "text": Style$1.TEXT,
      "script": Style$1.SCRIPT,
      "scriptscript": Style$1.SCRIPTSCRIPT
    };
    defineFunction({
      type: "styling",
      names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
      props: {
        numArgs: 0,
        allowedInText: true,
        primitive: true
      },
      handler(_ref, args) {
        var {
          breakOnTokenText,
          funcName,
          parser
        } = _ref;
        var body = parser.parseExpression(true, breakOnTokenText);
        var style = funcName.slice(1, funcName.length - 5);
        return {
          type: "styling",
          mode: parser.mode,
          style,
          body
        };
      },
      htmlBuilder(group, options) {
        var newStyle = styleMap[group.style];
        var newOptions = options.havingStyle(newStyle).withFont('');
        return sizingGroup(group.body, newOptions, options);
      },
      mathmlBuilder(group, options) {
        var newStyle = styleMap[group.style];
        var newOptions = options.havingStyle(newStyle);
        var inner = buildExpression(group.body, newOptions);
        var node = new mathMLTree.MathNode("mstyle", inner);
        var styleAttributes = {
          "display": ["0", "true"],
          "text": ["0", "false"],
          "script": ["1", "false"],
          "scriptscript": ["2", "false"]
        };
        var attr = styleAttributes[group.style];
        node.setAttribute("scriptlevel", attr[0]);
        node.setAttribute("displaystyle", attr[1]);
        return node;
      }
    });
    var htmlBuilderDelegate = function htmlBuilderDelegate(group, options) {
      var base = group.base;
      if (!base) {
        return null;
      } else if (base.type === "op") {
        var delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
        return delegate ? htmlBuilder$2 : null;
      } else if (base.type === "operatorname") {
        var _delegate = base.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base.limits);
        return _delegate ? htmlBuilder$1 : null;
      } else if (base.type === "accent") {
        return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;
      } else if (base.type === "horizBrace") {
        var isSup = !group.sub;
        return isSup === base.isOver ? htmlBuilder$3 : null;
      } else {
        return null;
      }
    };
    defineFunctionBuilders({
      type: "supsub",
      htmlBuilder(group, options) {
        var builderDelegate = htmlBuilderDelegate(group, options);
        if (builderDelegate) {
          return builderDelegate(group, options);
        }
        var {
          base: valueBase,
          sup: valueSup,
          sub: valueSub
        } = group;
        var base = buildGroup$1(valueBase, options);
        var supm;
        var subm;
        var metrics = options.fontMetrics();
        var supShift = 0;
        var subShift = 0;
        var isCharacterBox = valueBase && utils.isCharacterBox(valueBase);
        if (valueSup) {
          var newOptions = options.havingStyle(options.style.sup());
          supm = buildGroup$1(valueSup, newOptions, options);
          if (!isCharacterBox) {
            supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
          }
        }
        if (valueSub) {
          var _newOptions = options.havingStyle(options.style.sub());
          subm = buildGroup$1(valueSub, _newOptions, options);
          if (!isCharacterBox) {
            subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
          }
        }
        var minSupShift;
        if (options.style === Style$1.DISPLAY) {
          minSupShift = metrics.sup1;
        } else if (options.style.cramped) {
          minSupShift = metrics.sup3;
        } else {
          minSupShift = metrics.sup2;
        }
        var multiplier = options.sizeMultiplier;
        var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
        var marginLeft = null;
        if (subm) {
          var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
          if (base instanceof SymbolNode || isOiint) {
            marginLeft = makeEm(-base.italic);
          }
        }
        var supsub;
        if (supm && subm) {
          supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
          subShift = Math.max(subShift, metrics.sub2);
          var ruleWidth = metrics.defaultRuleThickness;
          var maxWidth = 4 * ruleWidth;
          if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
            subShift = maxWidth - (supShift - supm.depth) + subm.height;
            var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
            if (psi > 0) {
              supShift += psi;
              subShift -= psi;
            }
          }
          var vlistElem = [{
            type: "elem",
            elem: subm,
            shift: subShift,
            marginRight,
            marginLeft
          }, {
            type: "elem",
            elem: supm,
            shift: -supShift,
            marginRight
          }];
          supsub = buildCommon.makeVList({
            positionType: "individualShift",
            children: vlistElem
          }, options);
        } else if (subm) {
          subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
          var _vlistElem = [{
            type: "elem",
            elem: subm,
            marginLeft,
            marginRight
          }];
          supsub = buildCommon.makeVList({
            positionType: "shift",
            positionData: subShift,
            children: _vlistElem
          }, options);
        } else if (supm) {
          supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
          supsub = buildCommon.makeVList({
            positionType: "shift",
            positionData: -supShift,
            children: [{
              type: "elem",
              elem: supm,
              marginRight
            }]
          }, options);
        } else {
          throw new Error("supsub must have either sup or sub.");
        }
        var mclass = getTypeOfDomTree(base, "right") || "mord";
        return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
      },
      mathmlBuilder(group, options) {
        var isBrace = false;
        var isOver;
        var isSup;
        if (group.base && group.base.type === "horizBrace") {
          isSup = !!group.sup;
          if (isSup === group.base.isOver) {
            isBrace = true;
            isOver = group.base.isOver;
          }
        }
        if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
          group.base.parentIsSupSub = true;
        }
        var children = [buildGroup(group.base, options)];
        if (group.sub) {
          children.push(buildGroup(group.sub, options));
        }
        if (group.sup) {
          children.push(buildGroup(group.sup, options));
        }
        var nodeType;
        if (isBrace) {
          nodeType = isOver ? "mover" : "munder";
        } else if (!group.sub) {
          var base = group.base;
          if (base && base.type === "op" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
            nodeType = "mover";
          } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {
            nodeType = "mover";
          } else {
            nodeType = "msup";
          }
        } else if (!group.sup) {
          var _base = group.base;
          if (_base && _base.type === "op" && _base.limits && (options.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
            nodeType = "munder";
          } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === Style$1.DISPLAY)) {
            nodeType = "munder";
          } else {
            nodeType = "msub";
          }
        } else {
          var _base2 = group.base;
          if (_base2 && _base2.type === "op" && _base2.limits && options.style === Style$1.DISPLAY) {
            nodeType = "munderover";
          } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || _base2.limits)) {
            nodeType = "munderover";
          } else {
            nodeType = "msubsup";
          }
        }
        return new mathMLTree.MathNode(nodeType, children);
      }
    });
    defineFunctionBuilders({
      type: "atom",
      htmlBuilder(group, options) {
        return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
      },
      mathmlBuilder(group, options) {
        var node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
        if (group.family === "bin") {
          var variant = getVariant(group, options);
          if (variant === "bold-italic") {
            node.setAttribute("mathvariant", variant);
          }
        } else if (group.family === "punct") {
          node.setAttribute("separator", "true");
        } else if (group.family === "open" || group.family === "close") {
          node.setAttribute("stretchy", "false");
        }
        return node;
      }
    });
    var defaultVariant = {
      "mi": "italic",
      "mn": "normal",
      "mtext": "normal"
    };
    defineFunctionBuilders({
      type: "mathord",
      htmlBuilder(group, options) {
        return buildCommon.makeOrd(group, options, "mathord");
      },
      mathmlBuilder(group, options) {
        var node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
        var variant = getVariant(group, options) || "italic";
        if (variant !== defaultVariant[node.type]) {
          node.setAttribute("mathvariant", variant);
        }
        return node;
      }
    });
    defineFunctionBuilders({
      type: "textord",
      htmlBuilder(group, options) {
        return buildCommon.makeOrd(group, options, "textord");
      },
      mathmlBuilder(group, options) {
        var text = makeText(group.text, group.mode, options);
        var variant = getVariant(group, options) || "normal";
        var node;
        if (group.mode === 'text') {
          node = new mathMLTree.MathNode("mtext", [text]);
        } else if (/[0-9]/.test(group.text)) {
          node = new mathMLTree.MathNode("mn", [text]);
        } else if (group.text === "\\prime") {
          node = new mathMLTree.MathNode("mo", [text]);
        } else {
          node = new mathMLTree.MathNode("mi", [text]);
        }
        if (variant !== defaultVariant[node.type]) {
          node.setAttribute("mathvariant", variant);
        }
        return node;
      }
    });
    var cssSpace = {
      "\\nobreak": "nobreak",
      "\\allowbreak": "allowbreak"
    };
    var regularSpace = {
      " ": {},
      "\\ ": {},
      "~": {
        className: "nobreak"
      },
      "\\space": {},
      "\\nobreakspace": {
        className: "nobreak"
      }
    };
    defineFunctionBuilders({
      type: "spacing",
      htmlBuilder(group, options) {
        if (regularSpace.hasOwnProperty(group.text)) {
          var className = regularSpace[group.text].className || "";
          if (group.mode === "text") {
            var ord = buildCommon.makeOrd(group, options, "textord");
            ord.classes.push(className);
            return ord;
          } else {
            return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
          }
        } else if (cssSpace.hasOwnProperty(group.text)) {
          return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
        } else {
          throw new ParseError("Unknown type of space \"" + group.text + "\"");
        }
      },
      mathmlBuilder(group, options) {
        var node;
        if (regularSpace.hasOwnProperty(group.text)) {
          node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\u00a0")]);
        } else if (cssSpace.hasOwnProperty(group.text)) {
          return new mathMLTree.MathNode("mspace");
        } else {
          throw new ParseError("Unknown type of space \"" + group.text + "\"");
        }
        return node;
      }
    });
    var pad = () => {
      var padNode = new mathMLTree.MathNode("mtd", []);
      padNode.setAttribute("width", "50%");
      return padNode;
    };
    defineFunctionBuilders({
      type: "tag",
      mathmlBuilder(group, options) {
        var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
        table.setAttribute("width", "100%");
        return table;
      }
    });
    var textFontFamilies = {
      "\\text": undefined,
      "\\textrm": "textrm",
      "\\textsf": "textsf",
      "\\texttt": "texttt",
      "\\textnormal": "textrm"
    };
    var textFontWeights = {
      "\\textbf": "textbf",
      "\\textmd": "textmd"
    };
    var textFontShapes = {
      "\\textit": "textit",
      "\\textup": "textup"
    };
    var optionsWithFont = (group, options) => {
      var font = group.font;
      if (!font) {
        return options;
      } else if (textFontFamilies[font]) {
        return options.withTextFontFamily(textFontFamilies[font]);
      } else if (textFontWeights[font]) {
        return options.withTextFontWeight(textFontWeights[font]);
      } else {
        return options.withTextFontShape(textFontShapes[font]);
      }
    };
    defineFunction({
      type: "text",
      names: [
      "\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal",
      "\\textbf", "\\textmd",
      "\\textit", "\\textup"],
      props: {
        numArgs: 1,
        argTypes: ["text"],
        allowedInArgument: true,
        allowedInText: true
      },
      handler(_ref, args) {
        var {
          parser,
          funcName
        } = _ref;
        var body = args[0];
        return {
          type: "text",
          mode: parser.mode,
          body: ordargument(body),
          font: funcName
        };
      },
      htmlBuilder(group, options) {
        var newOptions = optionsWithFont(group, options);
        var inner = buildExpression$1(group.body, newOptions, true);
        return buildCommon.makeSpan(["mord", "text"], inner, newOptions);
      },
      mathmlBuilder(group, options) {
        var newOptions = optionsWithFont(group, options);
        return buildExpressionRow(group.body, newOptions);
      }
    });
    defineFunction({
      type: "underline",
      names: ["\\underline"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler(_ref, args) {
        var {
          parser
        } = _ref;
        return {
          type: "underline",
          mode: parser.mode,
          body: args[0]
        };
      },
      htmlBuilder(group, options) {
        var innerGroup = buildGroup$1(group.body, options);
        var line = buildCommon.makeLineSpan("underline-line", options);
        var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
        var vlist = buildCommon.makeVList({
          positionType: "top",
          positionData: innerGroup.height,
          children: [{
            type: "kern",
            size: defaultRuleThickness
          }, {
            type: "elem",
            elem: line
          }, {
            type: "kern",
            size: 3 * defaultRuleThickness
          }, {
            type: "elem",
            elem: innerGroup
          }]
        }, options);
        return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
      },
      mathmlBuilder(group, options) {
        var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203e")]);
        operator.setAttribute("stretchy", "true");
        var node = new mathMLTree.MathNode("munder", [buildGroup(group.body, options), operator]);
        node.setAttribute("accentunder", "true");
        return node;
      }
    });
    defineFunction({
      type: "vcenter",
      names: ["\\vcenter"],
      props: {
        numArgs: 1,
        argTypes: ["original"],
        allowedInText: false
      },
      handler(_ref, args) {
        var {
          parser
        } = _ref;
        return {
          type: "vcenter",
          mode: parser.mode,
          body: args[0]
        };
      },
      htmlBuilder(group, options) {
        var body = buildGroup$1(group.body, options);
        var axisHeight = options.fontMetrics().axisHeight;
        var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
        return buildCommon.makeVList({
          positionType: "shift",
          positionData: dy,
          children: [{
            type: "elem",
            elem: body
          }]
        }, options);
      },
      mathmlBuilder(group, options) {
        return new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options)], ["vcenter"]);
      }
    });
    defineFunction({
      type: "verb",
      names: ["\\verb"],
      props: {
        numArgs: 0,
        allowedInText: true
      },
      handler(context, args, optArgs) {
        throw new ParseError("\\verb ended by end of line instead of matching delimiter");
      },
      htmlBuilder(group, options) {
        var text = makeVerb(group);
        var body = [];
        var newOptions = options.havingStyle(options.style.text());
        for (var i = 0; i < text.length; i++) {
          var c = text[i];
          if (c === '~') {
            c = '\\textasciitilde';
          }
          body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
        }
        return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
      },
      mathmlBuilder(group, options) {
        var text = new mathMLTree.TextNode(makeVerb(group));
        var node = new mathMLTree.MathNode("mtext", [text]);
        node.setAttribute("mathvariant", "monospace");
        return node;
      }
    });
    var makeVerb = group => group.body.replace(/ /g, group.star ? '\u2423' : '\xA0');
    var functions = _functions;
    var spaceRegexString = "[ \r\n\t]";
    var controlWordRegexString = "\\\\[a-zA-Z@]+";
    var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
    var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
    var controlSpaceRegexString = "\\\\(\n|[ \r\t]+\n?)[ \r\t]*";
    var combiningDiacriticalMarkString = "[\u0300-\u036f]";
    var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
    var tokenRegexString = "(" + spaceRegexString + "+)|" + (
    controlSpaceRegexString + "|") +
    "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + (
    combiningDiacriticalMarkString + "*") +
    "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + (
    combiningDiacriticalMarkString + "*") +
    "|\\\\verb\\*([^]).*?\\4" +
    "|\\\\verb([^*a-zA-Z]).*?\\5" + (
    "|" + controlWordWhitespaceRegexString) + (
    "|" + controlSymbolRegexString + ")");
    class Lexer {
      constructor(input, settings) {
        this.input = void 0;
        this.settings = void 0;
        this.tokenRegex = void 0;
        this.catcodes = void 0;
        this.input = input;
        this.settings = settings;
        this.tokenRegex = new RegExp(tokenRegexString, 'g');
        this.catcodes = {
          "%": 14,
          "~": 13
        };
      }
      setCatcode(char, code) {
        this.catcodes[char] = code;
      }
      lex() {
        var input = this.input;
        var pos = this.tokenRegex.lastIndex;
        if (pos === input.length) {
          return new Token("EOF", new SourceLocation(this, pos, pos));
        }
        var match = this.tokenRegex.exec(input);
        if (match === null || match.index !== pos) {
          throw new ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
        }
        var text = match[6] || match[3] || (match[2] ? "\\ " : " ");
        if (this.catcodes[text] === 14) {
          var nlIndex = input.indexOf('\n', this.tokenRegex.lastIndex);
          if (nlIndex === -1) {
            this.tokenRegex.lastIndex = input.length;
            this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would " + "fail because of commenting the end of math mode (e.g. $)");
          } else {
            this.tokenRegex.lastIndex = nlIndex + 1;
          }
          return this.lex();
        }
        return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
      }
    }
    class Namespace {
      constructor(builtins, globalMacros) {
        if (builtins === void 0) {
          builtins = {};
        }
        if (globalMacros === void 0) {
          globalMacros = {};
        }
        this.current = void 0;
        this.builtins = void 0;
        this.undefStack = void 0;
        this.current = globalMacros;
        this.builtins = builtins;
        this.undefStack = [];
      }
      beginGroup() {
        this.undefStack.push({});
      }
      endGroup() {
        if (this.undefStack.length === 0) {
          throw new ParseError("Unbalanced namespace destruction: attempt " + "to pop global namespace; please report this as a bug");
        }
        var undefs = this.undefStack.pop();
        for (var undef in undefs) {
          if (undefs.hasOwnProperty(undef)) {
            if (undefs[undef] == null) {
              delete this.current[undef];
            } else {
              this.current[undef] = undefs[undef];
            }
          }
        }
      }
      endGroups() {
        while (this.undefStack.length > 0) {
          this.endGroup();
        }
      }
      has(name) {
        return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
      }
      get(name) {
        if (this.current.hasOwnProperty(name)) {
          return this.current[name];
        } else {
          return this.builtins[name];
        }
      }
      set(name, value, global) {
        if (global === void 0) {
          global = false;
        }
        if (global) {
          for (var i = 0; i < this.undefStack.length; i++) {
            delete this.undefStack[i][name];
          }
          if (this.undefStack.length > 0) {
            this.undefStack[this.undefStack.length - 1][name] = value;
          }
        } else {
          var top = this.undefStack[this.undefStack.length - 1];
          if (top && !top.hasOwnProperty(name)) {
            top[name] = this.current[name];
          }
        }
        if (value == null) {
          delete this.current[name];
        } else {
          this.current[name] = value;
        }
      }
    }
    var macros = _macros;
    defineMacro("\\noexpand", function (context) {
      var t = context.popToken();
      if (context.isExpandable(t.text)) {
        t.noexpand = true;
        t.treatAsRelax = true;
      }
      return {
        tokens: [t],
        numArgs: 0
      };
    });
    defineMacro("\\expandafter", function (context) {
      var t = context.popToken();
      context.expandOnce(true);
      return {
        tokens: [t],
        numArgs: 0
      };
    });
    defineMacro("\\@firstoftwo", function (context) {
      var args = context.consumeArgs(2);
      return {
        tokens: args[0],
        numArgs: 0
      };
    });
    defineMacro("\\@secondoftwo", function (context) {
      var args = context.consumeArgs(2);
      return {
        tokens: args[1],
        numArgs: 0
      };
    });
    defineMacro("\\@ifnextchar", function (context) {
      var args = context.consumeArgs(3);
      context.consumeSpaces();
      var nextToken = context.future();
      if (args[0].length === 1 && args[0][0].text === nextToken.text) {
        return {
          tokens: args[1],
          numArgs: 0
        };
      } else {
        return {
          tokens: args[2],
          numArgs: 0
        };
      }
    });
    defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
    defineMacro("\\TextOrMath", function (context) {
      var args = context.consumeArgs(2);
      if (context.mode === 'text') {
        return {
          tokens: args[0],
          numArgs: 0
        };
      } else {
        return {
          tokens: args[1],
          numArgs: 0
        };
      }
    });
    var digitToNumber = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      "a": 10,
      "A": 10,
      "b": 11,
      "B": 11,
      "c": 12,
      "C": 12,
      "d": 13,
      "D": 13,
      "e": 14,
      "E": 14,
      "f": 15,
      "F": 15
    };
    defineMacro("\\char", function (context) {
      var token = context.popToken();
      var base;
      var number = '';
      if (token.text === "'") {
        base = 8;
        token = context.popToken();
      } else if (token.text === '"') {
        base = 16;
        token = context.popToken();
      } else if (token.text === "`") {
        token = context.popToken();
        if (token.text[0] === "\\") {
          number = token.text.charCodeAt(1);
        } else if (token.text === "EOF") {
          throw new ParseError("\\char` missing argument");
        } else {
          number = token.text.charCodeAt(0);
        }
      } else {
        base = 10;
      }
      if (base) {
        number = digitToNumber[token.text];
        if (number == null || number >= base) {
          throw new ParseError("Invalid base-" + base + " digit " + token.text);
        }
        var digit;
        while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
          number *= base;
          number += digit;
          context.popToken();
        }
      }
      return "\\@char{" + number + "}";
    });
    var newcommand = (context, existsOK, nonexistsOK) => {
      var arg = context.consumeArg().tokens;
      if (arg.length !== 1) {
        throw new ParseError("\\newcommand's first argument must be a macro name");
      }
      var name = arg[0].text;
      var exists = context.isDefined(name);
      if (exists && !existsOK) {
        throw new ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
      }
      if (!exists && !nonexistsOK) {
        throw new ParseError("\\renewcommand{" + name + "} when command " + name + " " + "does not yet exist; use \\newcommand");
      }
      var numArgs = 0;
      arg = context.consumeArg().tokens;
      if (arg.length === 1 && arg[0].text === "[") {
        var argText = '';
        var token = context.expandNextToken();
        while (token.text !== "]" && token.text !== "EOF") {
          argText += token.text;
          token = context.expandNextToken();
        }
        if (!argText.match(/^\s*[0-9]+\s*$/)) {
          throw new ParseError("Invalid number of arguments: " + argText);
        }
        numArgs = parseInt(argText);
        arg = context.consumeArg().tokens;
      }
      context.macros.set(name, {
        tokens: arg,
        numArgs
      });
      return '';
    };
    defineMacro("\\newcommand", context => newcommand(context, false, true));
    defineMacro("\\renewcommand", context => newcommand(context, true, false));
    defineMacro("\\providecommand", context => newcommand(context, true, true));
    defineMacro("\\message", context => {
      var arg = context.consumeArgs(1)[0];
      console.log(arg.reverse().map(token => token.text).join(""));
      return '';
    });
    defineMacro("\\errmessage", context => {
      var arg = context.consumeArgs(1)[0];
      console.error(arg.reverse().map(token => token.text).join(""));
      return '';
    });
    defineMacro("\\show", context => {
      var tok = context.popToken();
      var name = tok.text;
      console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);
      return '';
    });
    defineMacro("\\bgroup", "{");
    defineMacro("\\egroup", "}");
    defineMacro("~", "\\nobreakspace");
    defineMacro("\\lq", "`");
    defineMacro("\\rq", "'");
    defineMacro("\\aa", "\\r a");
    defineMacro("\\AA", "\\r A");
    defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`}");
    defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
    defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}");
    defineMacro("\u212C", "\\mathscr{B}");
    defineMacro("\u2130", "\\mathscr{E}");
    defineMacro("\u2131", "\\mathscr{F}");
    defineMacro("\u210B", "\\mathscr{H}");
    defineMacro("\u2110", "\\mathscr{I}");
    defineMacro("\u2112", "\\mathscr{L}");
    defineMacro("\u2133", "\\mathscr{M}");
    defineMacro("\u211B", "\\mathscr{R}");
    defineMacro("\u212D", "\\mathfrak{C}");
    defineMacro("\u210C", "\\mathfrak{H}");
    defineMacro("\u2128", "\\mathfrak{Z}");
    defineMacro("\\Bbbk", "\\Bbb{k}");
    defineMacro("\u00b7", "\\cdotp");
    defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
    defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
    defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
    defineMacro("\\mathstrut", "\\vphantom{(}");
    defineMacro("\\underbar", "\\underline{\\text{#1}}");
    defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
    defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");
    defineMacro("\\ne", "\\neq");
    defineMacro("\u2260", "\\neq");
    defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}" + "{\\mathrel{\\char`}}");
    defineMacro("\u2209", "\\notin");
    defineMacro("\u2258", "\\html@mathml{" + "\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}" + "}{\\mathrel{\\char`\u2258}}");
    defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
    defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
    defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}" + "{\\mathrel{\\char`\u225B}}");
    defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}" + "{\\mathrel{\\char`\u225D}}");
    defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}" + "{\\mathrel{\\char`\u225E}}");
    defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
    defineMacro("\u27C2", "\\perp");
    defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
    defineMacro("\u220C", "\\notni");
    defineMacro("\u231C", "\\ulcorner");
    defineMacro("\u231D", "\\urcorner");
    defineMacro("\u231E", "\\llcorner");
    defineMacro("\u231F", "\\lrcorner");
    defineMacro("\u00A9", "\\copyright");
    defineMacro("\u00AE", "\\textregistered");
    defineMacro("\uFE0F", "\\textregistered");
    defineMacro("\\ulcorner", "\\html@mathml{\\@ulcorner}{\\mathop{\\char\"231c}}");
    defineMacro("\\urcorner", "\\html@mathml{\\@urcorner}{\\mathop{\\char\"231d}}");
    defineMacro("\\llcorner", "\\html@mathml{\\@llcorner}{\\mathop{\\char\"231e}}");
    defineMacro("\\lrcorner", "\\html@mathml{\\@lrcorner}{\\mathop{\\char\"231f}}");
    defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
    defineMacro("\u22ee", "\\vdots");
    defineMacro("\\varGamma", "\\mathit{\\Gamma}");
    defineMacro("\\varDelta", "\\mathit{\\Delta}");
    defineMacro("\\varTheta", "\\mathit{\\Theta}");
    defineMacro("\\varLambda", "\\mathit{\\Lambda}");
    defineMacro("\\varXi", "\\mathit{\\Xi}");
    defineMacro("\\varPi", "\\mathit{\\Pi}");
    defineMacro("\\varSigma", "\\mathit{\\Sigma}");
    defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
    defineMacro("\\varPhi", "\\mathit{\\Phi}");
    defineMacro("\\varPsi", "\\mathit{\\Psi}");
    defineMacro("\\varOmega", "\\mathit{\\Omega}");
    defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
    defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}" + "\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
    defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
    defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
    defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
    defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
    var dotsByToken = {
      ',': '\\dotsc',
      '\\not': '\\dotsb',
      '+': '\\dotsb',
      '=': '\\dotsb',
      '<': '\\dotsb',
      '>': '\\dotsb',
      '-': '\\dotsb',
      '*': '\\dotsb',
      ':': '\\dotsb',
      '\\DOTSB': '\\dotsb',
      '\\coprod': '\\dotsb',
      '\\bigvee': '\\dotsb',
      '\\bigwedge': '\\dotsb',
      '\\biguplus': '\\dotsb',
      '\\bigcap': '\\dotsb',
      '\\bigcup': '\\dotsb',
      '\\prod': '\\dotsb',
      '\\sum': '\\dotsb',
      '\\bigotimes': '\\dotsb',
      '\\bigoplus': '\\dotsb',
      '\\bigodot': '\\dotsb',
      '\\bigsqcup': '\\dotsb',
      '\\And': '\\dotsb',
      '\\longrightarrow': '\\dotsb',
      '\\Longrightarrow': '\\dotsb',
      '\\longleftarrow': '\\dotsb',
      '\\Longleftarrow': '\\dotsb',
      '\\longleftrightarrow': '\\dotsb',
      '\\Longleftrightarrow': '\\dotsb',
      '\\mapsto': '\\dotsb',
      '\\longmapsto': '\\dotsb',
      '\\hookrightarrow': '\\dotsb',
      '\\doteq': '\\dotsb',
      '\\mathbin': '\\dotsb',
      '\\mathrel': '\\dotsb',
      '\\relbar': '\\dotsb',
      '\\Relbar': '\\dotsb',
      '\\xrightarrow': '\\dotsb',
      '\\xleftarrow': '\\dotsb',
      '\\DOTSI': '\\dotsi',
      '\\int': '\\dotsi',
      '\\oint': '\\dotsi',
      '\\iint': '\\dotsi',
      '\\iiint': '\\dotsi',
      '\\iiiint': '\\dotsi',
      '\\idotsint': '\\dotsi',
      '\\DOTSX': '\\dotsx'
    };
    defineMacro("\\dots", function (context) {
      var thedots = '\\dotso';
      var next = context.expandAfterFuture().text;
      if (next in dotsByToken) {
        thedots = dotsByToken[next];
      } else if (next.slice(0, 4) === '\\not') {
        thedots = '\\dotsb';
      } else if (next in symbols.math) {
        if (utils.contains(['bin', 'rel'], symbols.math[next].group)) {
          thedots = '\\dotsb';
        }
      }
      return thedots;
    });
    var spaceAfterDots = {
      ')': true,
      ']': true,
      '\\rbrack': true,
      '\\}': true,
      '\\rbrace': true,
      '\\rangle': true,
      '\\rceil': true,
      '\\rfloor': true,
      '\\rgroup': true,
      '\\rmoustache': true,
      '\\right': true,
      '\\bigr': true,
      '\\biggr': true,
      '\\Bigr': true,
      '\\Biggr': true,
      '$': true,
      ';': true,
      '.': true,
      ',': true
    };
    defineMacro("\\dotso", function (context) {
      var next = context.future().text;
      if (next in spaceAfterDots) {
        return "\\ldots\\,";
      } else {
        return "\\ldots";
      }
    });
    defineMacro("\\dotsc", function (context) {
      var next = context.future().text;
      if (next in spaceAfterDots && next !== ',') {
        return "\\ldots\\,";
      } else {
        return "\\ldots";
      }
    });
    defineMacro("\\cdots", function (context) {
      var next = context.future().text;
      if (next in spaceAfterDots) {
        return "\\@cdots\\,";
      } else {
        return "\\@cdots";
      }
    });
    defineMacro("\\dotsb", "\\cdots");
    defineMacro("\\dotsm", "\\cdots");
    defineMacro("\\dotsi", "\\!\\cdots");
    defineMacro("\\dotsx", "\\ldots\\,");
    defineMacro("\\DOTSI", "\\relax");
    defineMacro("\\DOTSB", "\\relax");
    defineMacro("\\DOTSX", "\\relax");
    defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
    defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
    defineMacro("\\thinspace", "\\,");
    defineMacro("\\>", "\\mskip{4mu}");
    defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
    defineMacro("\\medspace", "\\:");
    defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
    defineMacro("\\thickspace", "\\;");
    defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
    defineMacro("\\negthinspace", "\\!");
    defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
    defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
    defineMacro("\\enspace", "\\kern.5em ");
    defineMacro("\\enskip", "\\hskip.5em\\relax");
    defineMacro("\\quad", "\\hskip1em\\relax");
    defineMacro("\\qquad", "\\hskip2em\\relax");
    defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
    defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
    defineMacro("\\tag@literal", context => {
      if (context.macros.get("\\df@tag")) {
        throw new ParseError("Multiple \\tag");
      }
      return "\\gdef\\df@tag{\\text{#1}}";
    });
    defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}" + "\\mathbin{\\rm mod}" + "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
    defineMacro("\\pod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
    defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
    defineMacro("\\mod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}" + "{\\rm mod}\\,\\,#1");
    defineMacro("\\newline", "\\\\\\relax");
    defineMacro("\\TeX", "\\textrm{\\html@mathml{" + "T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX" + "}{TeX}}");
    var latexRaiseA = makeEm(fontMetricsData['Main-Regular']["T".charCodeAt(0)][1] - 0.7 * fontMetricsData['Main-Regular']["A".charCodeAt(0)][1]);
    defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
    defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
    defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
    defineMacro("\\@hspace", "\\hskip #1\\relax");
    defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
    defineMacro("\\ordinarycolon", ":");
    defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
    defineMacro("\\dblcolon", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}" + "{\\mathop{\\char\"2237}}");
    defineMacro("\\coloneqq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}" + "{\\mathop{\\char\"2254}}");
    defineMacro("\\Coloneqq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}" + "{\\mathop{\\char\"2237\\char\"3d}}");
    defineMacro("\\coloneq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + "{\\mathop{\\char\"3a\\char\"2212}}");
    defineMacro("\\Coloneq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + "{\\mathop{\\char\"2237\\char\"2212}}");
    defineMacro("\\eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + "{\\mathop{\\char\"2255}}");
    defineMacro("\\Eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + "{\\mathop{\\char\"3d\\char\"2237}}");
    defineMacro("\\eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + "{\\mathop{\\char\"2239}}");
    defineMacro("\\Eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + "{\\mathop{\\char\"2212\\char\"2237}}");
    defineMacro("\\colonapprox", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + "{\\mathop{\\char\"3a\\char\"2248}}");
    defineMacro("\\Colonapprox", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + "{\\mathop{\\char\"2237\\char\"2248}}");
    defineMacro("\\colonsim", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + "{\\mathop{\\char\"3a\\char\"223c}}");
    defineMacro("\\Colonsim", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + "{\\mathop{\\char\"2237\\char\"223c}}");
    defineMacro("\u2237", "\\dblcolon");
    defineMacro("\u2239", "\\eqcolon");
    defineMacro("\u2254", "\\coloneqq");
    defineMacro("\u2255", "\\eqqcolon");
    defineMacro("\u2A74", "\\Coloneqq");
    defineMacro("\\ratio", "\\vcentcolon");
    defineMacro("\\coloncolon", "\\dblcolon");
    defineMacro("\\colonequals", "\\coloneqq");
    defineMacro("\\coloncolonequals", "\\Coloneqq");
    defineMacro("\\equalscolon", "\\eqqcolon");
    defineMacro("\\equalscoloncolon", "\\Eqqcolon");
    defineMacro("\\colonminus", "\\coloneq");
    defineMacro("\\coloncolonminus", "\\Coloneq");
    defineMacro("\\minuscolon", "\\eqcolon");
    defineMacro("\\minuscoloncolon", "\\Eqcolon");
    defineMacro("\\coloncolonapprox", "\\Colonapprox");
    defineMacro("\\coloncolonsim", "\\Colonsim");
    defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
    defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
    defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
    defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
    defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
    defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
    defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
    defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
    defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
    defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
    defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
    defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
    defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
    defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
    defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
    defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
    defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
    defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
    defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
    defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{}");
    defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{}");
    defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
    defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
    defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{}");
    defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{}");
    defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{}");
    defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{}");
    defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
    defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
    defineMacro("\\llbracket", "\\html@mathml{" + "\\mathopen{[\\mkern-3.2mu[}}" + "{\\mathopen{\\char`\u27e6}}");
    defineMacro("\\rrbracket", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu]}}" + "{\\mathclose{\\char`\u27e7}}");
    defineMacro("\u27e6", "\\llbracket");
    defineMacro("\u27e7", "\\rrbracket");
    defineMacro("\\lBrace", "\\html@mathml{" + "\\mathopen{\\{\\mkern-3.2mu[}}" + "{\\mathopen{\\char`\u2983}}");
    defineMacro("\\rBrace", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu\\}}}" + "{\\mathclose{\\char`\u2984}}");
    defineMacro("\u2983", "\\lBrace");
    defineMacro("\u2984", "\\rBrace");
    defineMacro("\\minuso", "\\mathbin{\\html@mathml{" + "{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}" + "{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}" + "{\\char`}}");
    defineMacro("", "\\minuso");
    defineMacro("\\darr", "\\downarrow");
    defineMacro("\\dArr", "\\Downarrow");
    defineMacro("\\Darr", "\\Downarrow");
    defineMacro("\\lang", "\\langle");
    defineMacro("\\rang", "\\rangle");
    defineMacro("\\uarr", "\\uparrow");
    defineMacro("\\uArr", "\\Uparrow");
    defineMacro("\\Uarr", "\\Uparrow");
    defineMacro("\\N", "\\mathbb{N}");
    defineMacro("\\R", "\\mathbb{R}");
    defineMacro("\\Z", "\\mathbb{Z}");
    defineMacro("\\alef", "\\aleph");
    defineMacro("\\alefsym", "\\aleph");
    defineMacro("\\Alpha", "\\mathrm{A}");
    defineMacro("\\Beta", "\\mathrm{B}");
    defineMacro("\\bull", "\\bullet");
    defineMacro("\\Chi", "\\mathrm{X}");
    defineMacro("\\clubs", "\\clubsuit");
    defineMacro("\\cnums", "\\mathbb{C}");
    defineMacro("\\Complex", "\\mathbb{C}");
    defineMacro("\\Dagger", "\\ddagger");
    defineMacro("\\diamonds", "\\diamondsuit");
    defineMacro("\\empty", "\\emptyset");
    defineMacro("\\Epsilon", "\\mathrm{E}");
    defineMacro("\\Eta", "\\mathrm{H}");
    defineMacro("\\exist", "\\exists");
    defineMacro("\\harr", "\\leftrightarrow");
    defineMacro("\\hArr", "\\Leftrightarrow");
    defineMacro("\\Harr", "\\Leftrightarrow");
    defineMacro("\\hearts", "\\heartsuit");
    defineMacro("\\image", "\\Im");
    defineMacro("\\infin", "\\infty");
    defineMacro("\\Iota", "\\mathrm{I}");
    defineMacro("\\isin", "\\in");
    defineMacro("\\Kappa", "\\mathrm{K}");
    defineMacro("\\larr", "\\leftarrow");
    defineMacro("\\lArr", "\\Leftarrow");
    defineMacro("\\Larr", "\\Leftarrow");
    defineMacro("\\lrarr", "\\leftrightarrow");
    defineMacro("\\lrArr", "\\Leftrightarrow");
    defineMacro("\\Lrarr", "\\Leftrightarrow");
    defineMacro("\\Mu", "\\mathrm{M}");
    defineMacro("\\natnums", "\\mathbb{N}");
    defineMacro("\\Nu", "\\mathrm{N}");
    defineMacro("\\Omicron", "\\mathrm{O}");
    defineMacro("\\plusmn", "\\pm");
    defineMacro("\\rarr", "\\rightarrow");
    defineMacro("\\rArr", "\\Rightarrow");
    defineMacro("\\Rarr", "\\Rightarrow");
    defineMacro("\\real", "\\Re");
    defineMacro("\\reals", "\\mathbb{R}");
    defineMacro("\\Reals", "\\mathbb{R}");
    defineMacro("\\Rho", "\\mathrm{P}");
    defineMacro("\\sdot", "\\cdot");
    defineMacro("\\sect", "\\S");
    defineMacro("\\spades", "\\spadesuit");
    defineMacro("\\sub", "\\subset");
    defineMacro("\\sube", "\\subseteq");
    defineMacro("\\supe", "\\supseteq");
    defineMacro("\\Tau", "\\mathrm{T}");
    defineMacro("\\thetasym", "\\vartheta");
    defineMacro("\\weierp", "\\wp");
    defineMacro("\\Zeta", "\\mathrm{Z}");
    defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
    defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
    defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
    defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
    defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
    defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
    defineMacro("\\Bra", "\\left\\langle#1\\right|");
    defineMacro("\\Ket", "\\left|#1\\right\\rangle");
    var braketHelper = one => context => {
      var left = context.consumeArg().tokens;
      var middle = context.consumeArg().tokens;
      var middleDouble = context.consumeArg().tokens;
      var right = context.consumeArg().tokens;
      var oldMiddle = context.macros.get("|");
      var oldMiddleDouble = context.macros.get("\\|");
      context.macros.beginGroup();
      var midMacro = double => context => {
        if (one) {
          context.macros.set("|", oldMiddle);
          if (middleDouble.length) {
            context.macros.set("\\|", oldMiddleDouble);
          }
        }
        var doubled = double;
        if (!double && middleDouble.length) {
          var nextToken = context.future();
          if (nextToken.text === "|") {
            context.popToken();
            doubled = true;
          }
        }
        return {
          tokens: doubled ? middleDouble : middle,
          numArgs: 0
        };
      };
      context.macros.set("|", midMacro(false));
      if (middleDouble.length) {
        context.macros.set("\\|", midMacro(true));
      }
      var arg = context.consumeArg().tokens;
      var expanded = context.expandTokens([...right, ...arg, ...left
      ]);
      context.macros.endGroup();
      return {
        tokens: expanded.reverse(),
        numArgs: 0
      };
    };
    defineMacro("\\bra@ket", braketHelper(false));
    defineMacro("\\bra@set", braketHelper(true));
    defineMacro("\\Braket", "\\bra@ket{\\left\\langle}" + "{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
    defineMacro("\\Set", "\\bra@set{\\left\\{\\:}" + "{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
    defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
    defineMacro("\\angln", "{\\angl n}");
    defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
    defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
    defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
    defineMacro("\\red", "\\textcolor{##df0030}{#1}");
    defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
    defineMacro("\\gray", "\\textcolor{gray}{#1}");
    defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
    defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
    defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
    defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
    defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
    defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
    defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
    defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
    defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
    defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
    defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
    defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
    defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
    defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
    defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
    defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
    defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
    defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
    defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
    defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
    defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
    defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
    defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
    defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
    defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
    defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
    defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
    defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
    defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
    defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
    defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
    defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
    defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
    defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
    defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
    defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
    defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
    defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
    defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
    defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
    defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
    defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
    defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
    defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
    defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
    defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
    defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
    defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
    defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
    defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
    var implicitCommands = {
      "^": true,
      "_": true,
      "\\limits": true,
      "\\nolimits": true
    };
    class MacroExpander {
      constructor(input, settings, mode) {
        this.settings = void 0;
        this.expansionCount = void 0;
        this.lexer = void 0;
        this.macros = void 0;
        this.stack = void 0;
        this.mode = void 0;
        this.settings = settings;
        this.expansionCount = 0;
        this.feed(input);
        this.macros = new Namespace(macros, settings.macros);
        this.mode = mode;
        this.stack = [];
      }
      feed(input) {
        this.lexer = new Lexer(input, this.settings);
      }
      switchMode(newMode) {
        this.mode = newMode;
      }
      beginGroup() {
        this.macros.beginGroup();
      }
      endGroup() {
        this.macros.endGroup();
      }
      endGroups() {
        this.macros.endGroups();
      }
      future() {
        if (this.stack.length === 0) {
          this.pushToken(this.lexer.lex());
        }
        return this.stack[this.stack.length - 1];
      }
      popToken() {
        this.future();
        return this.stack.pop();
      }
      pushToken(token) {
        this.stack.push(token);
      }
      pushTokens(tokens) {
        this.stack.push(...tokens);
      }
      scanArgument(isOptional) {
        var start;
        var end;
        var tokens;
        if (isOptional) {
          this.consumeSpaces();
          if (this.future().text !== "[") {
            return null;
          }
          start = this.popToken();
          ({
            tokens,
            end
          } = this.consumeArg(["]"]));
        } else {
          ({
            tokens,
            start,
            end
          } = this.consumeArg());
        }
        this.pushToken(new Token("EOF", end.loc));
        this.pushTokens(tokens);
        return start.range(end, "");
      }
      consumeSpaces() {
        for (;;) {
          var token = this.future();
          if (token.text === " ") {
            this.stack.pop();
          } else {
            break;
          }
        }
      }
      consumeArg(delims) {
        var tokens = [];
        var isDelimited = delims && delims.length > 0;
        if (!isDelimited) {
          this.consumeSpaces();
        }
        var start = this.future();
        var tok;
        var depth = 0;
        var match = 0;
        do {
          tok = this.popToken();
          tokens.push(tok);
          if (tok.text === "{") {
            ++depth;
          } else if (tok.text === "}") {
            --depth;
            if (depth === -1) {
              throw new ParseError("Extra }", tok);
            }
          } else if (tok.text === "EOF") {
            throw new ParseError("Unexpected end of input in a macro argument" + ", expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
          }
          if (delims && isDelimited) {
            if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
              ++match;
              if (match === delims.length) {
                tokens.splice(-match, match);
                break;
              }
            } else {
              match = 0;
            }
          }
        } while (depth !== 0 || isDelimited);
        if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
          tokens.pop();
          tokens.shift();
        }
        tokens.reverse();
        return {
          tokens,
          start,
          end: tok
        };
      }
      consumeArgs(numArgs, delimiters) {
        if (delimiters) {
          if (delimiters.length !== numArgs + 1) {
            throw new ParseError("The length of delimiters doesn't match the number of args!");
          }
          var delims = delimiters[0];
          for (var i = 0; i < delims.length; i++) {
            var tok = this.popToken();
            if (delims[i] !== tok.text) {
              throw new ParseError("Use of the macro doesn't match its definition", tok);
            }
          }
        }
        var args = [];
        for (var _i = 0; _i < numArgs; _i++) {
          args.push(this.consumeArg(delimiters && delimiters[_i + 1]).tokens);
        }
        return args;
      }
      expandOnce(expandableOnly) {
        var topToken = this.popToken();
        var name = topToken.text;
        var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
        if (expansion == null || expandableOnly && expansion.unexpandable) {
          if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
            throw new ParseError("Undefined control sequence: " + name);
          }
          this.pushToken(topToken);
          return topToken;
        }
        this.expansionCount++;
        if (this.expansionCount > this.settings.maxExpand) {
          throw new ParseError("Too many expansions: infinite loop or " + "need to increase maxExpand setting");
        }
        var tokens = expansion.tokens;
        var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
        if (expansion.numArgs) {
          tokens = tokens.slice();
          for (var i = tokens.length - 1; i >= 0; --i) {
            var tok = tokens[i];
            if (tok.text === "#") {
              if (i === 0) {
                throw new ParseError("Incomplete placeholder at end of macro body", tok);
              }
              tok = tokens[--i];
              if (tok.text === "#") {
                tokens.splice(i + 1, 1);
              } else if (/^[1-9]$/.test(tok.text)) {
                tokens.splice(i, 2, ...args[+tok.text - 1]);
              } else {
                throw new ParseError("Not a valid argument number", tok);
              }
            }
          }
        }
        this.pushTokens(tokens);
        return tokens;
      }
      expandAfterFuture() {
        this.expandOnce();
        return this.future();
      }
      expandNextToken() {
        for (;;) {
          var expanded = this.expandOnce();
          if (expanded instanceof Token) {
            if (expanded.treatAsRelax) {
              expanded.text = "\\relax";
            }
            return this.stack.pop();
          }
        }
        throw new Error();
      }
      expandMacro(name) {
        return this.macros.has(name) ? this.expandTokens([new Token(name)]) : undefined;
      }
      expandTokens(tokens) {
        var output = [];
        var oldStackLength = this.stack.length;
        this.pushTokens(tokens);
        while (this.stack.length > oldStackLength) {
          var expanded = this.expandOnce(true);
          if (expanded instanceof Token) {
            if (expanded.treatAsRelax) {
              expanded.noexpand = false;
              expanded.treatAsRelax = false;
            }
            output.push(this.stack.pop());
          }
        }
        return output;
      }
      expandMacroAsText(name) {
        var tokens = this.expandMacro(name);
        if (tokens) {
          return tokens.map(token => token.text).join("");
        } else {
          return tokens;
        }
      }
      _getExpansion(name) {
        var definition = this.macros.get(name);
        if (definition == null) {
          return definition;
        }
        if (name.length === 1) {
          var catcode = this.lexer.catcodes[name];
          if (catcode != null && catcode !== 13) {
            return;
          }
        }
        var expansion = typeof definition === "function" ? definition(this) : definition;
        if (typeof expansion === "string") {
          var numArgs = 0;
          if (expansion.indexOf("#") !== -1) {
            var stripped = expansion.replace(/##/g, "");
            while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
              ++numArgs;
            }
          }
          var bodyLexer = new Lexer(expansion, this.settings);
          var tokens = [];
          var tok = bodyLexer.lex();
          while (tok.text !== "EOF") {
            tokens.push(tok);
            tok = bodyLexer.lex();
          }
          tokens.reverse();
          var expanded = {
            tokens,
            numArgs
          };
          return expanded;
        }
        return expansion;
      }
      isDefined(name) {
        return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
      }
      isExpandable(name) {
        var macro = this.macros.get(name);
        return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;
      }
    }
    var unicodeSubRegEx = /^[]/;
    var uSubsAndSups = Object.freeze({
      '': '+',
      '': '-',
      '': '=',
      '': '(',
      '': ')',
      '': '0',
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '\u2090': 'a',
      '\u2091': 'e',
      '\u2095': 'h',
      '\u1D62': 'i',
      '\u2C7C': 'j',
      '\u2096': 'k',
      '\u2097': 'l',
      '\u2098': 'm',
      '\u2099': 'n',
      '\u2092': 'o',
      '\u209A': 'p',
      '\u1D63': 'r',
      '\u209B': 's',
      '\u209C': 't',
      '\u1D64': 'u',
      '\u1D65': 'v',
      '\u2093': 'x',
      '\u1D66': '',
      '\u1D67': '',
      '\u1D68': '',
      '\u1D69': '\u03d5',
      '\u1D6A': '',
      '': '+',
      '': '-',
      '': '=',
      '': '(',
      '': ')',
      '': '0',
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '\u1D2C': 'A',
      '\u1D2E': 'B',
      '\u1D30': 'D',
      '\u1D31': 'E',
      '\u1D33': 'G',
      '\u1D34': 'H',
      '\u1D35': 'I',
      '\u1D36': 'J',
      '\u1D37': 'K',
      '\u1D38': 'L',
      '\u1D39': 'M',
      '\u1D3A': 'N',
      '\u1D3C': 'O',
      '\u1D3E': 'P',
      '\u1D3F': 'R',
      '\u1D40': 'T',
      '\u1D41': 'U',
      '\u2C7D': 'V',
      '\u1D42': 'W',
      '\u1D43': 'a',
      '\u1D47': 'b',
      '\u1D9C': 'c',
      '\u1D48': 'd',
      '\u1D49': 'e',
      '\u1DA0': 'f',
      '\u1D4D': 'g',
      '\u02B0': 'h',
      '\u2071': 'i',
      '\u02B2': 'j',
      '\u1D4F': 'k',
      '\u02E1': 'l',
      '\u1D50': 'm',
      '\u207F': 'n',
      '\u1D52': 'o',
      '\u1D56': 'p',
      '\u02B3': 'r',
      '\u02E2': 's',
      '\u1D57': 't',
      '\u1D58': 'u',
      '\u1D5B': 'v',
      '\u02B7': 'w',
      '\u02E3': 'x',
      '\u02B8': 'y',
      '\u1DBB': 'z',
      '\u1D5D': '',
      '\u1D5E': '',
      '\u1D5F': '',
      '\u1D60': '\u03d5',
      '\u1D61': '',
      '\u1DBF': ''
    });
    var unicodeAccents = {
      "": {
        "text": "\\'",
        "math": "\\acute"
      },
      "": {
        "text": "\\`",
        "math": "\\grave"
      },
      "": {
        "text": "\\\"",
        "math": "\\ddot"
      },
      "": {
        "text": "\\~",
        "math": "\\tilde"
      },
      "": {
        "text": "\\=",
        "math": "\\bar"
      },
      "": {
        "text": "\\u",
        "math": "\\breve"
      },
      "": {
        "text": "\\v",
        "math": "\\check"
      },
      "": {
        "text": "\\^",
        "math": "\\hat"
      },
      "": {
        "text": "\\.",
        "math": "\\dot"
      },
      "": {
        "text": "\\r",
        "math": "\\mathring"
      },
      "": {
        "text": "\\H"
      },
      "": {
        "text": "\\c"
      }
    };
    var unicodeSymbols = {
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "b",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "d",
      "": "d",
      "": "d",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "f",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "h",
      "": "h",
      "": "h",
      "": "h",
      "": "h",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "j",
      "": "j",
      "": "k",
      "": "k",
      "": "k",
      "": "l",
      "": "l",
      "": "l",
      "": "m",
      "": "m",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "p",
      "": "p",
      "": "r",
      "": "r",
      "": "r",
      "": "r",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "t",
      "": "t",
      "": "t",
      "": "t",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "v",
      "": "w",
      "": "w",
      "": "w",
      "": "w",
      "": "w",
      "": "w",
      "": "x",
      "": "x",
      "": "y",
      "": "y",
      "": "y",
      "": "y",
      "": "y",
      "": "y",
      "": "y",
      "": "y",
      "": "z",
      "": "z",
      "": "z",
      "": "z",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "B",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "D",
      "": "D",
      "": "D",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "F",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "H",
      "": "H",
      "": "H",
      "": "H",
      "": "H",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "J",
      "": "K",
      "": "K",
      "": "K",
      "": "L",
      "": "L",
      "": "L",
      "": "M",
      "": "M",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "P",
      "": "P",
      "": "R",
      "": "R",
      "": "R",
      "": "R",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "T",
      "": "T",
      "": "T",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "V",
      "": "W",
      "": "W",
      "": "W",
      "": "W",
      "": "W",
      "": "X",
      "": "X",
      "": "Y",
      "": "Y",
      "": "Y",
      "": "Y",
      "": "Y",
      "": "Y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    };
    class Parser {
      constructor(input, settings) {
        this.mode = void 0;
        this.gullet = void 0;
        this.settings = void 0;
        this.leftrightDepth = void 0;
        this.nextToken = void 0;
        this.mode = "math";
        this.gullet = new MacroExpander(input, settings, this.mode);
        this.settings = settings;
        this.leftrightDepth = 0;
      }
      expect(text, consume) {
        if (consume === void 0) {
          consume = true;
        }
        if (this.fetch().text !== text) {
          throw new ParseError("Expected '" + text + "', got '" + this.fetch().text + "'", this.fetch());
        }
        if (consume) {
          this.consume();
        }
      }
      consume() {
        this.nextToken = null;
      }
      fetch() {
        if (this.nextToken == null) {
          this.nextToken = this.gullet.expandNextToken();
        }
        return this.nextToken;
      }
      switchMode(newMode) {
        this.mode = newMode;
        this.gullet.switchMode(newMode);
      }
      parse() {
        if (!this.settings.globalGroup) {
          this.gullet.beginGroup();
        }
        if (this.settings.colorIsTextColor) {
          this.gullet.macros.set("\\color", "\\textcolor");
        }
        try {
          var parse = this.parseExpression(false);
          this.expect("EOF");
          if (!this.settings.globalGroup) {
            this.gullet.endGroup();
          }
          return parse;
        } finally {
          this.gullet.endGroups();
        }
      }
      subparse(tokens) {
        var oldToken = this.nextToken;
        this.consume();
        this.gullet.pushToken(new Token("}"));
        this.gullet.pushTokens(tokens);
        var parse = this.parseExpression(false);
        this.expect("}");
        this.nextToken = oldToken;
        return parse;
      }
      parseExpression(breakOnInfix, breakOnTokenText) {
        var body = [];
        while (true) {
          if (this.mode === "math") {
            this.consumeSpaces();
          }
          var lex = this.fetch();
          if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
            break;
          }
          if (breakOnTokenText && lex.text === breakOnTokenText) {
            break;
          }
          if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
            break;
          }
          var atom = this.parseAtom(breakOnTokenText);
          if (!atom) {
            break;
          } else if (atom.type === "internal") {
            continue;
          }
          body.push(atom);
        }
        if (this.mode === "text") {
          this.formLigatures(body);
        }
        return this.handleInfixNodes(body);
      }
      handleInfixNodes(body) {
        var overIndex = -1;
        var funcName;
        for (var i = 0; i < body.length; i++) {
          if (body[i].type === "infix") {
            if (overIndex !== -1) {
              throw new ParseError("only one infix operator per group", body[i].token);
            }
            overIndex = i;
            funcName = body[i].replaceWith;
          }
        }
        if (overIndex !== -1 && funcName) {
          var numerNode;
          var denomNode;
          var numerBody = body.slice(0, overIndex);
          var denomBody = body.slice(overIndex + 1);
          if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
            numerNode = numerBody[0];
          } else {
            numerNode = {
              type: "ordgroup",
              mode: this.mode,
              body: numerBody
            };
          }
          if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
            denomNode = denomBody[0];
          } else {
            denomNode = {
              type: "ordgroup",
              mode: this.mode,
              body: denomBody
            };
          }
          var node;
          if (funcName === "\\\\abovefrac") {
            node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
          } else {
            node = this.callFunction(funcName, [numerNode, denomNode], []);
          }
          return [node];
        } else {
          return body;
        }
      }
      handleSupSubscript(name
      ) {
        var symbolToken = this.fetch();
        var symbol = symbolToken.text;
        this.consume();
        this.consumeSpaces();
        var group = this.parseGroup(name);
        if (!group) {
          throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
        }
        return group;
      }
      formatUnsupportedCmd(text) {
        var textordArray = [];
        for (var i = 0; i < text.length; i++) {
          textordArray.push({
            type: "textord",
            mode: "text",
            text: text[i]
          });
        }
        var textNode = {
          type: "text",
          mode: this.mode,
          body: textordArray
        };
        var colorNode = {
          type: "color",
          mode: this.mode,
          color: this.settings.errorColor,
          body: [textNode]
        };
        return colorNode;
      }
      parseAtom(breakOnTokenText) {
        var base = this.parseGroup("atom", breakOnTokenText);
        if (this.mode === "text") {
          return base;
        }
        var superscript;
        var subscript;
        while (true) {
          this.consumeSpaces();
          var lex = this.fetch();
          if (lex.text === "\\limits" || lex.text === "\\nolimits") {
            if (base && base.type === "op") {
              var limits = lex.text === "\\limits";
              base.limits = limits;
              base.alwaysHandleSupSub = true;
            } else if (base && base.type === "operatorname") {
              if (base.alwaysHandleSupSub) {
                base.limits = lex.text === "\\limits";
              }
            } else {
              throw new ParseError("Limit controls must follow a math operator", lex);
            }
            this.consume();
          } else if (lex.text === "^") {
            if (superscript) {
              throw new ParseError("Double superscript", lex);
            }
            superscript = this.handleSupSubscript("superscript");
          } else if (lex.text === "_") {
            if (subscript) {
              throw new ParseError("Double subscript", lex);
            }
            subscript = this.handleSupSubscript("subscript");
          } else if (lex.text === "'") {
            if (superscript) {
              throw new ParseError("Double superscript", lex);
            }
            var prime = {
              type: "textord",
              mode: this.mode,
              text: "\\prime"
            };
            var primes = [prime];
            this.consume();
            while (this.fetch().text === "'") {
              primes.push(prime);
              this.consume();
            }
            if (this.fetch().text === "^") {
              primes.push(this.handleSupSubscript("superscript"));
            }
            superscript = {
              type: "ordgroup",
              mode: this.mode,
              body: primes
            };
          } else if (uSubsAndSups[lex.text]) {
            var str = uSubsAndSups[lex.text];
            var isSub = unicodeSubRegEx.test(lex.text);
            this.consume();
            while (true) {
              var token = this.fetch().text;
              if (!uSubsAndSups[token]) {
                break;
              }
              if (unicodeSubRegEx.test(token) !== isSub) {
                break;
              }
              this.consume();
              str += uSubsAndSups[token];
            }
            var body = new Parser(str, this.settings).parse();
            if (isSub) {
              subscript = {
                type: "ordgroup",
                mode: "math",
                body
              };
            } else {
              superscript = {
                type: "ordgroup",
                mode: "math",
                body
              };
            }
          } else {
            break;
          }
        }
        if (superscript || subscript) {
          return {
            type: "supsub",
            mode: this.mode,
            base: base,
            sup: superscript,
            sub: subscript
          };
        } else {
          return base;
        }
      }
      parseFunction(breakOnTokenText, name
      ) {
        var token = this.fetch();
        var func = token.text;
        var funcData = functions[func];
        if (!funcData) {
          return null;
        }
        this.consume();
        if (name && name !== "atom" && !funcData.allowedInArgument) {
          throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
        } else if (this.mode === "text" && !funcData.allowedInText) {
          throw new ParseError("Can't use function '" + func + "' in text mode", token);
        } else if (this.mode === "math" && funcData.allowedInMath === false) {
          throw new ParseError("Can't use function '" + func + "' in math mode", token);
        }
        var {
          args,
          optArgs
        } = this.parseArguments(func, funcData);
        return this.callFunction(func, args, optArgs, token, breakOnTokenText);
      }
      callFunction(name, args, optArgs, token, breakOnTokenText) {
        var context = {
          funcName: name,
          parser: this,
          token,
          breakOnTokenText
        };
        var func = functions[name];
        if (func && func.handler) {
          return func.handler(context, args, optArgs);
        } else {
          throw new ParseError("No function handler for " + name);
        }
      }
      parseArguments(func,
      funcData) {
        var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
        if (totalArgs === 0) {
          return {
            args: [],
            optArgs: []
          };
        }
        var args = [];
        var optArgs = [];
        for (var i = 0; i < totalArgs; i++) {
          var argType = funcData.argTypes && funcData.argTypes[i];
          var isOptional = i < funcData.numOptionalArgs;
          if (funcData.primitive && argType == null ||
          funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
            argType = "primitive";
          }
          var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
          if (isOptional) {
            optArgs.push(arg);
          } else if (arg != null) {
            args.push(arg);
          } else {
            throw new ParseError("Null argument, please report this as a bug");
          }
        }
        return {
          args,
          optArgs
        };
      }
      parseGroupOfType(name, type, optional) {
        switch (type) {
          case "color":
            return this.parseColorGroup(optional);
          case "size":
            return this.parseSizeGroup(optional);
          case "url":
            return this.parseUrlGroup(optional);
          case "math":
          case "text":
            return this.parseArgumentGroup(optional, type);
          case "hbox":
            {
              var group = this.parseArgumentGroup(optional, "text");
              return group != null ? {
                type: "styling",
                mode: group.mode,
                body: [group],
                style: "text"
              } : null;
            }
          case "raw":
            {
              var token = this.parseStringGroup("raw", optional);
              return token != null ? {
                type: "raw",
                mode: "text",
                string: token.text
              } : null;
            }
          case "primitive":
            {
              if (optional) {
                throw new ParseError("A primitive argument cannot be optional");
              }
              var _group = this.parseGroup(name);
              if (_group == null) {
                throw new ParseError("Expected group as " + name, this.fetch());
              }
              return _group;
            }
          case "original":
          case null:
          case undefined:
            return this.parseArgumentGroup(optional);
          default:
            throw new ParseError("Unknown group type as " + name, this.fetch());
        }
      }
      consumeSpaces() {
        while (this.fetch().text === " ") {
          this.consume();
        }
      }
      parseStringGroup(modeName,
      optional) {
        var argToken = this.gullet.scanArgument(optional);
        if (argToken == null) {
          return null;
        }
        var str = "";
        var nextToken;
        while ((nextToken = this.fetch()).text !== "EOF") {
          str += nextToken.text;
          this.consume();
        }
        this.consume();
        argToken.text = str;
        return argToken;
      }
      parseRegexGroup(regex, modeName
      ) {
        var firstToken = this.fetch();
        var lastToken = firstToken;
        var str = "";
        var nextToken;
        while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
          lastToken = nextToken;
          str += lastToken.text;
          this.consume();
        }
        if (str === "") {
          throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
        }
        return firstToken.range(lastToken, str);
      }
      parseColorGroup(optional) {
        var res = this.parseStringGroup("color", optional);
        if (res == null) {
          return null;
        }
        var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
        if (!match) {
          throw new ParseError("Invalid color: '" + res.text + "'", res);
        }
        var color = match[0];
        if (/^[0-9a-f]{6}$/i.test(color)) {
          color = "#" + color;
        }
        return {
          type: "color-token",
          mode: this.mode,
          color
        };
      }
      parseSizeGroup(optional) {
        var res;
        var isBlank = false;
        this.gullet.consumeSpaces();
        if (!optional && this.gullet.future().text !== "{") {
          res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
        } else {
          res = this.parseStringGroup("size", optional);
        }
        if (!res) {
          return null;
        }
        if (!optional && res.text.length === 0) {
          res.text = "0pt";
          isBlank = true;
        }
        var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
        if (!match) {
          throw new ParseError("Invalid size: '" + res.text + "'", res);
        }
        var data = {
          number: +(match[1] + match[2]),
          unit: match[3]
        };
        if (!validUnit(data)) {
          throw new ParseError("Invalid unit: '" + data.unit + "'", res);
        }
        return {
          type: "size",
          mode: this.mode,
          value: data,
          isBlank
        };
      }
      parseUrlGroup(optional) {
        this.gullet.lexer.setCatcode("%", 13);
        this.gullet.lexer.setCatcode("~", 12);
        var res = this.parseStringGroup("url", optional);
        this.gullet.lexer.setCatcode("%", 14);
        this.gullet.lexer.setCatcode("~", 13);
        if (res == null) {
          return null;
        }
        var url = res.text.replace(/\\([#$%&~_^{}])/g, '$1');
        return {
          type: "url",
          mode: this.mode,
          url
        };
      }
      parseArgumentGroup(optional, mode) {
        var argToken = this.gullet.scanArgument(optional);
        if (argToken == null) {
          return null;
        }
        var outerMode = this.mode;
        if (mode) {
          this.switchMode(mode);
        }
        this.gullet.beginGroup();
        var expression = this.parseExpression(false, "EOF");
        this.expect("EOF");
        this.gullet.endGroup();
        var result = {
          type: "ordgroup",
          mode: this.mode,
          loc: argToken.loc,
          body: expression
        };
        if (mode) {
          this.switchMode(outerMode);
        }
        return result;
      }
      parseGroup(name,
      breakOnTokenText) {
        var firstToken = this.fetch();
        var text = firstToken.text;
        var result;
        if (text === "{" || text === "\\begingroup") {
          this.consume();
          var groupEnd = text === "{" ? "}" : "\\endgroup";
          this.gullet.beginGroup();
          var expression = this.parseExpression(false, groupEnd);
          var lastToken = this.fetch();
          this.expect(groupEnd);
          this.gullet.endGroup();
          result = {
            type: "ordgroup",
            mode: this.mode,
            loc: SourceLocation.range(firstToken, lastToken),
            body: expression,
            semisimple: text === "\\begingroup" || undefined
          };
        } else {
          result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
          if (result == null && text[0] === "\\" && !implicitCommands.hasOwnProperty(text)) {
            if (this.settings.throwOnError) {
              throw new ParseError("Undefined control sequence: " + text, firstToken);
            }
            result = this.formatUnsupportedCmd(text);
            this.consume();
          }
        }
        return result;
      }
      formLigatures(group) {
        var n = group.length - 1;
        for (var i = 0; i < n; ++i) {
          var a = group[i];
          var v = a.text;
          if (v === "-" && group[i + 1].text === "-") {
            if (i + 1 < n && group[i + 2].text === "-") {
              group.splice(i, 3, {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(a, group[i + 2]),
                text: "---"
              });
              n -= 2;
            } else {
              group.splice(i, 2, {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(a, group[i + 1]),
                text: "--"
              });
              n -= 1;
            }
          }
          if ((v === "'" || v === "`") && group[i + 1].text === v) {
            group.splice(i, 2, {
              type: "textord",
              mode: "text",
              loc: SourceLocation.range(a, group[i + 1]),
              text: v + v
            });
            n -= 1;
          }
        }
      }
      parseSymbol() {
        var nucleus = this.fetch();
        var text = nucleus.text;
        if (/^\\verb[^a-zA-Z]/.test(text)) {
          this.consume();
          var arg = text.slice(5);
          var star = arg.charAt(0) === "*";
          if (star) {
            arg = arg.slice(1);
          }
          if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
            throw new ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
          }
          arg = arg.slice(1, -1);
          return {
            type: "verb",
            mode: "text",
            body: arg,
            star
          };
        }
        if (unicodeSymbols.hasOwnProperty(text[0]) && !symbols[this.mode][text[0]]) {
          if (this.settings.strict && this.mode === "math") {
            this.settings.reportNonstrict("unicodeTextInMathMode", "Accented Unicode text character \"" + text[0] + "\" used in " + "math mode", nucleus);
          }
          text = unicodeSymbols[text[0]] + text.slice(1);
        }
        var match = combiningDiacriticalMarksEndRegex.exec(text);
        if (match) {
          text = text.substring(0, match.index);
          if (text === 'i') {
            text = '\u0131';
          } else if (text === 'j') {
            text = '\u0237';
          }
        }
        var symbol;
        if (symbols[this.mode][text]) {
          if (this.settings.strict && this.mode === 'math' && extraLatin.indexOf(text) >= 0) {
            this.settings.reportNonstrict("unicodeTextInMathMode", "Latin-1/Unicode text character \"" + text[0] + "\" used in " + "math mode", nucleus);
          }
          var group = symbols[this.mode][text].group;
          var loc = SourceLocation.range(nucleus);
          var s;
          if (ATOMS.hasOwnProperty(group)) {
            var family = group;
            s = {
              type: "atom",
              mode: this.mode,
              family,
              loc,
              text
            };
          } else {
            s = {
              type: group,
              mode: this.mode,
              loc,
              text
            };
          }
          symbol = s;
        } else if (text.charCodeAt(0) >= 0x80) {
          if (this.settings.strict) {
            if (!supportedCodepoint(text.charCodeAt(0))) {
              this.settings.reportNonstrict("unknownSymbol", "Unrecognized Unicode character \"" + text[0] + "\"" + (" (" + text.charCodeAt(0) + ")"), nucleus);
            } else if (this.mode === "math") {
              this.settings.reportNonstrict("unicodeTextInMathMode", "Unicode text character \"" + text[0] + "\" used in math mode", nucleus);
            }
          }
          symbol = {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(nucleus),
            text
          };
        } else {
          return null;
        }
        this.consume();
        if (match) {
          for (var i = 0; i < match[0].length; i++) {
            var accent = match[0][i];
            if (!unicodeAccents[accent]) {
              throw new ParseError("Unknown accent ' " + accent + "'", nucleus);
            }
            var command = unicodeAccents[accent][this.mode] || unicodeAccents[accent].text;
            if (!command) {
              throw new ParseError("Accent " + accent + " unsupported in " + this.mode + " mode", nucleus);
            }
            symbol = {
              type: "accent",
              mode: this.mode,
              loc: SourceLocation.range(nucleus),
              label: command,
              isStretchy: false,
              isShifty: true,
              base: symbol
            };
          }
        }
        return symbol;
      }
    }
    Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
    var parseTree = function parseTree(toParse, settings) {
      if (!(typeof toParse === 'string' || toParse instanceof String)) {
        throw new TypeError('KaTeX can only parse string typed expression');
      }
      var parser = new Parser(toParse, settings);
      delete parser.gullet.macros.current["\\df@tag"];
      var tree = parser.parse();
      delete parser.gullet.macros.current["\\current@color"];
      delete parser.gullet.macros.current["\\color"];
      if (parser.gullet.macros.get("\\df@tag")) {
        if (!settings.displayMode) {
          throw new ParseError("\\tag works only in display equations");
        }
        tree = [{
          type: "tag",
          mode: "text",
          body: tree,
          tag: parser.subparse([new Token("\\df@tag")])
        }];
      }
      return tree;
    };
    var render = function render(expression, baseNode, options) {
      baseNode.textContent = "";
      var node = renderToDomTree(expression, options).toNode();
      baseNode.appendChild(node);
    };
    if (typeof document !== "undefined") {
      if (document.compatMode !== "CSS1Compat") {
        typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your " + "website has a suitable doctype.");
        render = function render() {
          throw new ParseError("KaTeX doesn't work in quirks mode.");
        };
      }
    }
    var renderToString = function renderToString(expression, options) {
      var markup = renderToDomTree(expression, options).toMarkup();
      return markup;
    };
    var generateParseTree = function generateParseTree(expression, options) {
      var settings = new Settings(options);
      return parseTree(expression, settings);
    };
    var renderError = function renderError(error, expression, options) {
      if (options.throwOnError || !(error instanceof ParseError)) {
        throw error;
      }
      var node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
      node.setAttribute("title", error.toString());
      node.setAttribute("style", "color:" + options.errorColor);
      return node;
    };
    var renderToDomTree = function renderToDomTree(expression, options) {
      var settings = new Settings(options);
      try {
        var tree = parseTree(expression, settings);
        return buildTree(tree, expression, settings);
      } catch (error) {
        return renderError(error, expression, settings);
      }
    };
    var renderToHTMLTree = function renderToHTMLTree(expression, options) {
      var settings = new Settings(options);
      try {
        var tree = parseTree(expression, settings);
        return buildHTMLTree(tree, expression, settings);
      } catch (error) {
        return renderError(error, expression, settings);
      }
    };
    var katex = {
      version: "0.16.5",
      render,
      renderToString,
      ParseError,
      SETTINGS_SCHEMA,
      __parse: generateParseTree,
      __renderToDomTree: renderToDomTree,
      __renderToHTMLTree: renderToHTMLTree,
      __setFontMetrics: setFontMetrics,
      __defineSymbol: defineSymbol,
      __defineFunction: defineFunction,
      __defineMacro: defineMacro,
      __domTree: {
        Span,
        Anchor,
        SymbolNode,
        SvgNode,
        PathNode,
        LineNode
      }
    };

    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _classPrivateMethodGet(receiver, privateSet, fn) {
      if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }
      return fn;
    }
    function _checkPrivateRedeclaration(obj, privateCollection) {
      if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
      }
    }
    function _classPrivateMethodInitSpec(obj, privateSet) {
      _checkPrivateRedeclaration(obj, privateSet);
      privateSet.add(obj);
    }

    function _getDefaults() {
      return {
        async: false,
        breaks: false,
        extensions: null,
        gfm: true,
        hooks: null,
        pedantic: false,
        renderer: null,
        silent: false,
        tokenizer: null,
        walkTokens: null
      };
    }
    let _defaults = _getDefaults();
    function changeDefaults(newDefaults) {
      _defaults = newDefaults;
    }
    const escapeTest = /[&<>"']/;
    const escapeReplace = new RegExp(escapeTest.source, 'g');
    const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
    const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
    const escapeReplacements = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    const getEscapeReplacement = ch => escapeReplacements[ch];
    function escape(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html;
    }
    const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape(html) {
      return html.replace(unescapeTest, (_, n) => {
        n = n.toLowerCase();
        if (n === 'colon') return ':';
        if (n.charAt(0) === '#') {
          return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
        }
        return '';
      });
    }
    const caret = /(^|[^\[])\^/g;
    function edit(regex, opt) {
      regex = typeof regex === 'string' ? regex : regex.source;
      opt = opt || '';
      const obj = {
        replace: (name, val) => {
          val = typeof val === 'object' && 'source' in val ? val.source : val;
          val = val.replace(caret, '$1');
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: () => {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }
    function cleanUrl(href) {
      try {
        href = encodeURI(href).replace(/%25/g, '%');
      } catch (e) {
        return null;
      }
      return href;
    }
    const noopTest = {
      exec: () => null
    };
    function splitCells(tableRow, count) {
      const row = tableRow.replace(/\|/g, (match, offset, str) => {
          let escaped = false;
          let curr = offset;
          while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
          if (escaped) {
            return '|';
          } else {
            return ' |';
          }
        }),
        cells = row.split(/ \|/);
      let i = 0;
      if (!cells[0].trim()) {
        cells.shift();
      }
      if (cells.length > 0 && !cells[cells.length - 1].trim()) {
        cells.pop();
      }
      if (count) {
        if (cells.length > count) {
          cells.splice(count);
        } else {
          while (cells.length < count) cells.push('');
        }
      }
      for (; i < cells.length; i++) {
        cells[i] = cells[i].trim().replace(/\\\|/g, '|');
      }
      return cells;
    }
    function rtrim(str, c, invert) {
      const l = str.length;
      if (l === 0) {
        return '';
      }
      let suffLen = 0;
      while (suffLen < l) {
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }
      return str.slice(0, l - suffLen);
    }
    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      let level = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === '\\') {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }
    function outputLink(cap, link, raw, lexer) {
      const href = link.href;
      const title = link.title ? escape(link.title) : null;
      const text = cap[1].replace(/\\([\[\]])/g, '$1');
      if (cap[0].charAt(0) !== '!') {
        lexer.state.inLink = true;
        const token = {
          type: 'link',
          raw,
          href,
          title,
          text,
          tokens: lexer.inlineTokens(text)
        };
        lexer.state.inLink = false;
        return token;
      }
      return {
        type: 'image',
        raw,
        href,
        title,
        text: escape(text)
      };
    }
    function indentCodeCompensation(raw, text) {
      const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text;
      }
      const indentToCode = matchIndentToCode[1];
      return text.split('\n').map(node => {
        const matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node;
        }
        const [indentInNode] = matchIndentInNode;
        if (indentInNode.length >= indentToCode.length) {
          return node.slice(indentToCode.length);
        }
        return node;
      }).join('\n');
    }
    class _Tokenizer {
      options;
      rules;
      lexer;
      constructor(options) {
        this.options = options || _defaults;
      }
      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: 'space',
            raw: cap[0]
          };
        }
      }
      code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ {1,4}/gm, '');
          return {
            type: 'code',
            raw: cap[0],
            codeBlockStyle: 'indented',
            text: !this.options.pedantic ? rtrim(text, '\n') : text
          };
        }
      }
      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text = indentCodeCompensation(raw, cap[3] || '');
          return {
            type: 'code',
            raw,
            lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, '$1') : cap[2],
            text
          };
        }
      }
      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          let text = cap[2].trim();
          if (/#$/.test(text)) {
            const trimmed = rtrim(text, '#');
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text = trimmed.trim();
            }
          }
          return {
            type: 'heading',
            raw: cap[0],
            depth: cap[1].length,
            text,
            tokens: this.lexer.inline(text)
          };
        }
      }
      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: 'hr',
            raw: cap[0]
          };
        }
      }
      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          const text = rtrim(cap[0].replace(/^ *>[ \t]?/gm, ''), '\n');
          const top = this.lexer.state.top;
          this.lexer.state.top = true;
          const tokens = this.lexer.blockTokens(text);
          this.lexer.state.top = top;
          return {
            type: 'blockquote',
            raw: cap[0],
            tokens,
            text
          };
        }
      }
      list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
          let bull = cap[1].trim();
          const isordered = bull.length > 1;
          const list = {
            type: 'list',
            raw: '',
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : '',
            loose: false,
            items: []
          };
          bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
          if (this.options.pedantic) {
            bull = isordered ? bull : '[*+-]';
          }
          const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|$))`);
          let raw = '';
          let itemContents = '';
          let endsWithBlankLine = false;
          while (src) {
            let endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }
            if (this.rules.block.hr.test(src)) {
              break;
            }
            raw = cap[0];
            src = src.substring(raw.length);
            let line = cap[2].split('\n', 1)[0].replace(/^\t+/, t => ' '.repeat(3 * t.length));
            let nextLine = src.split('\n', 1)[0];
            let indent = 0;
            if (this.options.pedantic) {
              indent = 2;
              itemContents = line.trimStart();
            } else {
              indent = cap[2].search(/[^ ]/);
              indent = indent > 4 ? 1 : indent;
              itemContents = line.slice(indent);
              indent += cap[1].length;
            }
            let blankLine = false;
            if (!line && /^ *$/.test(nextLine)) {
              raw += nextLine + '\n';
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }
            if (!endEarly) {
              const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`);
              const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
              const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
              const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
              while (src) {
                const rawLine = src.split('\n', 1)[0];
                nextLine = rawLine;
                if (this.options.pedantic) {
                  nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');
                }
                if (fencesBeginRegex.test(nextLine)) {
                  break;
                }
                if (headingBeginRegex.test(nextLine)) {
                  break;
                }
                if (nextBulletRegex.test(nextLine)) {
                  break;
                }
                if (hrRegex.test(src)) {
                  break;
                }
                if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
                  itemContents += '\n' + nextLine.slice(indent);
                } else {
                  if (blankLine) {
                    break;
                  }
                  if (line.search(/[^ ]/) >= 4) {
                    break;
                  }
                  if (fencesBeginRegex.test(line)) {
                    break;
                  }
                  if (headingBeginRegex.test(line)) {
                    break;
                  }
                  if (hrRegex.test(line)) {
                    break;
                  }
                  itemContents += '\n' + nextLine;
                }
                if (!blankLine && !nextLine.trim()) {
                  blankLine = true;
                }
                raw += rawLine + '\n';
                src = src.substring(rawLine.length + 1);
                line = nextLine.slice(indent);
              }
            }
            if (!list.loose) {
              if (endsWithBlankLine) {
                list.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }
            let istask = null;
            let ischecked;
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== '[ ] ';
                itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
              }
            }
            list.items.push({
              type: 'list_item',
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents,
              tokens: []
            });
            list.raw += raw;
          }
          list.items[list.items.length - 1].raw = raw.trimEnd();
          list.items[list.items.length - 1].text = itemContents.trimEnd();
          list.raw = list.raw.trimEnd();
          for (let i = 0; i < list.items.length; i++) {
            this.lexer.state.top = false;
            list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
            if (!list.loose) {
              const spacers = list.items[i].tokens.filter(t => t.type === 'space');
              const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\n.*\n/.test(t.raw));
              list.loose = hasMultipleLineBreaks;
            }
          }
          if (list.loose) {
            for (let i = 0; i < list.items.length; i++) {
              list.items[i].loose = true;
            }
          }
          return list;
        }
      }
      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          const token = {
            type: 'html',
            block: true,
            raw: cap[0],
            pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
            text: cap[0]
          };
          return token;
        }
      }
      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
          const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline._escapes, '$1') : '';
          const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, '$1') : cap[3];
          return {
            type: 'def',
            tag,
            raw: cap[0],
            href,
            title
          };
        }
      }
      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
          if (!/[:|]/.test(cap[2])) {
            return;
          }
          const item = {
            type: 'table',
            raw: cap[0],
            header: splitCells(cap[1]).map(c => {
              return {
                text: c,
                tokens: []
              };
            }),
            align: cap[2].replace(/^\||\| *$/g, '').split('|'),
            rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : []
          };
          if (item.header.length === item.align.length) {
            let l = item.align.length;
            let i, j, k, row;
            for (i = 0; i < l; i++) {
              const align = item.align[i];
              if (align) {
                if (/^ *-+: *$/.test(align)) {
                  item.align[i] = 'right';
                } else if (/^ *:-+: *$/.test(align)) {
                  item.align[i] = 'center';
                } else if (/^ *:-+ *$/.test(align)) {
                  item.align[i] = 'left';
                } else {
                  item.align[i] = null;
                }
              }
            }
            l = item.rows.length;
            for (i = 0; i < l; i++) {
              item.rows[i] = splitCells(item.rows[i], item.header.length).map(c => {
                return {
                  text: c,
                  tokens: []
                };
              });
            }
            l = item.header.length;
            for (j = 0; j < l; j++) {
              item.header[j].tokens = this.lexer.inline(item.header[j].text);
            }
            l = item.rows.length;
            for (j = 0; j < l; j++) {
              row = item.rows[j];
              for (k = 0; k < row.length; k++) {
                row[k].tokens = this.lexer.inline(row[k].text);
              }
            }
            return item;
          }
        }
      }
      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: 'heading',
            raw: cap[0],
            depth: cap[2].charAt(0) === '=' ? 1 : 2,
            text: cap[1],
            tokens: this.lexer.inline(cap[1])
          };
        }
      }
      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          const text = cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1];
          return {
            type: 'paragraph',
            raw: cap[0],
            text,
            tokens: this.lexer.inline(text)
          };
        }
      }
      text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          return {
            type: 'text',
            raw: cap[0],
            text: cap[0],
            tokens: this.lexer.inline(cap[0])
          };
        }
      }
      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: 'escape',
            raw: cap[0],
            text: escape(cap[1])
          };
        }
      }
      tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }
          return {
            type: 'html',
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            block: false,
            text: cap[0]
          };
        }
      }
      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            const lastParenIndex = findClosingBracket(cap[2], '()');
            if (lastParenIndex > -1) {
              const start = cap[0].indexOf('!') === 0 ? 5 : 4;
              const linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = '';
            }
          }
          let href = cap[2];
          let title = '';
          if (this.options.pedantic) {
            const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link) {
              href = link[1];
              title = link[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : '';
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
            title: title ? title.replace(this.rules.inline._escapes, '$1') : title
          }, cap[0], this.lexer);
        }
      }
      reflink(src, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          let link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
          link = links[link.toLowerCase()];
          if (!link) {
            const text = cap[0].charAt(0);
            return {
              type: 'text',
              raw: text,
              text
            };
          }
          return outputLink(cap, link, cap[0], this.lexer);
        }
      }
      emStrong(src, maskedSrc, prevChar = '') {
        let match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match) return;
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u)) return;
        const nextChar = match[1] || match[2] || '';
        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
          const lLength = [...match[0]].length - 1;
          let rDelim,
            rLength,
            delimTotal = lLength,
            midDelimTotal = 0;
          const endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + match[0].length - 1);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim) continue;
            rLength = [...rDelim].length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0) continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            const raw = [...src].slice(0, lLength + match.index + rLength + 1).join('');
            if (Math.min(lLength, rLength) % 2) {
              const text = raw.slice(1, -1);
              return {
                type: 'em',
                raw,
                text,
                tokens: this.lexer.inlineTokens(text)
              };
            }
            const text = raw.slice(2, -2);
            return {
              type: 'strong',
              raw,
              text,
              tokens: this.lexer.inlineTokens(text)
            };
          }
        }
      }
      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          let text = cap[2].replace(/\n/g, ' ');
          const hasNonSpaceChars = /[^ ]/.test(text);
          const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape(text, true);
          return {
            type: 'codespan',
            raw: cap[0],
            text
          };
        }
      }
      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: 'br',
            raw: cap[0]
          };
        }
      }
      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: 'del',
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2])
          };
        }
      }
      autolink(src) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text, href;
          if (cap[2] === '@') {
            text = escape(cap[1]);
            href = 'mailto:' + text;
          } else {
            text = escape(cap[1]);
            href = text;
          }
          return {
            type: 'link',
            raw: cap[0],
            text,
            href,
            tokens: [{
              type: 'text',
              raw: text,
              text
            }]
          };
        }
      }
      url(src) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text, href;
          if (cap[2] === '@') {
            text = escape(cap[0]);
            href = 'mailto:' + text;
          } else {
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape(cap[0]);
            if (cap[1] === 'www.') {
              href = 'http://' + cap[0];
            } else {
              href = cap[0];
            }
          }
          return {
            type: 'link',
            raw: cap[0],
            text,
            href,
            tokens: [{
              type: 'text',
              raw: text,
              text
            }]
          };
        }
      }
      inlineText(src) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text;
          if (this.lexer.state.inRawBlock) {
            text = cap[0];
          } else {
            text = escape(cap[0]);
          }
          return {
            type: 'text',
            raw: cap[0],
            text
          };
        }
      }
    }
    const block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
      html: '^ {0,3}(?:'
      + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)'
      + '|comment[^\\n]*(\\n+|$)'
      + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)'
      + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)'
      + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)'
      + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)'
      + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)'
      + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)'
      + ')',
      def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def).replace('label', block._label).replace('title', block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.listItemStart = edit(/^( *)(bull) */).replace('bull', block.bullet).getRegex();
    block.list = edit(block.list).replace(/bull/g, block.bullet).replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replace('def', '\\n+(?=' + block.def.source + ')').getRegex();
    block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.lheading = edit(block.lheading).replace(/bull/g, block.bullet)
    .getRegex();
    block.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '')
    .replace('|table', '').replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag)
    .getRegex();
    block.blockquote = edit(block.blockquote).replace('paragraph', block.paragraph).getRegex();
    block.normal = {
      ...block
    };
    block.gfm = {
      ...block.normal,
      table: '^ *([^\\n ].*)\\n'
      + ' {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)'
      + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)'
    };
    block.gfm.table = edit(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag)
    .getRegex();
    block.gfm.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '')
    .replace('table', block.gfm.table)
    .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag)
    .getRegex();
    block.pedantic = {
      ...block.normal,
      html: edit('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)'
      + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: edit(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()
    };
    const inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: '^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>'
      + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>'
      + '|^<\\?[\\s\\S]*?\\?>'
      + '|^<![a-zA-Z]+\\s[\\s\\S]*?>'
      + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: 'reflink|nolink(?!\\()',
      emStrong: {
        lDelim: /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
        rDelimAst: /^[^_*]*?__[^_*]*?\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\*)[punct](\*+)(?=[\s]|$)|[^punct\s](\*+)(?!\*)(?=[punct\s]|$)|(?!\*)[punct\s](\*+)(?=[^punct\s])|[\s](\*+)(?!\*)(?=[punct])|(?!\*)[punct](\*+)(?!\*)(?=[punct])|[^punct\s](\*+)(?=[^punct\s])/,
        rDelimUnd: /^[^_*]*?\*\*[^_*]*?_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\s]|$)|[^punct\s](_+)(?!_)(?=[punct\s]|$)|(?!_)[punct\s](_+)(?=[^punct\s])|[\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^((?![*_])[\spunctuation])/
    };
    inline._punctuation = '\\p{P}$+<=>`^|~';
    inline.punctuation = edit(inline.punctuation, 'u').replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
    inline.anyPunctuation = /\\[punct]/g;
    inline._escapes = /\\([punct])/g;
    inline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();
    inline.emStrong.lDelim = edit(inline.emStrong.lDelim, 'u').replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'gu').replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'gu').replace(/punct/g, inline._punctuation).getRegex();
    inline.anyPunctuation = edit(inline.anyPunctuation, 'gu').replace(/punct/g, inline._punctuation).getRegex();
    inline._escapes = edit(inline._escapes, 'gu').replace(/punct/g, inline._punctuation).getRegex();
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();
    inline.reflink = edit(inline.reflink).replace('label', inline._label).replace('ref', block._label).getRegex();
    inline.nolink = edit(inline.nolink).replace('ref', block._label).getRegex();
    inline.reflinkSearch = edit(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();
    inline.normal = {
      ...inline
    };
    inline.pedantic = {
      ...inline.normal,
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace('label', inline._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline._label).getRegex()
    };
    inline.gfm = {
      ...inline.normal,
      escape: edit(inline.escape).replace('])', '~|])').getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    };
    inline.gfm.url = edit(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();
    inline.breaks = {
      ...inline.gfm,
      br: edit(inline.br).replace('{2,}', '*').getRegex(),
      text: edit(inline.gfm.text).replace('\\b_', '\\b_| {2,}\\n').replace(/\{2,\}/g, '*').getRegex()
    };
    class _Lexer {
      tokens;
      options;
      state;
      tokenizer;
      inlineQueue;
      constructor(options) {
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || _defaults;
        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };
        const rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      static get rules() {
        return {
          block,
          inline
        };
      }
      static lex(src, options) {
        const lexer = new _Lexer(options);
        return lexer.lex(src);
      }
      static lexInline(src, options) {
        const lexer = new _Lexer(options);
        return lexer.inlineTokens(src);
      }
      lex(src) {
        src = src.replace(/\r\n|\r/g, '\n');
        this.blockTokens(src, this.tokens);
        let next;
        while (next = this.inlineQueue.shift()) {
          this.inlineTokens(next.src, next.tokens);
        }
        return this.tokens;
      }
      blockTokens(src, tokens = []) {
        if (this.options.pedantic) {
          src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
        } else {
          src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
            return leading + '    '.repeat(tabs.length);
          });
        }
        let token;
        let lastToken;
        let cutSrc;
        let lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(extTokenizer => {
            if (token = extTokenizer.call({
              lexer: this
            }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              tokens[tokens.length - 1].raw += '\n';
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
              lastToken.raw += '\n' + token.raw;
              lastToken.text += '\n' + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
              lastToken.raw += '\n' + token.raw;
              lastToken.text += '\n' + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startBlock.forEach(getStartIndex => {
              tempStart = getStartIndex.call({
                lexer: this
              }, tempSrc);
              if (typeof tempStart === 'number' && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === 'paragraph') {
              lastToken.raw += '\n' + token.raw;
              lastToken.text += '\n' + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === 'text') {
              lastToken.raw += '\n' + token.raw;
              lastToken.text += '\n' + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        this.state.top = true;
        return tokens;
      }
      inline(src, tokens = []) {
        this.inlineQueue.push({
          src,
          tokens
        });
        return tokens;
      }
      inlineTokens(src, tokens = []) {
        let token, lastToken, cutSrc;
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;
        if (this.tokens.links) {
          const links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = '';
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(extTokenizer => {
            if (token = extTokenizer.call({
              lexer: this
            }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === 'text' && lastToken.type === 'text') {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === 'text' && lastToken.type === 'text') {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!this.state.inLink && (token = this.tokenizer.url(src))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startInline.forEach(getStartIndex => {
              tempStart = getStartIndex.call({
                lexer: this
              }, tempSrc);
              if (typeof tempStart === 'number' && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (token = this.tokenizer.inlineText(cutSrc)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== '_') {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === 'text') {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
    }
    class _Renderer {
      options;
      constructor(options) {
        this.options = options || _defaults;
      }
      code(code, infostring, escaped) {
        const lang = (infostring || '').match(/^\S*/)?.[0];
        code = code.replace(/\n$/, '') + '\n';
        if (!lang) {
          return '<pre><code>' + (escaped ? code : escape(code, true)) + '</code></pre>\n';
        }
        return '<pre><code class="language-' + escape(lang) + '">' + (escaped ? code : escape(code, true)) + '</code></pre>\n';
      }
      blockquote(quote) {
        return `<blockquote>\n${quote}</blockquote>\n`;
      }
      html(html, block) {
        return html;
      }
      heading(text, level, raw) {
        return `<h${level}>${text}</h${level}>\n`;
      }
      hr() {
        return '<hr>\n';
      }
      list(body, ordered, start) {
        const type = ordered ? 'ol' : 'ul';
        const startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
        return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
      }
      listitem(text, task, checked) {
        return `<li>${text}</li>\n`;
      }
      checkbox(checked) {
        return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox">';
      }
      paragraph(text) {
        return `<p>${text}</p>\n`;
      }
      table(header, body) {
        if (body) body = `<tbody>${body}</tbody>`;
        return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
      }
      tablerow(content) {
        return `<tr>\n${content}</tr>\n`;
      }
      tablecell(content, flags) {
        const type = flags.header ? 'th' : 'td';
        const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
        return tag + content + `</${type}>\n`;
      }
      strong(text) {
        return `<strong>${text}</strong>`;
      }
      em(text) {
        return `<em>${text}</em>`;
      }
      codespan(text) {
        return `<code>${text}</code>`;
      }
      br() {
        return '<br>';
      }
      del(text) {
        return `<del>${text}</del>`;
      }
      link(href, title, text) {
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
          return text;
        }
        href = cleanHref;
        let out = '<a href="' + href + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += '>' + text + '</a>';
        return out;
      }
      image(href, title, text) {
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
          return text;
        }
        href = cleanHref;
        let out = `<img src="${href}" alt="${text}"`;
        if (title) {
          out += ` title="${title}"`;
        }
        out += '>';
        return out;
      }
      text(text) {
        return text;
      }
    }
    class _TextRenderer {
      strong(text) {
        return text;
      }
      em(text) {
        return text;
      }
      codespan(text) {
        return text;
      }
      del(text) {
        return text;
      }
      html(text) {
        return text;
      }
      text(text) {
        return text;
      }
      link(href, title, text) {
        return '' + text;
      }
      image(href, title, text) {
        return '' + text;
      }
      br() {
        return '';
      }
    }
    class _Parser {
      options;
      renderer;
      textRenderer;
      constructor(options) {
        this.options = options || _defaults;
        this.options.renderer = this.options.renderer || new _Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new _TextRenderer();
      }
      static parse(tokens, options) {
        const parser = new _Parser(options);
        return parser.parse(tokens);
      }
      static parseInline(tokens, options) {
        const parser = new _Parser(options);
        return parser.parseInline(tokens);
      }
      parse(tokens, top = true) {
        let out = '';
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            const genericToken = token;
            const ret = this.options.extensions.renderers[genericToken.type].call({
              parser: this
            }, genericToken);
            if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {
              out += ret || '';
              continue;
            }
          }
          switch (token.type) {
            case 'space':
              {
                continue;
              }
            case 'hr':
              {
                out += this.renderer.hr();
                continue;
              }
            case 'heading':
              {
                const headingToken = token;
                out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));
                continue;
              }
            case 'code':
              {
                const codeToken = token;
                out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
                continue;
              }
            case 'table':
              {
                const tableToken = token;
                let header = '';
                let cell = '';
                for (let j = 0; j < tableToken.header.length; j++) {
                  cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), {
                    header: true,
                    align: tableToken.align[j]
                  });
                }
                header += this.renderer.tablerow(cell);
                let body = '';
                for (let j = 0; j < tableToken.rows.length; j++) {
                  const row = tableToken.rows[j];
                  cell = '';
                  for (let k = 0; k < row.length; k++) {
                    cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {
                      header: false,
                      align: tableToken.align[k]
                    });
                  }
                  body += this.renderer.tablerow(cell);
                }
                out += this.renderer.table(header, body);
                continue;
              }
            case 'blockquote':
              {
                const blockquoteToken = token;
                const body = this.parse(blockquoteToken.tokens);
                out += this.renderer.blockquote(body);
                continue;
              }
            case 'list':
              {
                const listToken = token;
                const ordered = listToken.ordered;
                const start = listToken.start;
                const loose = listToken.loose;
                let body = '';
                for (let j = 0; j < listToken.items.length; j++) {
                  const item = listToken.items[j];
                  const checked = item.checked;
                  const task = item.task;
                  let itemBody = '';
                  if (item.task) {
                    const checkbox = this.renderer.checkbox(!!checked);
                    if (loose) {
                      if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                        item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                          item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                        }
                      } else {
                        item.tokens.unshift({
                          type: 'text',
                          text: checkbox + ' '
                        });
                      }
                    } else {
                      itemBody += checkbox + ' ';
                    }
                  }
                  itemBody += this.parse(item.tokens, loose);
                  body += this.renderer.listitem(itemBody, task, !!checked);
                }
                out += this.renderer.list(body, ordered, start);
                continue;
              }
            case 'html':
              {
                const htmlToken = token;
                out += this.renderer.html(htmlToken.text, htmlToken.block);
                continue;
              }
            case 'paragraph':
              {
                const paragraphToken = token;
                out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
                continue;
              }
            case 'text':
              {
                let textToken = token;
                let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
                while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {
                  textToken = tokens[++i];
                  body += '\n' + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
                }
                out += top ? this.renderer.paragraph(body) : body;
                continue;
              }
            default:
              {
                const errMsg = 'Token with "' + token.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(errMsg);
                  return '';
                } else {
                  throw new Error(errMsg);
                }
              }
          }
        }
        return out;
      }
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = '';
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            const ret = this.options.extensions.renderers[token.type].call({
              parser: this
            }, token);
            if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
              out += ret || '';
              continue;
            }
          }
          switch (token.type) {
            case 'escape':
              {
                const escapeToken = token;
                out += renderer.text(escapeToken.text);
                break;
              }
            case 'html':
              {
                const tagToken = token;
                out += renderer.html(tagToken.text);
                break;
              }
            case 'link':
              {
                const linkToken = token;
                out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));
                break;
              }
            case 'image':
              {
                const imageToken = token;
                out += renderer.image(imageToken.href, imageToken.title, imageToken.text);
                break;
              }
            case 'strong':
              {
                const strongToken = token;
                out += renderer.strong(this.parseInline(strongToken.tokens, renderer));
                break;
              }
            case 'em':
              {
                const emToken = token;
                out += renderer.em(this.parseInline(emToken.tokens, renderer));
                break;
              }
            case 'codespan':
              {
                const codespanToken = token;
                out += renderer.codespan(codespanToken.text);
                break;
              }
            case 'br':
              {
                out += renderer.br();
                break;
              }
            case 'del':
              {
                const delToken = token;
                out += renderer.del(this.parseInline(delToken.tokens, renderer));
                break;
              }
            case 'text':
              {
                const textToken = token;
                out += renderer.text(textToken.text);
                break;
              }
            default:
              {
                const errMsg = 'Token with "' + token.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(errMsg);
                  return '';
                } else {
                  throw new Error(errMsg);
                }
              }
          }
        }
        return out;
      }
    }
    class _Hooks {
      options;
      constructor(options) {
        this.options = options || _defaults;
      }
      static passThroughHooks = new Set(['preprocess', 'postprocess']);
      preprocess(markdown) {
        return markdown;
      }
      postprocess(html) {
        return html;
      }
    }
    var _parseMarkdown = new WeakSet();
    var _onError = new WeakSet();
    class Marked {
      constructor(...args) {
        _classPrivateMethodInitSpec(this, _onError);
        _classPrivateMethodInitSpec(this, _parseMarkdown);
        _defineProperty(this, "defaults", _getDefaults());
        _defineProperty(this, "options", this.setOptions);
        _defineProperty(this, "parse", _classPrivateMethodGet(this, _parseMarkdown, _parseMarkdown2).call(this, _Lexer.lex, _Parser.parse));
        _defineProperty(this, "parseInline", _classPrivateMethodGet(this, _parseMarkdown, _parseMarkdown2).call(this, _Lexer.lexInline, _Parser.parseInline));
        _defineProperty(this, "Parser", _Parser);
        _defineProperty(this, "parser", _Parser.parse);
        _defineProperty(this, "Renderer", _Renderer);
        _defineProperty(this, "TextRenderer", _TextRenderer);
        _defineProperty(this, "Lexer", _Lexer);
        _defineProperty(this, "lexer", _Lexer.lex);
        _defineProperty(this, "Tokenizer", _Tokenizer);
        _defineProperty(this, "Hooks", _Hooks);
        this.use(...args);
      }
      walkTokens(tokens, callback) {
        let values = [];
        for (const token of tokens) {
          values = values.concat(callback.call(this, token));
          switch (token.type) {
            case 'table':
              {
                const tableToken = token;
                for (const cell of tableToken.header) {
                  values = values.concat(this.walkTokens(cell.tokens, callback));
                }
                for (const row of tableToken.rows) {
                  for (const cell of row) {
                    values = values.concat(this.walkTokens(cell.tokens, callback));
                  }
                }
                break;
              }
            case 'list':
              {
                const listToken = token;
                values = values.concat(this.walkTokens(listToken.items, callback));
                break;
              }
            default:
              {
                const genericToken = token;
                if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
                  this.defaults.extensions.childTokens[genericToken.type].forEach(childTokens => {
                    values = values.concat(this.walkTokens(genericToken[childTokens], callback));
                  });
                } else if (genericToken.tokens) {
                  values = values.concat(this.walkTokens(genericToken.tokens, callback));
                }
              }
          }
        }
        return values;
      }
      use(...args) {
        const extensions = this.defaults.extensions || {
          renderers: {},
          childTokens: {}
        };
        args.forEach(pack => {
          const opts = {
            ...pack
          };
          opts.async = this.defaults.async || opts.async || false;
          if (pack.extensions) {
            pack.extensions.forEach(ext => {
              if (!ext.name) {
                throw new Error('extension name required');
              }
              if ('renderer' in ext) {
                const prevRenderer = extensions.renderers[ext.name];
                if (prevRenderer) {
                  extensions.renderers[ext.name] = function (...args) {
                    let ret = ext.renderer.apply(this, args);
                    if (ret === false) {
                      ret = prevRenderer.apply(this, args);
                    }
                    return ret;
                  };
                } else {
                  extensions.renderers[ext.name] = ext.renderer;
                }
              }
              if ('tokenizer' in ext) {
                if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {
                  throw new Error("extension level must be 'block' or 'inline'");
                }
                const extLevel = extensions[ext.level];
                if (extLevel) {
                  extLevel.unshift(ext.tokenizer);
                } else {
                  extensions[ext.level] = [ext.tokenizer];
                }
                if (ext.start) {
                  if (ext.level === 'block') {
                    if (extensions.startBlock) {
                      extensions.startBlock.push(ext.start);
                    } else {
                      extensions.startBlock = [ext.start];
                    }
                  } else if (ext.level === 'inline') {
                    if (extensions.startInline) {
                      extensions.startInline.push(ext.start);
                    } else {
                      extensions.startInline = [ext.start];
                    }
                  }
                }
              }
              if ('childTokens' in ext && ext.childTokens) {
                extensions.childTokens[ext.name] = ext.childTokens;
              }
            });
            opts.extensions = extensions;
          }
          if (pack.renderer) {
            const renderer = this.defaults.renderer || new _Renderer(this.defaults);
            for (const prop in pack.renderer) {
              const rendererFunc = pack.renderer[prop];
              const rendererKey = prop;
              const prevRenderer = renderer[rendererKey];
              renderer[rendererKey] = (...args) => {
                let ret = rendererFunc.apply(renderer, args);
                if (ret === false) {
                  ret = prevRenderer.apply(renderer, args);
                }
                return ret || '';
              };
            }
            opts.renderer = renderer;
          }
          if (pack.tokenizer) {
            const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
            for (const prop in pack.tokenizer) {
              const tokenizerFunc = pack.tokenizer[prop];
              const tokenizerKey = prop;
              const prevTokenizer = tokenizer[tokenizerKey];
              tokenizer[tokenizerKey] = (...args) => {
                let ret = tokenizerFunc.apply(tokenizer, args);
                if (ret === false) {
                  ret = prevTokenizer.apply(tokenizer, args);
                }
                return ret;
              };
            }
            opts.tokenizer = tokenizer;
          }
          if (pack.hooks) {
            const hooks = this.defaults.hooks || new _Hooks();
            for (const prop in pack.hooks) {
              const hooksFunc = pack.hooks[prop];
              const hooksKey = prop;
              const prevHook = hooks[hooksKey];
              if (_Hooks.passThroughHooks.has(prop)) {
                hooks[hooksKey] = arg => {
                  if (this.defaults.async) {
                    return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {
                      return prevHook.call(hooks, ret);
                    });
                  }
                  const ret = hooksFunc.call(hooks, arg);
                  return prevHook.call(hooks, ret);
                };
              } else {
                hooks[hooksKey] = (...args) => {
                  let ret = hooksFunc.apply(hooks, args);
                  if (ret === false) {
                    ret = prevHook.apply(hooks, args);
                  }
                  return ret;
                };
              }
            }
            opts.hooks = hooks;
          }
          if (pack.walkTokens) {
            const walkTokens = this.defaults.walkTokens;
            const packWalktokens = pack.walkTokens;
            opts.walkTokens = function (token) {
              let values = [];
              values.push(packWalktokens.call(this, token));
              if (walkTokens) {
                values = values.concat(walkTokens.call(this, token));
              }
              return values;
            };
          }
          this.defaults = {
            ...this.defaults,
            ...opts
          };
        });
        return this;
      }
      setOptions(opt) {
        this.defaults = {
          ...this.defaults,
          ...opt
        };
        return this;
      }
    }
    function _parseMarkdown2(lexer, parser) {
      return (src, options) => {
        const origOpt = {
          ...options
        };
        const opt = {
          ...this.defaults,
          ...origOpt
        };
        if (this.defaults.async === true && origOpt.async === false) {
          if (!opt.silent) {
            console.warn('marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.');
          }
          opt.async = true;
        }
        const throwError = _classPrivateMethodGet(this, _onError, _onError2).call(this, !!opt.silent, !!opt.async);
        if (typeof src === 'undefined' || src === null) {
          return throwError(new Error('marked(): input parameter is undefined or null'));
        }
        if (typeof src !== 'string') {
          return throwError(new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected'));
        }
        if (opt.hooks) {
          opt.hooks.options = opt;
        }
        if (opt.async) {
          return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then(src => lexer(src, opt)).then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then(tokens => parser(tokens, opt)).then(html => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
        }
        try {
          if (opt.hooks) {
            src = opt.hooks.preprocess(src);
          }
          const tokens = lexer(src, opt);
          if (opt.walkTokens) {
            this.walkTokens(tokens, opt.walkTokens);
          }
          let html = parser(tokens, opt);
          if (opt.hooks) {
            html = opt.hooks.postprocess(html);
          }
          return html;
        } catch (e) {
          return throwError(e);
        }
      };
    }
    function _onError2(silent, async) {
      return e => {
        e.message += '\nPlease report this to https://github.com/markedjs/marked.';
        if (silent) {
          const msg = '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
          if (async) {
            return Promise.resolve(msg);
          }
          return msg;
        }
        if (async) {
          return Promise.reject(e);
        }
        throw e;
      };
    }
    const markedInstance = new Marked();
    function marked(src, opt) {
      return markedInstance.parse(src, opt);
    }
    marked.options = marked.setOptions = function (options) {
      markedInstance.setOptions(options);
      marked.defaults = markedInstance.defaults;
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.getDefaults = _getDefaults;
    marked.defaults = _defaults;
    marked.use = function (...args) {
      markedInstance.use(...args);
      marked.defaults = markedInstance.defaults;
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.walkTokens = function (tokens, callback) {
      return markedInstance.walkTokens(tokens, callback);
    };
    marked.parseInline = markedInstance.parseInline;
    marked.Parser = _Parser;
    marked.parser = _Parser.parse;
    marked.Renderer = _Renderer;
    marked.TextRenderer = _TextRenderer;
    marked.Lexer = _Lexer;
    marked.lexer = _Lexer.lex;
    marked.Tokenizer = _Tokenizer;
    marked.Hooks = _Hooks;
    marked.parse = marked;
    marked.options;
    marked.setOptions;
    marked.use;
    marked.walkTokens;
    marked.parseInline;
    _Parser.parse;
    _Lexer.lex;

    const inlineRule = /^(\${1,2})(?!\$)((?:\\.|[^\\\n])*?(?:\\.|[^\\\n\$]))\1(?=[\s?!\.,:]|$)/;
    const blockRule = /^(\${1,2})\n((?:\\[^]|[^\\])+?)\n\1(?:\n|$)/;
    function markedKatex(options = {}) {
      return {
        extensions: [
          inlineKatex(options, createRenderer(options, false)),
          blockKatex(options, createRenderer(options, true))
        ]
      };
    }
    function createRenderer(options, newlineAfter) {
      return (token) => katex.renderToString(token.text, { ...options, displayMode: token.displayMode }) + (newlineAfter ? '\n' : '');
    }
    function inlineKatex(options, renderer) {
      return {
        name: 'inlineKatex',
        level: 'inline',
        start(src) {
          let index;
          let indexSrc = src;
          while (indexSrc) {
            index = indexSrc.indexOf('$');
            if (index === -1) {
              return;
            }
            if (index === 0 || indexSrc.charAt(index - 1) === ' ') {
              const possibleKatex = indexSrc.substring(index);
              if (possibleKatex.match(inlineRule)) {
                return index;
              }
            }
            indexSrc = indexSrc.substring(index + 1).replace(/^\$+/, '');
          }
        },
        tokenizer(src, tokens) {
          const match = src.match(inlineRule);
          if (match) {
            return {
              type: 'inlineKatex',
              raw: match[0],
              text: match[2].trim(),
              displayMode: match[1].length === 2
            };
          }
        },
        renderer
      };
    }
    function blockKatex(options, renderer) {
      return {
        name: 'blockKatex',
        level: 'block',
        tokenizer(src, tokens) {
          const match = src.match(blockRule);
          if (match) {
            return {
              type: 'blockKatex',
              raw: match[0],
              text: match[2].trim(),
              displayMode: match[1].length === 2
            };
          }
        },
        renderer
      };
    }

    // Create a class name generator from the view name
    // ClassName('tmp') will generate a CSS class name like `tp-tmpv`
    const className = ClassName('indu');
    const classNameBorder = ClassName('indub');
    class LatexView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className());
            if (config.border) {
                this.element.classList.add(classNameBorder());
            }
            config.viewProps.bindClassModifiers(this.element);
            const contentElem = doc.createElement('div');
            contentElem.classList.add(className('t'));
            // markdown is latex + markdown
            if (config.markdown) {
                const html = new Marked()
                    // add extensions here if you want in the future
                    .use(markedKatex(Object.assign({ output: "mathml" }, config.latexSettings)))
                    .parse(config.content, Object.assign({ gfm: true, breaks: true }, config.markdownSettings));
                if (typeof html === "string") {
                    contentElem.innerHTML = html;
                }
                else {
                    html.then(str => contentElem.innerHTML = str);
                }
            }
            else if (config.latex) {
                // I think there is a discrepency between the types and the actual module code itself.
                // Just ignore it for now
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                contentElem.innerHTML = katex.renderToString(config.content, Object.assign({ displayMode: true, output: "mathml" }, config.latexSettings));
            }
            else {
                contentElem.textContent = config.content;
            }
            this.element.appendChild(contentElem);
        }
    }

    // Custom controller class should implement `Controller` interface
    class LatexController extends BladeController {
        constructor(doc, config) {
            super({
                blade: createBlade(),
                view: new LatexView(doc, config),
                viewProps: config.viewProps,
            });
        }
    }

    // These are in typescript which are used for reference, but no the shape we want them.
    const p = ParamsParsers;
    /**
     * Please note, these are handconfigured.
     * There is no way to iterate types in typescript so this is a compromise.
     * May be deprecated at some point
     */
    const latexSettingsConfig = {
        displayMode: p.optional.boolean,
        output: p.optional.string,
        leqno: p.optional.boolean,
        fleqn: p.optional.boolean,
        throwOnError: p.optional.boolean,
        errorColor: p.optional.string,
        macros: p.optional.object({}),
        minRuleThickness: p.optional.number,
        colorIsTextColor: p.optional.boolean,
        maxSize: p.optional.number,
        maxExpand: p.optional.number,
        strict: p.optional.boolean,
        trust: p.optional.boolean,
        globalGroup: p.optional.boolean
    };
    /**
     * TODO test this more. I don't think I'll ever really use this though
     */
    const markedSettingsConfig = {
        async: p.optional.boolean,
        breaks: p.optional.boolean,
        gfm: p.optional.boolean,
        pedantic: p.optional.boolean,
        silent: p.optional.boolean,
        renderer: p.optional.object({}),
        tokenizer: p.optional.object({}),
        walkTokens: p.optional.function,
    };

    // NOTE: You can see JSDoc comments of `InputBindingPlugin` for details about each property
    //
    // `InputBindingPlugin<In, Ex, P>` means...
    // - The plugin receives the bound value as `Ex`,
    // - converts `Ex` into `In` and holds it
    // - P is the type of the parsed parameters
    //
    const TweakpaneLatexPlugin = {
        id: 'latex',
        // type: The plugin type.
        // - 'input': Input binding
        // - 'monitor': Monitor binding
        type: 'blade',
        // This plugin template injects a compiled CSS by @rollup/plugin-replace
        // See rollup.config.js for details
        css: '.tp-induv{position:relative;align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-induv.tp-v-disabled{opacity:.5}.tp-induv .tp-induv_t{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;padding:2px 4px 2px;width:1px}.tp-induv .tp-induv_t>*:first-child{margin-top:0}.tp-induv .tp-induv_t>*:last-child{margin-bottom:0}.tp-induv .tp-induv_t p,.tp-induv .tp-induv_t h1,.tp-induv .tp-induv_t h2,.tp-induv .tp-induv_t h3,.tp-induv .tp-induv_t ol,.tp-induv .tp-induv_t ul,.tp-induv .tp-induv_t blockquote,.tp-induv .tp-induv_t pre{margin:.5em 0}.tp-induv .tp-induv_t a{color:var(--btn-bg)}.tp-induv .tp-induv_t a:active{color:var(--btn-bg-a)}.tp-induv .tp-induv_t a:hover{color:var(--btn-bg-h)}.tp-induv .tp-induv_t h1{font-size:1.3em;font-weight:bold}.tp-induv .tp-induv_t h2{font-size:1em;font-weight:bold}.tp-induv .tp-induv_t h3{font-size:1em;font-weight:normal}.tp-induv .tp-induv_t ol,.tp-induv .tp-induv_t ul,.tp-induv .tp-induv_t blockquote{padding-left:28px}.tp-indubv::before{border:var(--mo-fg) dashed 1px;border-radius:var(--elm-br);bottom:0;content:"";left:var(--cnt-v-p);opacity:.3;position:absolute;right:var(--cnt-v-p);top:0}',
        accept(params) {
            // Parse parameters object
            const p = ParamsParsers;
            const r = parseParams(params, {
                border: p.optional.boolean,
                content: p.required.string,
                markdown: p.optional.boolean,
                latex: p.optional.boolean,
                latexSettings: p.optional.object(latexSettingsConfig),
                markdownSettings: p.optional.object(markedSettingsConfig),
                view: p.required.constant('latex'),
            });
            return r ? { params: r } : null;
        },
        controller(args) {
            var _a, _b, _c, _d, _e;
            // Create a controller for the plugin
            return new LatexController(args.document, {
                border: (_a = args.params.border) !== null && _a !== void 0 ? _a : false,
                content: args.params.content,
                latex: (_b = args.params.latex) !== null && _b !== void 0 ? _b : false,
                markdown: (_c = args.params.markdown) !== null && _c !== void 0 ? _c : false,
                latexSettings: (_d = args.params.latexSettings) !== null && _d !== void 0 ? _d : {},
                markdownSettings: (_e = args.params.markdownSettings) !== null && _e !== void 0 ? _e : {},
                viewProps: args.viewProps,
            });
        },
        api(args) {
            if (!(args.controller instanceof LatexController)) {
                return null;
            }
            return new BladeApi(args.controller);
        },
    };

    // Export your plugin(s) as constant `plugins`
    const plugins = [TweakpaneLatexPlugin];

    exports.plugins = plugins;

    Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],3:[function(require,module,exports){
/*! Tweakpane 3.1.7 (c) 2016 cocopon, licensed under the MIT license. */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Tweakpane = {}));
})(this, (function (exports) { 'use strict';

    /***
     * A simple semantic versioning perser.
     */
    class Semver {
        /**
         * @hidden
         */
        constructor(text) {
            const [core, prerelease] = text.split('-');
            const coreComps = core.split('.');
            this.major = parseInt(coreComps[0], 10);
            this.minor = parseInt(coreComps[1], 10);
            this.patch = parseInt(coreComps[2], 10);
            this.prerelease = prerelease !== null && prerelease !== void 0 ? prerelease : null;
        }
        toString() {
            const core = [this.major, this.minor, this.patch].join('.');
            return this.prerelease !== null ? [core, this.prerelease].join('-') : core;
        }
    }

    class BladeApi {
        constructor(controller) {
            this.controller_ = controller;
        }
        get element() {
            return this.controller_.view.element;
        }
        get disabled() {
            return this.controller_.viewProps.get('disabled');
        }
        set disabled(disabled) {
            this.controller_.viewProps.set('disabled', disabled);
        }
        get hidden() {
            return this.controller_.viewProps.get('hidden');
        }
        set hidden(hidden) {
            this.controller_.viewProps.set('hidden', hidden);
        }
        dispose() {
            this.controller_.viewProps.set('disposed', true);
        }
    }

    class TpEvent {
        constructor(target) {
            this.target = target;
        }
    }
    class TpChangeEvent extends TpEvent {
        constructor(target, value, presetKey, last) {
            super(target);
            this.value = value;
            this.presetKey = presetKey;
            this.last = last !== null && last !== void 0 ? last : true;
        }
    }
    class TpUpdateEvent extends TpEvent {
        constructor(target, value, presetKey) {
            super(target);
            this.value = value;
            this.presetKey = presetKey;
        }
    }
    class TpFoldEvent extends TpEvent {
        constructor(target, expanded) {
            super(target);
            this.expanded = expanded;
        }
    }
    class TpTabSelectEvent extends TpEvent {
        constructor(target, index) {
            super(target);
            this.index = index;
        }
    }

    function forceCast(v) {
        return v;
    }
    function isEmpty(value) {
        return value === null || value === undefined;
    }
    function deepEqualsArray(a1, a2) {
        if (a1.length !== a2.length) {
            return false;
        }
        for (let i = 0; i < a1.length; i++) {
            if (a1[i] !== a2[i]) {
                return false;
            }
        }
        return true;
    }
    function isPropertyWritable(obj, key) {
        let target = obj;
        do {
            const d = Object.getOwnPropertyDescriptor(target, key);
            if (d && (d.set !== undefined || d.writable === true)) {
                return true;
            }
            target = Object.getPrototypeOf(target);
        } while (target !== null);
        return false;
    }

    const CREATE_MESSAGE_MAP = {
        alreadydisposed: () => 'View has been already disposed',
        invalidparams: (context) => `Invalid parameters for '${context.name}'`,
        nomatchingcontroller: (context) => `No matching controller for '${context.key}'`,
        nomatchingview: (context) => `No matching view for '${JSON.stringify(context.params)}'`,
        notbindable: () => `Value is not bindable`,
        propertynotfound: (context) => `Property '${context.name}' not found`,
        shouldneverhappen: () => 'This error should never happen',
    };
    class TpError {
        static alreadyDisposed() {
            return new TpError({ type: 'alreadydisposed' });
        }
        static notBindable() {
            return new TpError({
                type: 'notbindable',
            });
        }
        static propertyNotFound(name) {
            return new TpError({
                type: 'propertynotfound',
                context: {
                    name: name,
                },
            });
        }
        static shouldNeverHappen() {
            return new TpError({ type: 'shouldneverhappen' });
        }
        constructor(config) {
            var _a;
            this.message =
                (_a = CREATE_MESSAGE_MAP[config.type](forceCast(config.context))) !== null && _a !== void 0 ? _a : 'Unexpected error';
            this.name = this.constructor.name;
            this.stack = new Error(this.message).stack;
            this.type = config.type;
        }
    }

    class BindingTarget {
        constructor(obj, key, opt_id) {
            this.obj_ = obj;
            this.key_ = key;
            this.presetKey_ = opt_id !== null && opt_id !== void 0 ? opt_id : key;
        }
        static isBindable(obj) {
            if (obj === null) {
                return false;
            }
            if (typeof obj !== 'object') {
                return false;
            }
            return true;
        }
        get key() {
            return this.key_;
        }
        get presetKey() {
            return this.presetKey_;
        }
        read() {
            return this.obj_[this.key_];
        }
        write(value) {
            this.obj_[this.key_] = value;
        }
        writeProperty(name, value) {
            const valueObj = this.read();
            if (!BindingTarget.isBindable(valueObj)) {
                throw TpError.notBindable();
            }
            if (!(name in valueObj)) {
                throw TpError.propertyNotFound(name);
            }
            valueObj[name] = value;
        }
    }

    class ButtonApi extends BladeApi {
        get label() {
            return this.controller_.props.get('label');
        }
        set label(label) {
            this.controller_.props.set('label', label);
        }
        get title() {
            var _a;
            return (_a = this.controller_.valueController.props.get('title')) !== null && _a !== void 0 ? _a : '';
        }
        set title(title) {
            this.controller_.valueController.props.set('title', title);
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            const emitter = this.controller_.valueController.emitter;
            emitter.on(eventName, () => {
                bh(new TpEvent(this));
            });
            return this;
        }
    }

    class Emitter {
        constructor() {
            this.observers_ = {};
        }
        on(eventName, handler) {
            let observers = this.observers_[eventName];
            if (!observers) {
                observers = this.observers_[eventName] = [];
            }
            observers.push({
                handler: handler,
            });
            return this;
        }
        off(eventName, handler) {
            const observers = this.observers_[eventName];
            if (observers) {
                this.observers_[eventName] = observers.filter((observer) => {
                    return observer.handler !== handler;
                });
            }
            return this;
        }
        emit(eventName, event) {
            const observers = this.observers_[eventName];
            if (!observers) {
                return;
            }
            observers.forEach((observer) => {
                observer.handler(event);
            });
        }
    }

    const PREFIX = 'tp';
    function ClassName(viewName) {
        const fn = (opt_elementName, opt_modifier) => {
            return [
                PREFIX,
                '-',
                viewName,
                'v',
                opt_elementName ? `_${opt_elementName}` : '',
                opt_modifier ? `-${opt_modifier}` : '',
            ].join('');
        };
        return fn;
    }

    function compose(h1, h2) {
        return (input) => h2(h1(input));
    }
    function extractValue(ev) {
        return ev.rawValue;
    }
    function bindValue(value, applyValue) {
        value.emitter.on('change', compose(extractValue, applyValue));
        applyValue(value.rawValue);
    }
    function bindValueMap(valueMap, key, applyValue) {
        bindValue(valueMap.value(key), applyValue);
    }

    function applyClass(elem, className, active) {
        if (active) {
            elem.classList.add(className);
        }
        else {
            elem.classList.remove(className);
        }
    }
    function valueToClassName(elem, className) {
        return (value) => {
            applyClass(elem, className, value);
        };
    }
    function bindValueToTextContent(value, elem) {
        bindValue(value, (text) => {
            elem.textContent = text !== null && text !== void 0 ? text : '';
        });
    }

    const className$q = ClassName('btn');
    class ButtonView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$q());
            config.viewProps.bindClassModifiers(this.element);
            const buttonElem = doc.createElement('button');
            buttonElem.classList.add(className$q('b'));
            config.viewProps.bindDisabled(buttonElem);
            this.element.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            const titleElem = doc.createElement('div');
            titleElem.classList.add(className$q('t'));
            bindValueToTextContent(config.props.value('title'), titleElem);
            this.buttonElement.appendChild(titleElem);
        }
    }

    class ButtonController {
        constructor(doc, config) {
            this.emitter = new Emitter();
            this.onClick_ = this.onClick_.bind(this);
            this.props = config.props;
            this.viewProps = config.viewProps;
            this.view = new ButtonView(doc, {
                props: this.props,
                viewProps: this.viewProps,
            });
            this.view.buttonElement.addEventListener('click', this.onClick_);
        }
        onClick_() {
            this.emitter.emit('click', {
                sender: this,
            });
        }
    }

    class BoundValue {
        constructor(initialValue, config) {
            var _a;
            this.constraint_ = config === null || config === void 0 ? void 0 : config.constraint;
            this.equals_ = (_a = config === null || config === void 0 ? void 0 : config.equals) !== null && _a !== void 0 ? _a : ((v1, v2) => v1 === v2);
            this.emitter = new Emitter();
            this.rawValue_ = initialValue;
        }
        get constraint() {
            return this.constraint_;
        }
        get rawValue() {
            return this.rawValue_;
        }
        set rawValue(rawValue) {
            this.setRawValue(rawValue, {
                forceEmit: false,
                last: true,
            });
        }
        setRawValue(rawValue, options) {
            const opts = options !== null && options !== void 0 ? options : {
                forceEmit: false,
                last: true,
            };
            const constrainedValue = this.constraint_
                ? this.constraint_.constrain(rawValue)
                : rawValue;
            const prevValue = this.rawValue_;
            const changed = !this.equals_(prevValue, constrainedValue);
            if (!changed && !opts.forceEmit) {
                return;
            }
            this.emitter.emit('beforechange', {
                sender: this,
            });
            this.rawValue_ = constrainedValue;
            this.emitter.emit('change', {
                options: opts,
                previousRawValue: prevValue,
                rawValue: constrainedValue,
                sender: this,
            });
        }
    }

    class PrimitiveValue {
        constructor(initialValue) {
            this.emitter = new Emitter();
            this.value_ = initialValue;
        }
        get rawValue() {
            return this.value_;
        }
        set rawValue(value) {
            this.setRawValue(value, {
                forceEmit: false,
                last: true,
            });
        }
        setRawValue(value, options) {
            const opts = options !== null && options !== void 0 ? options : {
                forceEmit: false,
                last: true,
            };
            const prevValue = this.value_;
            if (prevValue === value && !opts.forceEmit) {
                return;
            }
            this.emitter.emit('beforechange', {
                sender: this,
            });
            this.value_ = value;
            this.emitter.emit('change', {
                options: opts,
                previousRawValue: prevValue,
                rawValue: this.value_,
                sender: this,
            });
        }
    }

    function createValue(initialValue, config) {
        const constraint = config === null || config === void 0 ? void 0 : config.constraint;
        const equals = config === null || config === void 0 ? void 0 : config.equals;
        if (!constraint && !equals) {
            return new PrimitiveValue(initialValue);
        }
        return new BoundValue(initialValue, config);
    }

    class ValueMap {
        constructor(valueMap) {
            this.emitter = new Emitter();
            this.valMap_ = valueMap;
            for (const key in this.valMap_) {
                const v = this.valMap_[key];
                v.emitter.on('change', () => {
                    this.emitter.emit('change', {
                        key: key,
                        sender: this,
                    });
                });
            }
        }
        static createCore(initialValue) {
            const keys = Object.keys(initialValue);
            return keys.reduce((o, key) => {
                return Object.assign(o, {
                    [key]: createValue(initialValue[key]),
                });
            }, {});
        }
        static fromObject(initialValue) {
            const core = this.createCore(initialValue);
            return new ValueMap(core);
        }
        get(key) {
            return this.valMap_[key].rawValue;
        }
        set(key, value) {
            this.valMap_[key].rawValue = value;
        }
        value(key) {
            return this.valMap_[key];
        }
    }

    function parseObject(value, keyToParserMap) {
        const keys = Object.keys(keyToParserMap);
        const result = keys.reduce((tmp, key) => {
            if (tmp === undefined) {
                return undefined;
            }
            const parser = keyToParserMap[key];
            const result = parser(value[key]);
            return result.succeeded
                ? Object.assign(Object.assign({}, tmp), { [key]: result.value }) : undefined;
        }, {});
        return forceCast(result);
    }
    function parseArray(value, parseItem) {
        return value.reduce((tmp, item) => {
            if (tmp === undefined) {
                return undefined;
            }
            const result = parseItem(item);
            if (!result.succeeded || result.value === undefined) {
                return undefined;
            }
            return [...tmp, result.value];
        }, []);
    }
    function isObject(value) {
        if (value === null) {
            return false;
        }
        return typeof value === 'object';
    }
    function createParamsParserBuilder(parse) {
        return (optional) => (v) => {
            if (!optional && v === undefined) {
                return {
                    succeeded: false,
                    value: undefined,
                };
            }
            if (optional && v === undefined) {
                return {
                    succeeded: true,
                    value: undefined,
                };
            }
            const result = parse(v);
            return result !== undefined
                ? {
                    succeeded: true,
                    value: result,
                }
                : {
                    succeeded: false,
                    value: undefined,
                };
        };
    }
    function createParamsParserBuilders(optional) {
        return {
            custom: (parse) => createParamsParserBuilder(parse)(optional),
            boolean: createParamsParserBuilder((v) => typeof v === 'boolean' ? v : undefined)(optional),
            number: createParamsParserBuilder((v) => typeof v === 'number' ? v : undefined)(optional),
            string: createParamsParserBuilder((v) => typeof v === 'string' ? v : undefined)(optional),
            function: createParamsParserBuilder((v) =>
            typeof v === 'function' ? v : undefined)(optional),
            constant: (value) => createParamsParserBuilder((v) => (v === value ? value : undefined))(optional),
            raw: createParamsParserBuilder((v) => v)(optional),
            object: (keyToParserMap) => createParamsParserBuilder((v) => {
                if (!isObject(v)) {
                    return undefined;
                }
                return parseObject(v, keyToParserMap);
            })(optional),
            array: (itemParser) => createParamsParserBuilder((v) => {
                if (!Array.isArray(v)) {
                    return undefined;
                }
                return parseArray(v, itemParser);
            })(optional),
        };
    }
    const ParamsParsers = {
        optional: createParamsParserBuilders(true),
        required: createParamsParserBuilders(false),
    };
    function parseParams(value, keyToParserMap) {
        const result = ParamsParsers.required.object(keyToParserMap)(value);
        return result.succeeded ? result.value : undefined;
    }

    function warnMissing(info) {
        console.warn([
            `Missing '${info.key}' of ${info.target} in ${info.place}.`,
            'Please rebuild plugins with the latest core package.',
        ].join(' '));
    }

    function disposeElement(elem) {
        if (elem && elem.parentElement) {
            elem.parentElement.removeChild(elem);
        }
        return null;
    }

    class ReadonlyValue {
        constructor(value) {
            this.value_ = value;
        }
        static create(value) {
            return [
                new ReadonlyValue(value),
                (rawValue, options) => {
                    value.setRawValue(rawValue, options);
                },
            ];
        }
        get emitter() {
            return this.value_.emitter;
        }
        get rawValue() {
            return this.value_.rawValue;
        }
    }

    const className$p = ClassName('');
    function valueToModifier(elem, modifier) {
        return valueToClassName(elem, className$p(undefined, modifier));
    }
    class ViewProps extends ValueMap {
        constructor(valueMap) {
            var _a;
            super(valueMap);
            this.onDisabledChange_ = this.onDisabledChange_.bind(this);
            this.onParentChange_ = this.onParentChange_.bind(this);
            this.onParentGlobalDisabledChange_ =
                this.onParentGlobalDisabledChange_.bind(this);
            [this.globalDisabled_, this.setGlobalDisabled_] = ReadonlyValue.create(createValue(this.getGlobalDisabled_()));
            this.value('disabled').emitter.on('change', this.onDisabledChange_);
            this.value('parent').emitter.on('change', this.onParentChange_);
            (_a = this.get('parent')) === null || _a === void 0 ? void 0 : _a.globalDisabled.emitter.on('change', this.onParentGlobalDisabledChange_);
        }
        static create(opt_initialValue) {
            var _a, _b, _c;
            const initialValue = opt_initialValue !== null && opt_initialValue !== void 0 ? opt_initialValue : {};
            return new ViewProps(ValueMap.createCore({
                disabled: (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
                disposed: false,
                hidden: (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false,
                parent: (_c = initialValue.parent) !== null && _c !== void 0 ? _c : null,
            }));
        }
        get globalDisabled() {
            return this.globalDisabled_;
        }
        bindClassModifiers(elem) {
            bindValue(this.globalDisabled_, valueToModifier(elem, 'disabled'));
            bindValueMap(this, 'hidden', valueToModifier(elem, 'hidden'));
        }
        bindDisabled(target) {
            bindValue(this.globalDisabled_, (disabled) => {
                target.disabled = disabled;
            });
        }
        bindTabIndex(elem) {
            bindValue(this.globalDisabled_, (disabled) => {
                elem.tabIndex = disabled ? -1 : 0;
            });
        }
        handleDispose(callback) {
            this.value('disposed').emitter.on('change', (disposed) => {
                if (disposed) {
                    callback();
                }
            });
        }
        getGlobalDisabled_() {
            const parent = this.get('parent');
            const parentDisabled = parent ? parent.globalDisabled.rawValue : false;
            return parentDisabled || this.get('disabled');
        }
        updateGlobalDisabled_() {
            this.setGlobalDisabled_(this.getGlobalDisabled_());
        }
        onDisabledChange_() {
            this.updateGlobalDisabled_();
        }
        onParentGlobalDisabledChange_() {
            this.updateGlobalDisabled_();
        }
        onParentChange_(ev) {
            var _a;
            const prevParent = ev.previousRawValue;
            prevParent === null || prevParent === void 0 ? void 0 : prevParent.globalDisabled.emitter.off('change', this.onParentGlobalDisabledChange_);
            (_a = this.get('parent')) === null || _a === void 0 ? void 0 : _a.globalDisabled.emitter.on('change', this.onParentGlobalDisabledChange_);
            this.updateGlobalDisabled_();
        }
    }

    function getAllBladePositions() {
        return ['veryfirst', 'first', 'last', 'verylast'];
    }

    const className$o = ClassName('');
    const POS_TO_CLASS_NAME_MAP = {
        veryfirst: 'vfst',
        first: 'fst',
        last: 'lst',
        verylast: 'vlst',
    };
    class BladeController {
        constructor(config) {
            this.parent_ = null;
            this.blade = config.blade;
            this.view = config.view;
            this.viewProps = config.viewProps;
            const elem = this.view.element;
            this.blade.value('positions').emitter.on('change', () => {
                getAllBladePositions().forEach((pos) => {
                    elem.classList.remove(className$o(undefined, POS_TO_CLASS_NAME_MAP[pos]));
                });
                this.blade.get('positions').forEach((pos) => {
                    elem.classList.add(className$o(undefined, POS_TO_CLASS_NAME_MAP[pos]));
                });
            });
            this.viewProps.handleDispose(() => {
                disposeElement(elem);
            });
        }
        get parent() {
            return this.parent_;
        }
        set parent(parent) {
            this.parent_ = parent;
            if (!('parent' in this.viewProps.valMap_)) {
                warnMissing({
                    key: 'parent',
                    target: ViewProps.name,
                    place: 'BladeController.parent',
                });
                return;
            }
            this.viewProps.set('parent', this.parent_ ? this.parent_.viewProps : null);
        }
    }

    const SVG_NS = 'http://www.w3.org/2000/svg';
    function forceReflow(element) {
        element.offsetHeight;
    }
    function disableTransitionTemporarily(element, callback) {
        const t = element.style.transition;
        element.style.transition = 'none';
        callback();
        element.style.transition = t;
    }
    function supportsTouch(doc) {
        return doc.ontouchstart !== undefined;
    }
    function getGlobalObject() {
        return globalThis;
    }
    function getWindowDocument() {
        const globalObj = forceCast(getGlobalObject());
        return globalObj.document;
    }
    function getCanvasContext(canvasElement) {
        const win = canvasElement.ownerDocument.defaultView;
        if (!win) {
            return null;
        }
        const isBrowser = 'document' in win;
        return isBrowser
            ? canvasElement.getContext('2d', {
                willReadFrequently: true,
            })
            : null;
    }
    const ICON_ID_TO_INNER_HTML_MAP = {
        check: '<path d="M2 8l4 4l8 -8"/>',
        dropdown: '<path d="M5 7h6l-3 3 z"/>',
        p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>',
    };
    function createSvgIconElement(document, iconId) {
        const elem = document.createElementNS(SVG_NS, 'svg');
        elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP[iconId];
        return elem;
    }
    function insertElementAt(parentElement, element, index) {
        parentElement.insertBefore(element, parentElement.children[index]);
    }
    function removeElement(element) {
        if (element.parentElement) {
            element.parentElement.removeChild(element);
        }
    }
    function removeChildElements(element) {
        while (element.children.length > 0) {
            element.removeChild(element.children[0]);
        }
    }
    function removeChildNodes(element) {
        while (element.childNodes.length > 0) {
            element.removeChild(element.childNodes[0]);
        }
    }
    function findNextTarget(ev) {
        if (ev.relatedTarget) {
            return forceCast(ev.relatedTarget);
        }
        if ('explicitOriginalTarget' in ev) {
            return ev.explicitOriginalTarget;
        }
        return null;
    }

    const className$n = ClassName('lbl');
    function createLabelNode(doc, label) {
        const frag = doc.createDocumentFragment();
        const lineNodes = label.split('\n').map((line) => {
            return doc.createTextNode(line);
        });
        lineNodes.forEach((lineNode, index) => {
            if (index > 0) {
                frag.appendChild(doc.createElement('br'));
            }
            frag.appendChild(lineNode);
        });
        return frag;
    }
    class LabelView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$n());
            config.viewProps.bindClassModifiers(this.element);
            const labelElem = doc.createElement('div');
            labelElem.classList.add(className$n('l'));
            bindValueMap(config.props, 'label', (value) => {
                if (isEmpty(value)) {
                    this.element.classList.add(className$n(undefined, 'nol'));
                }
                else {
                    this.element.classList.remove(className$n(undefined, 'nol'));
                    removeChildNodes(labelElem);
                    labelElem.appendChild(createLabelNode(doc, value));
                }
            });
            this.element.appendChild(labelElem);
            this.labelElement = labelElem;
            const valueElem = doc.createElement('div');
            valueElem.classList.add(className$n('v'));
            this.element.appendChild(valueElem);
            this.valueElement = valueElem;
        }
    }

    class LabelController extends BladeController {
        constructor(doc, config) {
            const viewProps = config.valueController.viewProps;
            super(Object.assign(Object.assign({}, config), { view: new LabelView(doc, {
                    props: config.props,
                    viewProps: viewProps,
                }), viewProps: viewProps }));
            this.props = config.props;
            this.valueController = config.valueController;
            this.view.valueElement.appendChild(this.valueController.view.element);
        }
    }

    const ButtonBladePlugin = {
        id: 'button',
        type: 'blade',
        accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
                title: p.required.string,
                view: p.required.constant('button'),
                label: p.optional.string,
            });
            return result ? { params: result } : null;
        },
        controller(args) {
            return new LabelController(args.document, {
                blade: args.blade,
                props: ValueMap.fromObject({
                    label: args.params.label,
                }),
                valueController: new ButtonController(args.document, {
                    props: ValueMap.fromObject({
                        title: args.params.title,
                    }),
                    viewProps: args.viewProps,
                }),
            });
        },
        api(args) {
            if (!(args.controller instanceof LabelController)) {
                return null;
            }
            if (!(args.controller.valueController instanceof ButtonController)) {
                return null;
            }
            return new ButtonApi(args.controller);
        },
    };

    class ValueBladeController extends BladeController {
        constructor(config) {
            super(config);
            this.value = config.value;
        }
    }

    function createBlade() {
        return new ValueMap({
            positions: createValue([], {
                equals: deepEqualsArray,
            }),
        });
    }

    class Foldable extends ValueMap {
        constructor(valueMap) {
            super(valueMap);
        }
        static create(expanded) {
            const coreObj = {
                completed: true,
                expanded: expanded,
                expandedHeight: null,
                shouldFixHeight: false,
                temporaryExpanded: null,
            };
            const core = ValueMap.createCore(coreObj);
            return new Foldable(core);
        }
        get styleExpanded() {
            var _a;
            return (_a = this.get('temporaryExpanded')) !== null && _a !== void 0 ? _a : this.get('expanded');
        }
        get styleHeight() {
            if (!this.styleExpanded) {
                return '0';
            }
            const exHeight = this.get('expandedHeight');
            if (this.get('shouldFixHeight') && !isEmpty(exHeight)) {
                return `${exHeight}px`;
            }
            return 'auto';
        }
        bindExpandedClass(elem, expandedClassName) {
            const onExpand = () => {
                const expanded = this.styleExpanded;
                if (expanded) {
                    elem.classList.add(expandedClassName);
                }
                else {
                    elem.classList.remove(expandedClassName);
                }
            };
            bindValueMap(this, 'expanded', onExpand);
            bindValueMap(this, 'temporaryExpanded', onExpand);
        }
        cleanUpTransition() {
            this.set('shouldFixHeight', false);
            this.set('expandedHeight', null);
            this.set('completed', true);
        }
    }
    function computeExpandedFolderHeight(folder, containerElement) {
        let height = 0;
        disableTransitionTemporarily(containerElement, () => {
            folder.set('expandedHeight', null);
            folder.set('temporaryExpanded', true);
            forceReflow(containerElement);
            height = containerElement.clientHeight;
            folder.set('temporaryExpanded', null);
            forceReflow(containerElement);
        });
        return height;
    }
    function applyHeight(foldable, elem) {
        elem.style.height = foldable.styleHeight;
    }
    function bindFoldable(foldable, elem) {
        foldable.value('expanded').emitter.on('beforechange', () => {
            foldable.set('completed', false);
            if (isEmpty(foldable.get('expandedHeight'))) {
                const h = computeExpandedFolderHeight(foldable, elem);
                if (h > 0) {
                    foldable.set('expandedHeight', h);
                }
            }
            foldable.set('shouldFixHeight', true);
            forceReflow(elem);
        });
        foldable.emitter.on('change', () => {
            applyHeight(foldable, elem);
        });
        applyHeight(foldable, elem);
        elem.addEventListener('transitionend', (ev) => {
            if (ev.propertyName !== 'height') {
                return;
            }
            foldable.cleanUpTransition();
        });
    }

    class RackLikeApi extends BladeApi {
        constructor(controller, rackApi) {
            super(controller);
            this.rackApi_ = rackApi;
        }
    }

    function addButtonAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: 'button' }));
    }
    function addFolderAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: 'folder' }));
    }
    function addSeparatorAsBlade(api, opt_params) {
        const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
        return api.addBlade(Object.assign(Object.assign({}, params), { view: 'separator' }));
    }
    function addTabAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: 'tab' }));
    }

    class NestedOrderedSet {
        constructor(extract) {
            this.emitter = new Emitter();
            this.items_ = [];
            this.cache_ = new Set();
            this.onSubListAdd_ = this.onSubListAdd_.bind(this);
            this.onSubListRemove_ = this.onSubListRemove_.bind(this);
            this.extract_ = extract;
        }
        get items() {
            return this.items_;
        }
        allItems() {
            return Array.from(this.cache_);
        }
        find(callback) {
            for (const item of this.allItems()) {
                if (callback(item)) {
                    return item;
                }
            }
            return null;
        }
        includes(item) {
            return this.cache_.has(item);
        }
        add(item, opt_index) {
            if (this.includes(item)) {
                throw TpError.shouldNeverHappen();
            }
            const index = opt_index !== undefined ? opt_index : this.items_.length;
            this.items_.splice(index, 0, item);
            this.cache_.add(item);
            const subList = this.extract_(item);
            if (subList) {
                subList.emitter.on('add', this.onSubListAdd_);
                subList.emitter.on('remove', this.onSubListRemove_);
                subList.allItems().forEach((item) => {
                    this.cache_.add(item);
                });
            }
            this.emitter.emit('add', {
                index: index,
                item: item,
                root: this,
                target: this,
            });
        }
        remove(item) {
            const index = this.items_.indexOf(item);
            if (index < 0) {
                return;
            }
            this.items_.splice(index, 1);
            this.cache_.delete(item);
            const subList = this.extract_(item);
            if (subList) {
                subList.emitter.off('add', this.onSubListAdd_);
                subList.emitter.off('remove', this.onSubListRemove_);
            }
            this.emitter.emit('remove', {
                index: index,
                item: item,
                root: this,
                target: this,
            });
        }
        onSubListAdd_(ev) {
            this.cache_.add(ev.item);
            this.emitter.emit('add', {
                index: ev.index,
                item: ev.item,
                root: this,
                target: ev.target,
            });
        }
        onSubListRemove_(ev) {
            this.cache_.delete(ev.item);
            this.emitter.emit('remove', {
                index: ev.index,
                item: ev.item,
                root: this,
                target: ev.target,
            });
        }
    }

    class InputBindingApi extends BladeApi {
        constructor(controller) {
            super(controller);
            this.onBindingChange_ = this.onBindingChange_.bind(this);
            this.emitter_ = new Emitter();
            this.controller_.binding.emitter.on('change', this.onBindingChange_);
        }
        get label() {
            return this.controller_.props.get('label');
        }
        set label(label) {
            this.controller_.props.set('label', label);
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
        refresh() {
            this.controller_.binding.read();
        }
        onBindingChange_(ev) {
            const value = ev.sender.target.read();
            this.emitter_.emit('change', {
                event: new TpChangeEvent(this, forceCast(value), this.controller_.binding.target.presetKey, ev.options.last),
            });
        }
    }

    class InputBindingController extends LabelController {
        constructor(doc, config) {
            super(doc, config);
            this.binding = config.binding;
        }
    }

    class MonitorBindingApi extends BladeApi {
        constructor(controller) {
            super(controller);
            this.onBindingUpdate_ = this.onBindingUpdate_.bind(this);
            this.emitter_ = new Emitter();
            this.controller_.binding.emitter.on('update', this.onBindingUpdate_);
        }
        get label() {
            return this.controller_.props.get('label');
        }
        set label(label) {
            this.controller_.props.set('label', label);
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
        refresh() {
            this.controller_.binding.read();
        }
        onBindingUpdate_(ev) {
            const value = ev.sender.target.read();
            this.emitter_.emit('update', {
                event: new TpUpdateEvent(this, forceCast(value), this.controller_.binding.target.presetKey),
            });
        }
    }

    class MonitorBindingController extends LabelController {
        constructor(doc, config) {
            super(doc, config);
            this.binding = config.binding;
            this.viewProps.bindDisabled(this.binding.ticker);
            this.viewProps.handleDispose(() => {
                this.binding.dispose();
            });
        }
    }

    function findSubBladeApiSet(api) {
        if (api instanceof RackApi) {
            return api['apiSet_'];
        }
        if (api instanceof RackLikeApi) {
            return api['rackApi_']['apiSet_'];
        }
        return null;
    }
    function getApiByController(apiSet, controller) {
        const api = apiSet.find((api) => api.controller_ === controller);
        if (!api) {
            throw TpError.shouldNeverHappen();
        }
        return api;
    }
    function createBindingTarget(obj, key, opt_id) {
        if (!BindingTarget.isBindable(obj)) {
            throw TpError.notBindable();
        }
        return new BindingTarget(obj, key, opt_id);
    }
    class RackApi extends BladeApi {
        constructor(controller, pool) {
            super(controller);
            this.onRackAdd_ = this.onRackAdd_.bind(this);
            this.onRackRemove_ = this.onRackRemove_.bind(this);
            this.onRackInputChange_ = this.onRackInputChange_.bind(this);
            this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this);
            this.emitter_ = new Emitter();
            this.apiSet_ = new NestedOrderedSet(findSubBladeApiSet);
            this.pool_ = pool;
            const rack = this.controller_.rack;
            rack.emitter.on('add', this.onRackAdd_);
            rack.emitter.on('remove', this.onRackRemove_);
            rack.emitter.on('inputchange', this.onRackInputChange_);
            rack.emitter.on('monitorupdate', this.onRackMonitorUpdate_);
            rack.children.forEach((bc) => {
                this.setUpApi_(bc);
            });
        }
        get children() {
            return this.controller_.rack.children.map((bc) => getApiByController(this.apiSet_, bc));
        }
        addInput(object, key, opt_params) {
            const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
            const doc = this.controller_.view.element.ownerDocument;
            const bc = this.pool_.createInput(doc, createBindingTarget(object, key, params.presetKey), params);
            const api = new InputBindingApi(bc);
            return this.add(api, params.index);
        }
        addMonitor(object, key, opt_params) {
            const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
            const doc = this.controller_.view.element.ownerDocument;
            const bc = this.pool_.createMonitor(doc, createBindingTarget(object, key), params);
            const api = new MonitorBindingApi(bc);
            return forceCast(this.add(api, params.index));
        }
        addFolder(params) {
            return addFolderAsBlade(this, params);
        }
        addButton(params) {
            return addButtonAsBlade(this, params);
        }
        addSeparator(opt_params) {
            return addSeparatorAsBlade(this, opt_params);
        }
        addTab(params) {
            return addTabAsBlade(this, params);
        }
        add(api, opt_index) {
            this.controller_.rack.add(api.controller_, opt_index);
            const gapi = this.apiSet_.find((a) => a.controller_ === api.controller_);
            if (gapi) {
                this.apiSet_.remove(gapi);
            }
            this.apiSet_.add(api);
            return api;
        }
        remove(api) {
            this.controller_.rack.remove(api.controller_);
        }
        addBlade(params) {
            const doc = this.controller_.view.element.ownerDocument;
            const bc = this.pool_.createBlade(doc, params);
            const api = this.pool_.createBladeApi(bc);
            return this.add(api, params.index);
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
        setUpApi_(bc) {
            const api = this.apiSet_.find((api) => api.controller_ === bc);
            if (!api) {
                this.apiSet_.add(this.pool_.createBladeApi(bc));
            }
        }
        onRackAdd_(ev) {
            this.setUpApi_(ev.bladeController);
        }
        onRackRemove_(ev) {
            if (ev.isRoot) {
                const api = getApiByController(this.apiSet_, ev.bladeController);
                this.apiSet_.remove(api);
            }
        }
        onRackInputChange_(ev) {
            const bc = ev.bladeController;
            if (bc instanceof InputBindingController) {
                const api = getApiByController(this.apiSet_, bc);
                const binding = bc.binding;
                this.emitter_.emit('change', {
                    event: new TpChangeEvent(api, forceCast(binding.target.read()), binding.target.presetKey, ev.options.last),
                });
            }
            else if (bc instanceof ValueBladeController) {
                const api = getApiByController(this.apiSet_, bc);
                this.emitter_.emit('change', {
                    event: new TpChangeEvent(api, bc.value.rawValue, undefined, ev.options.last),
                });
            }
        }
        onRackMonitorUpdate_(ev) {
            if (!(ev.bladeController instanceof MonitorBindingController)) {
                throw TpError.shouldNeverHappen();
            }
            const api = getApiByController(this.apiSet_, ev.bladeController);
            const binding = ev.bladeController.binding;
            this.emitter_.emit('update', {
                event: new TpUpdateEvent(api, forceCast(binding.target.read()), binding.target.presetKey),
            });
        }
    }

    class FolderApi extends RackLikeApi {
        constructor(controller, pool) {
            super(controller, new RackApi(controller.rackController, pool));
            this.emitter_ = new Emitter();
            this.controller_.foldable
                .value('expanded')
                .emitter.on('change', (ev) => {
                this.emitter_.emit('fold', {
                    event: new TpFoldEvent(this, ev.sender.rawValue),
                });
            });
            this.rackApi_.on('change', (ev) => {
                this.emitter_.emit('change', {
                    event: ev,
                });
            });
            this.rackApi_.on('update', (ev) => {
                this.emitter_.emit('update', {
                    event: ev,
                });
            });
        }
        get expanded() {
            return this.controller_.foldable.get('expanded');
        }
        set expanded(expanded) {
            this.controller_.foldable.set('expanded', expanded);
        }
        get title() {
            return this.controller_.props.get('title');
        }
        set title(title) {
            this.controller_.props.set('title', title);
        }
        get children() {
            return this.rackApi_.children;
        }
        addInput(object, key, opt_params) {
            return this.rackApi_.addInput(object, key, opt_params);
        }
        addMonitor(object, key, opt_params) {
            return this.rackApi_.addMonitor(object, key, opt_params);
        }
        addFolder(params) {
            return this.rackApi_.addFolder(params);
        }
        addButton(params) {
            return this.rackApi_.addButton(params);
        }
        addSeparator(opt_params) {
            return this.rackApi_.addSeparator(opt_params);
        }
        addTab(params) {
            return this.rackApi_.addTab(params);
        }
        add(api, opt_index) {
            return this.rackApi_.add(api, opt_index);
        }
        remove(api) {
            this.rackApi_.remove(api);
        }
        addBlade(params) {
            return this.rackApi_.addBlade(params);
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
    }

    class RackLikeController extends BladeController {
        constructor(config) {
            super({
                blade: config.blade,
                view: config.view,
                viewProps: config.rackController.viewProps,
            });
            this.rackController = config.rackController;
        }
    }

    class PlainView {
        constructor(doc, config) {
            const className = ClassName(config.viewName);
            this.element = doc.createElement('div');
            this.element.classList.add(className());
            config.viewProps.bindClassModifiers(this.element);
        }
    }

    function findInputBindingController(bcs, b) {
        for (let i = 0; i < bcs.length; i++) {
            const bc = bcs[i];
            if (bc instanceof InputBindingController && bc.binding === b) {
                return bc;
            }
        }
        return null;
    }
    function findMonitorBindingController(bcs, b) {
        for (let i = 0; i < bcs.length; i++) {
            const bc = bcs[i];
            if (bc instanceof MonitorBindingController && bc.binding === b) {
                return bc;
            }
        }
        return null;
    }
    function findValueBladeController(bcs, v) {
        for (let i = 0; i < bcs.length; i++) {
            const bc = bcs[i];
            if (bc instanceof ValueBladeController && bc.value === v) {
                return bc;
            }
        }
        return null;
    }
    function findSubRack(bc) {
        if (bc instanceof RackController) {
            return bc.rack;
        }
        if (bc instanceof RackLikeController) {
            return bc.rackController.rack;
        }
        return null;
    }
    function findSubBladeControllerSet(bc) {
        const rack = findSubRack(bc);
        return rack ? rack['bcSet_'] : null;
    }
    class BladeRack {
        constructor(config) {
            var _a, _b;
            this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
            this.onSetAdd_ = this.onSetAdd_.bind(this);
            this.onSetRemove_ = this.onSetRemove_.bind(this);
            this.onChildDispose_ = this.onChildDispose_.bind(this);
            this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
            this.onChildInputChange_ = this.onChildInputChange_.bind(this);
            this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this);
            this.onChildValueChange_ = this.onChildValueChange_.bind(this);
            this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
            this.onDescendantLayout_ = this.onDescendantLayout_.bind(this);
            this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this);
            this.onDescendantMonitorUpdate_ =
                this.onDescendantMonitorUpdate_.bind(this);
            this.emitter = new Emitter();
            this.blade_ = (_a = config.blade) !== null && _a !== void 0 ? _a : null;
            (_b = this.blade_) === null || _b === void 0 ? void 0 : _b.value('positions').emitter.on('change', this.onBladePositionsChange_);
            this.viewProps = config.viewProps;
            this.bcSet_ = new NestedOrderedSet(findSubBladeControllerSet);
            this.bcSet_.emitter.on('add', this.onSetAdd_);
            this.bcSet_.emitter.on('remove', this.onSetRemove_);
        }
        get children() {
            return this.bcSet_.items;
        }
        add(bc, opt_index) {
            var _a;
            (_a = bc.parent) === null || _a === void 0 ? void 0 : _a.remove(bc);
            if (isPropertyWritable(bc, 'parent')) {
                bc.parent = this;
            }
            else {
                bc['parent_'] = this;
                warnMissing({
                    key: 'parent',
                    target: 'BladeController',
                    place: 'BladeRack.add',
                });
            }
            this.bcSet_.add(bc, opt_index);
        }
        remove(bc) {
            if (isPropertyWritable(bc, 'parent')) {
                bc.parent = null;
            }
            else {
                bc['parent_'] = null;
                warnMissing({
                    key: 'parent',
                    target: 'BladeController',
                    place: 'BladeRack.remove',
                });
            }
            this.bcSet_.remove(bc);
        }
        find(controllerClass) {
            return forceCast(this.bcSet_.allItems().filter((bc) => {
                return bc instanceof controllerClass;
            }));
        }
        onSetAdd_(ev) {
            this.updatePositions_();
            const isRoot = ev.target === ev.root;
            this.emitter.emit('add', {
                bladeController: ev.item,
                index: ev.index,
                isRoot: isRoot,
                sender: this,
            });
            if (!isRoot) {
                return;
            }
            const bc = ev.item;
            bc.viewProps.emitter.on('change', this.onChildViewPropsChange_);
            bc.blade
                .value('positions')
                .emitter.on('change', this.onChildPositionsChange_);
            bc.viewProps.handleDispose(this.onChildDispose_);
            if (bc instanceof InputBindingController) {
                bc.binding.emitter.on('change', this.onChildInputChange_);
            }
            else if (bc instanceof MonitorBindingController) {
                bc.binding.emitter.on('update', this.onChildMonitorUpdate_);
            }
            else if (bc instanceof ValueBladeController) {
                bc.value.emitter.on('change', this.onChildValueChange_);
            }
            else {
                const rack = findSubRack(bc);
                if (rack) {
                    const emitter = rack.emitter;
                    emitter.on('layout', this.onDescendantLayout_);
                    emitter.on('inputchange', this.onDescendantInputChange_);
                    emitter.on('monitorupdate', this.onDescendantMonitorUpdate_);
                }
            }
        }
        onSetRemove_(ev) {
            this.updatePositions_();
            const isRoot = ev.target === ev.root;
            this.emitter.emit('remove', {
                bladeController: ev.item,
                isRoot: isRoot,
                sender: this,
            });
            if (!isRoot) {
                return;
            }
            const bc = ev.item;
            if (bc instanceof InputBindingController) {
                bc.binding.emitter.off('change', this.onChildInputChange_);
            }
            else if (bc instanceof MonitorBindingController) {
                bc.binding.emitter.off('update', this.onChildMonitorUpdate_);
            }
            else if (bc instanceof ValueBladeController) {
                bc.value.emitter.off('change', this.onChildValueChange_);
            }
            else {
                const rack = findSubRack(bc);
                if (rack) {
                    const emitter = rack.emitter;
                    emitter.off('layout', this.onDescendantLayout_);
                    emitter.off('inputchange', this.onDescendantInputChange_);
                    emitter.off('monitorupdate', this.onDescendantMonitorUpdate_);
                }
            }
        }
        updatePositions_() {
            const visibleItems = this.bcSet_.items.filter((bc) => !bc.viewProps.get('hidden'));
            const firstVisibleItem = visibleItems[0];
            const lastVisibleItem = visibleItems[visibleItems.length - 1];
            this.bcSet_.items.forEach((bc) => {
                const ps = [];
                if (bc === firstVisibleItem) {
                    ps.push('first');
                    if (!this.blade_ ||
                        this.blade_.get('positions').includes('veryfirst')) {
                        ps.push('veryfirst');
                    }
                }
                if (bc === lastVisibleItem) {
                    ps.push('last');
                    if (!this.blade_ || this.blade_.get('positions').includes('verylast')) {
                        ps.push('verylast');
                    }
                }
                bc.blade.set('positions', ps);
            });
        }
        onChildPositionsChange_() {
            this.updatePositions_();
            this.emitter.emit('layout', {
                sender: this,
            });
        }
        onChildViewPropsChange_(_ev) {
            this.updatePositions_();
            this.emitter.emit('layout', {
                sender: this,
            });
        }
        onChildDispose_() {
            const disposedUcs = this.bcSet_.items.filter((bc) => {
                return bc.viewProps.get('disposed');
            });
            disposedUcs.forEach((bc) => {
                this.bcSet_.remove(bc);
            });
        }
        onChildInputChange_(ev) {
            const bc = findInputBindingController(this.find(InputBindingController), ev.sender);
            if (!bc) {
                throw TpError.alreadyDisposed();
            }
            this.emitter.emit('inputchange', {
                bladeController: bc,
                options: ev.options,
                sender: this,
            });
        }
        onChildMonitorUpdate_(ev) {
            const bc = findMonitorBindingController(this.find(MonitorBindingController), ev.sender);
            if (!bc) {
                throw TpError.alreadyDisposed();
            }
            this.emitter.emit('monitorupdate', {
                bladeController: bc,
                sender: this,
            });
        }
        onChildValueChange_(ev) {
            const bc = findValueBladeController(this.find(ValueBladeController), ev.sender);
            if (!bc) {
                throw TpError.alreadyDisposed();
            }
            this.emitter.emit('inputchange', {
                bladeController: bc,
                options: ev.options,
                sender: this,
            });
        }
        onDescendantLayout_(_) {
            this.updatePositions_();
            this.emitter.emit('layout', {
                sender: this,
            });
        }
        onDescendantInputChange_(ev) {
            this.emitter.emit('inputchange', {
                bladeController: ev.bladeController,
                options: ev.options,
                sender: this,
            });
        }
        onDescendantMonitorUpdate_(ev) {
            this.emitter.emit('monitorupdate', {
                bladeController: ev.bladeController,
                sender: this,
            });
        }
        onBladePositionsChange_() {
            this.updatePositions_();
        }
    }

    class RackController extends BladeController {
        constructor(doc, config) {
            super(Object.assign(Object.assign({}, config), { view: new PlainView(doc, {
                    viewName: 'brk',
                    viewProps: config.viewProps,
                }) }));
            this.onRackAdd_ = this.onRackAdd_.bind(this);
            this.onRackRemove_ = this.onRackRemove_.bind(this);
            const rack = new BladeRack({
                blade: config.root ? undefined : config.blade,
                viewProps: config.viewProps,
            });
            rack.emitter.on('add', this.onRackAdd_);
            rack.emitter.on('remove', this.onRackRemove_);
            this.rack = rack;
            this.viewProps.handleDispose(() => {
                for (let i = this.rack.children.length - 1; i >= 0; i--) {
                    const bc = this.rack.children[i];
                    bc.viewProps.set('disposed', true);
                }
            });
        }
        onRackAdd_(ev) {
            if (!ev.isRoot) {
                return;
            }
            insertElementAt(this.view.element, ev.bladeController.view.element, ev.index);
        }
        onRackRemove_(ev) {
            if (!ev.isRoot) {
                return;
            }
            removeElement(ev.bladeController.view.element);
        }
    }

    const bladeContainerClassName = ClassName('cnt');

    class FolderView {
        constructor(doc, config) {
            var _a;
            this.className_ = ClassName((_a = config.viewName) !== null && _a !== void 0 ? _a : 'fld');
            this.element = doc.createElement('div');
            this.element.classList.add(this.className_(), bladeContainerClassName());
            config.viewProps.bindClassModifiers(this.element);
            this.foldable_ = config.foldable;
            this.foldable_.bindExpandedClass(this.element, this.className_(undefined, 'expanded'));
            bindValueMap(this.foldable_, 'completed', valueToClassName(this.element, this.className_(undefined, 'cpl')));
            const buttonElem = doc.createElement('button');
            buttonElem.classList.add(this.className_('b'));
            bindValueMap(config.props, 'title', (title) => {
                if (isEmpty(title)) {
                    this.element.classList.add(this.className_(undefined, 'not'));
                }
                else {
                    this.element.classList.remove(this.className_(undefined, 'not'));
                }
            });
            config.viewProps.bindDisabled(buttonElem);
            this.element.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            const indentElem = doc.createElement('div');
            indentElem.classList.add(this.className_('i'));
            this.element.appendChild(indentElem);
            const titleElem = doc.createElement('div');
            titleElem.classList.add(this.className_('t'));
            bindValueToTextContent(config.props.value('title'), titleElem);
            this.buttonElement.appendChild(titleElem);
            this.titleElement = titleElem;
            const markElem = doc.createElement('div');
            markElem.classList.add(this.className_('m'));
            this.buttonElement.appendChild(markElem);
            const containerElem = config.containerElement;
            containerElem.classList.add(this.className_('c'));
            this.element.appendChild(containerElem);
            this.containerElement = containerElem;
        }
    }

    class FolderController extends RackLikeController {
        constructor(doc, config) {
            var _a;
            const foldable = Foldable.create((_a = config.expanded) !== null && _a !== void 0 ? _a : true);
            const rc = new RackController(doc, {
                blade: config.blade,
                root: config.root,
                viewProps: config.viewProps,
            });
            super(Object.assign(Object.assign({}, config), { rackController: rc, view: new FolderView(doc, {
                    containerElement: rc.view.element,
                    foldable: foldable,
                    props: config.props,
                    viewName: config.root ? 'rot' : undefined,
                    viewProps: config.viewProps,
                }) }));
            this.onTitleClick_ = this.onTitleClick_.bind(this);
            this.props = config.props;
            this.foldable = foldable;
            bindFoldable(this.foldable, this.view.containerElement);
            this.rackController.rack.emitter.on('add', () => {
                this.foldable.cleanUpTransition();
            });
            this.rackController.rack.emitter.on('remove', () => {
                this.foldable.cleanUpTransition();
            });
            this.view.buttonElement.addEventListener('click', this.onTitleClick_);
        }
        get document() {
            return this.view.element.ownerDocument;
        }
        onTitleClick_() {
            this.foldable.set('expanded', !this.foldable.get('expanded'));
        }
    }

    const FolderBladePlugin = {
        id: 'folder',
        type: 'blade',
        accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
                title: p.required.string,
                view: p.required.constant('folder'),
                expanded: p.optional.boolean,
            });
            return result ? { params: result } : null;
        },
        controller(args) {
            return new FolderController(args.document, {
                blade: args.blade,
                expanded: args.params.expanded,
                props: ValueMap.fromObject({
                    title: args.params.title,
                }),
                viewProps: args.viewProps,
            });
        },
        api(args) {
            if (!(args.controller instanceof FolderController)) {
                return null;
            }
            return new FolderApi(args.controller, args.pool);
        },
    };

    class LabeledValueController extends ValueBladeController {
        constructor(doc, config) {
            const viewProps = config.valueController.viewProps;
            super(Object.assign(Object.assign({}, config), { value: config.valueController.value, view: new LabelView(doc, {
                    props: config.props,
                    viewProps: viewProps,
                }), viewProps: viewProps }));
            this.props = config.props;
            this.valueController = config.valueController;
            this.view.valueElement.appendChild(this.valueController.view.element);
        }
    }

    class SeparatorApi extends BladeApi {
    }

    const className$m = ClassName('spr');
    class SeparatorView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$m());
            config.viewProps.bindClassModifiers(this.element);
            const hrElem = doc.createElement('hr');
            hrElem.classList.add(className$m('r'));
            this.element.appendChild(hrElem);
        }
    }

    class SeparatorController extends BladeController {
        constructor(doc, config) {
            super(Object.assign(Object.assign({}, config), { view: new SeparatorView(doc, {
                    viewProps: config.viewProps,
                }) }));
        }
    }

    const SeparatorBladePlugin = {
        id: 'separator',
        type: 'blade',
        accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
                view: p.required.constant('separator'),
            });
            return result ? { params: result } : null;
        },
        controller(args) {
            return new SeparatorController(args.document, {
                blade: args.blade,
                viewProps: args.viewProps,
            });
        },
        api(args) {
            if (!(args.controller instanceof SeparatorController)) {
                return null;
            }
            return new SeparatorApi(args.controller);
        },
    };

    const className$l = ClassName('tbi');
    class TabItemView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$l());
            config.viewProps.bindClassModifiers(this.element);
            bindValueMap(config.props, 'selected', (selected) => {
                if (selected) {
                    this.element.classList.add(className$l(undefined, 'sel'));
                }
                else {
                    this.element.classList.remove(className$l(undefined, 'sel'));
                }
            });
            const buttonElem = doc.createElement('button');
            buttonElem.classList.add(className$l('b'));
            config.viewProps.bindDisabled(buttonElem);
            this.element.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            const titleElem = doc.createElement('div');
            titleElem.classList.add(className$l('t'));
            bindValueToTextContent(config.props.value('title'), titleElem);
            this.buttonElement.appendChild(titleElem);
            this.titleElement = titleElem;
        }
    }

    class TabItemController {
        constructor(doc, config) {
            this.emitter = new Emitter();
            this.onClick_ = this.onClick_.bind(this);
            this.props = config.props;
            this.viewProps = config.viewProps;
            this.view = new TabItemView(doc, {
                props: config.props,
                viewProps: config.viewProps,
            });
            this.view.buttonElement.addEventListener('click', this.onClick_);
        }
        onClick_() {
            this.emitter.emit('click', {
                sender: this,
            });
        }
    }

    class TabPageController {
        constructor(doc, config) {
            this.onItemClick_ = this.onItemClick_.bind(this);
            this.ic_ = new TabItemController(doc, {
                props: config.itemProps,
                viewProps: ViewProps.create(),
            });
            this.ic_.emitter.on('click', this.onItemClick_);
            this.cc_ = new RackController(doc, {
                blade: createBlade(),
                viewProps: ViewProps.create(),
            });
            this.props = config.props;
            bindValueMap(this.props, 'selected', (selected) => {
                this.itemController.props.set('selected', selected);
                this.contentController.viewProps.set('hidden', !selected);
            });
        }
        get itemController() {
            return this.ic_;
        }
        get contentController() {
            return this.cc_;
        }
        onItemClick_() {
            this.props.set('selected', true);
        }
    }

    class TabPageApi {
        constructor(controller, contentRackApi) {
            this.controller_ = controller;
            this.rackApi_ = contentRackApi;
        }
        get title() {
            var _a;
            return (_a = this.controller_.itemController.props.get('title')) !== null && _a !== void 0 ? _a : '';
        }
        set title(title) {
            this.controller_.itemController.props.set('title', title);
        }
        get selected() {
            return this.controller_.props.get('selected');
        }
        set selected(selected) {
            this.controller_.props.set('selected', selected);
        }
        get children() {
            return this.rackApi_.children;
        }
        addButton(params) {
            return this.rackApi_.addButton(params);
        }
        addFolder(params) {
            return this.rackApi_.addFolder(params);
        }
        addSeparator(opt_params) {
            return this.rackApi_.addSeparator(opt_params);
        }
        addTab(params) {
            return this.rackApi_.addTab(params);
        }
        add(api, opt_index) {
            this.rackApi_.add(api, opt_index);
        }
        remove(api) {
            this.rackApi_.remove(api);
        }
        addInput(object, key, opt_params) {
            return this.rackApi_.addInput(object, key, opt_params);
        }
        addMonitor(object, key, opt_params) {
            return this.rackApi_.addMonitor(object, key, opt_params);
        }
        addBlade(params) {
            return this.rackApi_.addBlade(params);
        }
    }

    class TabApi extends RackLikeApi {
        constructor(controller, pool) {
            super(controller, new RackApi(controller.rackController, pool));
            this.onPageAdd_ = this.onPageAdd_.bind(this);
            this.onPageRemove_ = this.onPageRemove_.bind(this);
            this.onSelect_ = this.onSelect_.bind(this);
            this.emitter_ = new Emitter();
            this.pageApiMap_ = new Map();
            this.rackApi_.on('change', (ev) => {
                this.emitter_.emit('change', {
                    event: ev,
                });
            });
            this.rackApi_.on('update', (ev) => {
                this.emitter_.emit('update', {
                    event: ev,
                });
            });
            this.controller_.tab.selectedIndex.emitter.on('change', this.onSelect_);
            this.controller_.pageSet.emitter.on('add', this.onPageAdd_);
            this.controller_.pageSet.emitter.on('remove', this.onPageRemove_);
            this.controller_.pageSet.items.forEach((pc) => {
                this.setUpPageApi_(pc);
            });
        }
        get pages() {
            return this.controller_.pageSet.items.map((pc) => {
                const api = this.pageApiMap_.get(pc);
                if (!api) {
                    throw TpError.shouldNeverHappen();
                }
                return api;
            });
        }
        addPage(params) {
            const doc = this.controller_.view.element.ownerDocument;
            const pc = new TabPageController(doc, {
                itemProps: ValueMap.fromObject({
                    selected: false,
                    title: params.title,
                }),
                props: ValueMap.fromObject({
                    selected: false,
                }),
            });
            this.controller_.add(pc, params.index);
            const api = this.pageApiMap_.get(pc);
            if (!api) {
                throw TpError.shouldNeverHappen();
            }
            return api;
        }
        removePage(index) {
            this.controller_.remove(index);
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
        setUpPageApi_(pc) {
            const rackApi = this.rackApi_['apiSet_'].find((api) => api.controller_ === pc.contentController);
            if (!rackApi) {
                throw TpError.shouldNeverHappen();
            }
            const api = new TabPageApi(pc, rackApi);
            this.pageApiMap_.set(pc, api);
        }
        onPageAdd_(ev) {
            this.setUpPageApi_(ev.item);
        }
        onPageRemove_(ev) {
            const api = this.pageApiMap_.get(ev.item);
            if (!api) {
                throw TpError.shouldNeverHappen();
            }
            this.pageApiMap_.delete(ev.item);
        }
        onSelect_(ev) {
            this.emitter_.emit('select', {
                event: new TpTabSelectEvent(this, ev.rawValue),
            });
        }
    }

    const INDEX_NOT_SELECTED = -1;
    class Tab {
        constructor() {
            this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
            this.empty = createValue(true);
            this.selectedIndex = createValue(INDEX_NOT_SELECTED);
            this.items_ = [];
        }
        add(item, opt_index) {
            const index = opt_index !== null && opt_index !== void 0 ? opt_index : this.items_.length;
            this.items_.splice(index, 0, item);
            item.emitter.on('change', this.onItemSelectedChange_);
            this.keepSelection_();
        }
        remove(item) {
            const index = this.items_.indexOf(item);
            if (index < 0) {
                return;
            }
            this.items_.splice(index, 1);
            item.emitter.off('change', this.onItemSelectedChange_);
            this.keepSelection_();
        }
        keepSelection_() {
            if (this.items_.length === 0) {
                this.selectedIndex.rawValue = INDEX_NOT_SELECTED;
                this.empty.rawValue = true;
                return;
            }
            const firstSelIndex = this.items_.findIndex((s) => s.rawValue);
            if (firstSelIndex < 0) {
                this.items_.forEach((s, i) => {
                    s.rawValue = i === 0;
                });
                this.selectedIndex.rawValue = 0;
            }
            else {
                this.items_.forEach((s, i) => {
                    s.rawValue = i === firstSelIndex;
                });
                this.selectedIndex.rawValue = firstSelIndex;
            }
            this.empty.rawValue = false;
        }
        onItemSelectedChange_(ev) {
            if (ev.rawValue) {
                const index = this.items_.findIndex((s) => s === ev.sender);
                this.items_.forEach((s, i) => {
                    s.rawValue = i === index;
                });
                this.selectedIndex.rawValue = index;
            }
            else {
                this.keepSelection_();
            }
        }
    }

    const className$k = ClassName('tab');
    class TabView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$k(), bladeContainerClassName());
            config.viewProps.bindClassModifiers(this.element);
            bindValue(config.empty, valueToClassName(this.element, className$k(undefined, 'nop')));
            const titleElem = doc.createElement('div');
            titleElem.classList.add(className$k('t'));
            this.element.appendChild(titleElem);
            this.itemsElement = titleElem;
            const indentElem = doc.createElement('div');
            indentElem.classList.add(className$k('i'));
            this.element.appendChild(indentElem);
            const contentsElem = config.contentsElement;
            contentsElem.classList.add(className$k('c'));
            this.element.appendChild(contentsElem);
            this.contentsElement = contentsElem;
        }
    }

    class TabController extends RackLikeController {
        constructor(doc, config) {
            const cr = new RackController(doc, {
                blade: config.blade,
                viewProps: config.viewProps,
            });
            const tab = new Tab();
            super({
                blade: config.blade,
                rackController: cr,
                view: new TabView(doc, {
                    contentsElement: cr.view.element,
                    empty: tab.empty,
                    viewProps: config.viewProps,
                }),
            });
            this.onPageAdd_ = this.onPageAdd_.bind(this);
            this.onPageRemove_ = this.onPageRemove_.bind(this);
            this.pageSet_ = new NestedOrderedSet(() => null);
            this.pageSet_.emitter.on('add', this.onPageAdd_);
            this.pageSet_.emitter.on('remove', this.onPageRemove_);
            this.tab = tab;
        }
        get pageSet() {
            return this.pageSet_;
        }
        add(pc, opt_index) {
            this.pageSet_.add(pc, opt_index);
        }
        remove(index) {
            this.pageSet_.remove(this.pageSet_.items[index]);
        }
        onPageAdd_(ev) {
            const pc = ev.item;
            insertElementAt(this.view.itemsElement, pc.itemController.view.element, ev.index);
            pc.itemController.viewProps.set('parent', this.viewProps);
            this.rackController.rack.add(pc.contentController, ev.index);
            this.tab.add(pc.props.value('selected'));
        }
        onPageRemove_(ev) {
            const pc = ev.item;
            removeElement(pc.itemController.view.element);
            pc.itemController.viewProps.set('parent', null);
            this.rackController.rack.remove(pc.contentController);
            this.tab.remove(pc.props.value('selected'));
        }
    }

    const TabBladePlugin = {
        id: 'tab',
        type: 'blade',
        accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
                pages: p.required.array(p.required.object({ title: p.required.string })),
                view: p.required.constant('tab'),
            });
            if (!result || result.pages.length === 0) {
                return null;
            }
            return { params: result };
        },
        controller(args) {
            const c = new TabController(args.document, {
                blade: args.blade,
                viewProps: args.viewProps,
            });
            args.params.pages.forEach((p) => {
                const pc = new TabPageController(args.document, {
                    itemProps: ValueMap.fromObject({
                        selected: false,
                        title: p.title,
                    }),
                    props: ValueMap.fromObject({
                        selected: false,
                    }),
                });
                c.add(pc);
            });
            return c;
        },
        api(args) {
            if (!(args.controller instanceof TabController)) {
                return null;
            }
            return new TabApi(args.controller, args.pool);
        },
    };

    function createBladeController(plugin, args) {
        const ac = plugin.accept(args.params);
        if (!ac) {
            return null;
        }
        const disabled = ParamsParsers.optional.boolean(args.params['disabled']).value;
        const hidden = ParamsParsers.optional.boolean(args.params['hidden']).value;
        return plugin.controller({
            blade: createBlade(),
            document: args.document,
            params: forceCast(Object.assign(Object.assign({}, ac.params), { disabled: disabled, hidden: hidden })),
            viewProps: ViewProps.create({
                disabled: disabled,
                hidden: hidden,
            }),
        });
    }

    class ManualTicker {
        constructor() {
            this.disabled = false;
            this.emitter = new Emitter();
        }
        dispose() { }
        tick() {
            if (this.disabled) {
                return;
            }
            this.emitter.emit('tick', {
                sender: this,
            });
        }
    }

    class IntervalTicker {
        constructor(doc, interval) {
            this.disabled_ = false;
            this.timerId_ = null;
            this.onTick_ = this.onTick_.bind(this);
            this.doc_ = doc;
            this.emitter = new Emitter();
            this.interval_ = interval;
            this.setTimer_();
        }
        get disabled() {
            return this.disabled_;
        }
        set disabled(inactive) {
            this.disabled_ = inactive;
            if (this.disabled_) {
                this.clearTimer_();
            }
            else {
                this.setTimer_();
            }
        }
        dispose() {
            this.clearTimer_();
        }
        clearTimer_() {
            if (this.timerId_ === null) {
                return;
            }
            const win = this.doc_.defaultView;
            if (win) {
                win.clearInterval(this.timerId_);
            }
            this.timerId_ = null;
        }
        setTimer_() {
            this.clearTimer_();
            if (this.interval_ <= 0) {
                return;
            }
            const win = this.doc_.defaultView;
            if (win) {
                this.timerId_ = win.setInterval(this.onTick_, this.interval_);
            }
        }
        onTick_() {
            if (this.disabled_) {
                return;
            }
            this.emitter.emit('tick', {
                sender: this,
            });
        }
    }

    class InputBinding {
        constructor(config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.reader = config.reader;
            this.writer = config.writer;
            this.emitter = new Emitter();
            this.value = config.value;
            this.value.emitter.on('change', this.onValueChange_);
            this.target = config.target;
            this.read();
        }
        read() {
            const targetValue = this.target.read();
            if (targetValue !== undefined) {
                this.value.rawValue = this.reader(targetValue);
            }
        }
        write_(rawValue) {
            this.writer(this.target, rawValue);
        }
        onValueChange_(ev) {
            this.write_(ev.rawValue);
            this.emitter.emit('change', {
                options: ev.options,
                rawValue: ev.rawValue,
                sender: this,
            });
        }
    }

    function fillBuffer(buffer, bufferSize) {
        while (buffer.length < bufferSize) {
            buffer.push(undefined);
        }
    }
    function initializeBuffer(bufferSize) {
        const buffer = [];
        fillBuffer(buffer, bufferSize);
        return createValue(buffer);
    }
    function createTrimmedBuffer(buffer) {
        const index = buffer.indexOf(undefined);
        return forceCast(index < 0 ? buffer : buffer.slice(0, index));
    }
    function createPushedBuffer(buffer, newValue) {
        const newBuffer = [...createTrimmedBuffer(buffer), newValue];
        if (newBuffer.length > buffer.length) {
            newBuffer.splice(0, newBuffer.length - buffer.length);
        }
        else {
            fillBuffer(newBuffer, buffer.length);
        }
        return newBuffer;
    }

    class MonitorBinding {
        constructor(config) {
            this.onTick_ = this.onTick_.bind(this);
            this.reader_ = config.reader;
            this.target = config.target;
            this.emitter = new Emitter();
            this.value = config.value;
            this.ticker = config.ticker;
            this.ticker.emitter.on('tick', this.onTick_);
            this.read();
        }
        dispose() {
            this.ticker.dispose();
        }
        read() {
            const targetValue = this.target.read();
            if (targetValue === undefined) {
                return;
            }
            const buffer = this.value.rawValue;
            const newValue = this.reader_(targetValue);
            this.value.rawValue = createPushedBuffer(buffer, newValue);
            this.emitter.emit('update', {
                rawValue: newValue,
                sender: this,
            });
        }
        onTick_(_) {
            this.read();
        }
    }

    class CompositeConstraint {
        constructor(constraints) {
            this.constraints = constraints;
        }
        constrain(value) {
            return this.constraints.reduce((result, c) => {
                return c.constrain(result);
            }, value);
        }
    }
    function findConstraint(c, constraintClass) {
        if (c instanceof constraintClass) {
            return c;
        }
        if (c instanceof CompositeConstraint) {
            const result = c.constraints.reduce((tmpResult, sc) => {
                if (tmpResult) {
                    return tmpResult;
                }
                return sc instanceof constraintClass ? sc : null;
            }, null);
            if (result) {
                return result;
            }
        }
        return null;
    }

    class DefiniteRangeConstraint {
        constructor(config) {
            this.values = ValueMap.fromObject({
                max: config.max,
                min: config.min,
            });
        }
        constrain(value) {
            const max = this.values.get('max');
            const min = this.values.get('min');
            return Math.min(Math.max(value, min), max);
        }
    }

    class ListConstraint {
        constructor(options) {
            this.values = ValueMap.fromObject({
                options: options,
            });
        }
        get options() {
            return this.values.get('options');
        }
        constrain(value) {
            const opts = this.values.get('options');
            if (opts.length === 0) {
                return value;
            }
            const matched = opts.filter((item) => {
                return item.value === value;
            }).length > 0;
            return matched ? value : opts[0].value;
        }
    }

    class RangeConstraint {
        constructor(config) {
            this.values = ValueMap.fromObject({
                max: config.max,
                min: config.min,
            });
        }
        get maxValue() {
            return this.values.get('max');
        }
        get minValue() {
            return this.values.get('min');
        }
        constrain(value) {
            const max = this.values.get('max');
            const min = this.values.get('min');
            let result = value;
            if (!isEmpty(min)) {
                result = Math.max(result, min);
            }
            if (!isEmpty(max)) {
                result = Math.min(result, max);
            }
            return result;
        }
    }

    class StepConstraint {
        constructor(step, origin = 0) {
            this.step = step;
            this.origin = origin;
        }
        constrain(value) {
            const o = this.origin % this.step;
            const r = Math.round((value - o) / this.step);
            return o + r * this.step;
        }
    }

    const className$j = ClassName('lst');
    class ListView {
        constructor(doc, config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.props_ = config.props;
            this.element = doc.createElement('div');
            this.element.classList.add(className$j());
            config.viewProps.bindClassModifiers(this.element);
            const selectElem = doc.createElement('select');
            selectElem.classList.add(className$j('s'));
            bindValueMap(this.props_, 'options', (opts) => {
                removeChildElements(selectElem);
                opts.forEach((item, index) => {
                    const optionElem = doc.createElement('option');
                    optionElem.dataset.index = String(index);
                    optionElem.textContent = item.text;
                    optionElem.value = String(item.value);
                    selectElem.appendChild(optionElem);
                });
            });
            config.viewProps.bindDisabled(selectElem);
            this.element.appendChild(selectElem);
            this.selectElement = selectElem;
            const markElem = doc.createElement('div');
            markElem.classList.add(className$j('m'));
            markElem.appendChild(createSvgIconElement(doc, 'dropdown'));
            this.element.appendChild(markElem);
            config.value.emitter.on('change', this.onValueChange_);
            this.value_ = config.value;
            this.update_();
        }
        update_() {
            this.selectElement.value = String(this.value_.rawValue);
        }
        onValueChange_() {
            this.update_();
        }
    }

    class ListController {
        constructor(doc, config) {
            this.onSelectChange_ = this.onSelectChange_.bind(this);
            this.props = config.props;
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new ListView(doc, {
                props: this.props,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view.selectElement.addEventListener('change', this.onSelectChange_);
        }
        onSelectChange_(e) {
            const selectElem = forceCast(e.currentTarget);
            const optElem = selectElem.selectedOptions.item(0);
            if (!optElem) {
                return;
            }
            const itemIndex = Number(optElem.dataset.index);
            this.value.rawValue = this.props.get('options')[itemIndex].value;
        }
    }

    const className$i = ClassName('pop');
    class PopupView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$i());
            config.viewProps.bindClassModifiers(this.element);
            bindValue(config.shows, valueToClassName(this.element, className$i(undefined, 'v')));
        }
    }

    class PopupController {
        constructor(doc, config) {
            this.shows = createValue(false);
            this.viewProps = config.viewProps;
            this.view = new PopupView(doc, {
                shows: this.shows,
                viewProps: this.viewProps,
            });
        }
    }

    const className$h = ClassName('txt');
    class TextView {
        constructor(doc, config) {
            this.onChange_ = this.onChange_.bind(this);
            this.element = doc.createElement('div');
            this.element.classList.add(className$h());
            config.viewProps.bindClassModifiers(this.element);
            this.props_ = config.props;
            this.props_.emitter.on('change', this.onChange_);
            const inputElem = doc.createElement('input');
            inputElem.classList.add(className$h('i'));
            inputElem.type = 'text';
            config.viewProps.bindDisabled(inputElem);
            this.element.appendChild(inputElem);
            this.inputElement = inputElem;
            config.value.emitter.on('change', this.onChange_);
            this.value_ = config.value;
            this.refresh();
        }
        refresh() {
            const formatter = this.props_.get('formatter');
            this.inputElement.value = formatter(this.value_.rawValue);
        }
        onChange_() {
            this.refresh();
        }
    }

    class TextController {
        constructor(doc, config) {
            this.onInputChange_ = this.onInputChange_.bind(this);
            this.parser_ = config.parser;
            this.props = config.props;
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new TextView(doc, {
                props: config.props,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view.inputElement.addEventListener('change', this.onInputChange_);
        }
        onInputChange_(e) {
            const inputElem = forceCast(e.currentTarget);
            const value = inputElem.value;
            const parsedValue = this.parser_(value);
            if (!isEmpty(parsedValue)) {
                this.value.rawValue = parsedValue;
            }
            this.view.refresh();
        }
    }

    function boolToString(value) {
        return String(value);
    }
    function boolFromUnknown(value) {
        if (value === 'false') {
            return false;
        }
        return !!value;
    }
    function BooleanFormatter(value) {
        return boolToString(value);
    }

    class NumberLiteralNode {
        constructor(text) {
            this.text = text;
        }
        evaluate() {
            return Number(this.text);
        }
        toString() {
            return this.text;
        }
    }
    const BINARY_OPERATION_MAP = {
        '**': (v1, v2) => Math.pow(v1, v2),
        '*': (v1, v2) => v1 * v2,
        '/': (v1, v2) => v1 / v2,
        '%': (v1, v2) => v1 % v2,
        '+': (v1, v2) => v1 + v2,
        '-': (v1, v2) => v1 - v2,
        '<<': (v1, v2) => v1 << v2,
        '>>': (v1, v2) => v1 >> v2,
        '>>>': (v1, v2) => v1 >>> v2,
        '&': (v1, v2) => v1 & v2,
        '^': (v1, v2) => v1 ^ v2,
        '|': (v1, v2) => v1 | v2,
    };
    class BinaryOperationNode {
        constructor(operator, left, right) {
            this.left = left;
            this.operator = operator;
            this.right = right;
        }
        evaluate() {
            const op = BINARY_OPERATION_MAP[this.operator];
            if (!op) {
                throw new Error(`unexpected binary operator: '${this.operator}`);
            }
            return op(this.left.evaluate(), this.right.evaluate());
        }
        toString() {
            return [
                'b(',
                this.left.toString(),
                this.operator,
                this.right.toString(),
                ')',
            ].join(' ');
        }
    }
    const UNARY_OPERATION_MAP = {
        '+': (v) => v,
        '-': (v) => -v,
        '~': (v) => ~v,
    };
    class UnaryOperationNode {
        constructor(operator, expr) {
            this.operator = operator;
            this.expression = expr;
        }
        evaluate() {
            const op = UNARY_OPERATION_MAP[this.operator];
            if (!op) {
                throw new Error(`unexpected unary operator: '${this.operator}`);
            }
            return op(this.expression.evaluate());
        }
        toString() {
            return ['u(', this.operator, this.expression.toString(), ')'].join(' ');
        }
    }

    function combineReader(parsers) {
        return (text, cursor) => {
            for (let i = 0; i < parsers.length; i++) {
                const result = parsers[i](text, cursor);
                if (result !== '') {
                    return result;
                }
            }
            return '';
        };
    }
    function readWhitespace(text, cursor) {
        var _a;
        const m = text.substr(cursor).match(/^\s+/);
        return (_a = (m && m[0])) !== null && _a !== void 0 ? _a : '';
    }
    function readNonZeroDigit(text, cursor) {
        const ch = text.substr(cursor, 1);
        return ch.match(/^[1-9]$/) ? ch : '';
    }
    function readDecimalDigits(text, cursor) {
        var _a;
        const m = text.substr(cursor).match(/^[0-9]+/);
        return (_a = (m && m[0])) !== null && _a !== void 0 ? _a : '';
    }
    function readSignedInteger(text, cursor) {
        const ds = readDecimalDigits(text, cursor);
        if (ds !== '') {
            return ds;
        }
        const sign = text.substr(cursor, 1);
        cursor += 1;
        if (sign !== '-' && sign !== '+') {
            return '';
        }
        const sds = readDecimalDigits(text, cursor);
        if (sds === '') {
            return '';
        }
        return sign + sds;
    }
    function readExponentPart(text, cursor) {
        const e = text.substr(cursor, 1);
        cursor += 1;
        if (e.toLowerCase() !== 'e') {
            return '';
        }
        const si = readSignedInteger(text, cursor);
        if (si === '') {
            return '';
        }
        return e + si;
    }
    function readDecimalIntegerLiteral(text, cursor) {
        const ch = text.substr(cursor, 1);
        if (ch === '0') {
            return ch;
        }
        const nzd = readNonZeroDigit(text, cursor);
        cursor += nzd.length;
        if (nzd === '') {
            return '';
        }
        return nzd + readDecimalDigits(text, cursor);
    }
    function readDecimalLiteral1(text, cursor) {
        const dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;
        if (dil === '') {
            return '';
        }
        const dot = text.substr(cursor, 1);
        cursor += dot.length;
        if (dot !== '.') {
            return '';
        }
        const dds = readDecimalDigits(text, cursor);
        cursor += dds.length;
        return dil + dot + dds + readExponentPart(text, cursor);
    }
    function readDecimalLiteral2(text, cursor) {
        const dot = text.substr(cursor, 1);
        cursor += dot.length;
        if (dot !== '.') {
            return '';
        }
        const dds = readDecimalDigits(text, cursor);
        cursor += dds.length;
        if (dds === '') {
            return '';
        }
        return dot + dds + readExponentPart(text, cursor);
    }
    function readDecimalLiteral3(text, cursor) {
        const dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;
        if (dil === '') {
            return '';
        }
        return dil + readExponentPart(text, cursor);
    }
    const readDecimalLiteral = combineReader([
        readDecimalLiteral1,
        readDecimalLiteral2,
        readDecimalLiteral3,
    ]);
    function parseBinaryDigits(text, cursor) {
        var _a;
        const m = text.substr(cursor).match(/^[01]+/);
        return (_a = (m && m[0])) !== null && _a !== void 0 ? _a : '';
    }
    function readBinaryIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== '0b') {
            return '';
        }
        const bds = parseBinaryDigits(text, cursor);
        if (bds === '') {
            return '';
        }
        return prefix + bds;
    }
    function readOctalDigits(text, cursor) {
        var _a;
        const m = text.substr(cursor).match(/^[0-7]+/);
        return (_a = (m && m[0])) !== null && _a !== void 0 ? _a : '';
    }
    function readOctalIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== '0o') {
            return '';
        }
        const ods = readOctalDigits(text, cursor);
        if (ods === '') {
            return '';
        }
        return prefix + ods;
    }
    function readHexDigits(text, cursor) {
        var _a;
        const m = text.substr(cursor).match(/^[0-9a-f]+/i);
        return (_a = (m && m[0])) !== null && _a !== void 0 ? _a : '';
    }
    function readHexIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== '0x') {
            return '';
        }
        const hds = readHexDigits(text, cursor);
        if (hds === '') {
            return '';
        }
        return prefix + hds;
    }
    const readNonDecimalIntegerLiteral = combineReader([
        readBinaryIntegerLiteral,
        readOctalIntegerLiteral,
        readHexIntegerLiteral,
    ]);
    const readNumericLiteral = combineReader([
        readNonDecimalIntegerLiteral,
        readDecimalLiteral,
    ]);

    function parseLiteral(text, cursor) {
        const num = readNumericLiteral(text, cursor);
        cursor += num.length;
        if (num === '') {
            return null;
        }
        return {
            evaluable: new NumberLiteralNode(num),
            cursor: cursor,
        };
    }
    function parseParenthesizedExpression(text, cursor) {
        const op = text.substr(cursor, 1);
        cursor += op.length;
        if (op !== '(') {
            return null;
        }
        const expr = parseExpression(text, cursor);
        if (!expr) {
            return null;
        }
        cursor = expr.cursor;
        cursor += readWhitespace(text, cursor).length;
        const cl = text.substr(cursor, 1);
        cursor += cl.length;
        if (cl !== ')') {
            return null;
        }
        return {
            evaluable: expr.evaluable,
            cursor: cursor,
        };
    }
    function parsePrimaryExpression(text, cursor) {
        var _a;
        return ((_a = parseLiteral(text, cursor)) !== null && _a !== void 0 ? _a : parseParenthesizedExpression(text, cursor));
    }
    function parseUnaryExpression(text, cursor) {
        const expr = parsePrimaryExpression(text, cursor);
        if (expr) {
            return expr;
        }
        const op = text.substr(cursor, 1);
        cursor += op.length;
        if (op !== '+' && op !== '-' && op !== '~') {
            return null;
        }
        const num = parseUnaryExpression(text, cursor);
        if (!num) {
            return null;
        }
        cursor = num.cursor;
        return {
            cursor: cursor,
            evaluable: new UnaryOperationNode(op, num.evaluable),
        };
    }
    function readBinaryOperator(ops, text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        const op = ops.filter((op) => text.startsWith(op, cursor))[0];
        if (!op) {
            return null;
        }
        cursor += op.length;
        cursor += readWhitespace(text, cursor).length;
        return {
            cursor: cursor,
            operator: op,
        };
    }
    function createBinaryOperationExpressionParser(exprParser, ops) {
        return (text, cursor) => {
            const firstExpr = exprParser(text, cursor);
            if (!firstExpr) {
                return null;
            }
            cursor = firstExpr.cursor;
            let expr = firstExpr.evaluable;
            for (;;) {
                const op = readBinaryOperator(ops, text, cursor);
                if (!op) {
                    break;
                }
                cursor = op.cursor;
                const nextExpr = exprParser(text, cursor);
                if (!nextExpr) {
                    return null;
                }
                cursor = nextExpr.cursor;
                expr = new BinaryOperationNode(op.operator, expr, nextExpr.evaluable);
            }
            return expr
                ? {
                    cursor: cursor,
                    evaluable: expr,
                }
                : null;
        };
    }
    const parseBinaryOperationExpression = [
        ['**'],
        ['*', '/', '%'],
        ['+', '-'],
        ['<<', '>>>', '>>'],
        ['&'],
        ['^'],
        ['|'],
    ].reduce((parser, ops) => {
        return createBinaryOperationExpressionParser(parser, ops);
    }, parseUnaryExpression);
    function parseExpression(text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        return parseBinaryOperationExpression(text, cursor);
    }
    function parseEcmaNumberExpression(text) {
        const expr = parseExpression(text, 0);
        if (!expr) {
            return null;
        }
        const cursor = expr.cursor + readWhitespace(text, expr.cursor).length;
        if (cursor !== text.length) {
            return null;
        }
        return expr.evaluable;
    }

    function parseNumber(text) {
        var _a;
        const r = parseEcmaNumberExpression(text);
        return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null && _a !== void 0 ? _a : null;
    }
    function numberFromUnknown(value) {
        if (typeof value === 'number') {
            return value;
        }
        if (typeof value === 'string') {
            const pv = parseNumber(value);
            if (!isEmpty(pv)) {
                return pv;
            }
        }
        return 0;
    }
    function numberToString(value) {
        return String(value);
    }
    function createNumberFormatter(digits) {
        return (value) => {
            return value.toFixed(Math.max(Math.min(digits, 20), 0));
        };
    }

    const innerFormatter = createNumberFormatter(0);
    function formatPercentage(value) {
        return innerFormatter(value) + '%';
    }

    function stringFromUnknown(value) {
        return String(value);
    }
    function formatString(value) {
        return value;
    }

    function connectValues({ primary, secondary, forward, backward, }) {
        let changing = false;
        function preventFeedback(callback) {
            if (changing) {
                return;
            }
            changing = true;
            callback();
            changing = false;
        }
        primary.emitter.on('change', (ev) => {
            preventFeedback(() => {
                secondary.setRawValue(forward(primary, secondary), ev.options);
            });
        });
        secondary.emitter.on('change', (ev) => {
            preventFeedback(() => {
                primary.setRawValue(backward(primary, secondary), ev.options);
            });
            preventFeedback(() => {
                secondary.setRawValue(forward(primary, secondary), ev.options);
            });
        });
        preventFeedback(() => {
            secondary.setRawValue(forward(primary, secondary), {
                forceEmit: false,
                last: true,
            });
        });
    }

    function getStepForKey(baseStep, keys) {
        const step = baseStep * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
        if (keys.upKey) {
            return +step;
        }
        else if (keys.downKey) {
            return -step;
        }
        return 0;
    }
    function getVerticalStepKeys(ev) {
        return {
            altKey: ev.altKey,
            downKey: ev.key === 'ArrowDown',
            shiftKey: ev.shiftKey,
            upKey: ev.key === 'ArrowUp',
        };
    }
    function getHorizontalStepKeys(ev) {
        return {
            altKey: ev.altKey,
            downKey: ev.key === 'ArrowLeft',
            shiftKey: ev.shiftKey,
            upKey: ev.key === 'ArrowRight',
        };
    }
    function isVerticalArrowKey(key) {
        return key === 'ArrowUp' || key === 'ArrowDown';
    }
    function isArrowKey(key) {
        return isVerticalArrowKey(key) || key === 'ArrowLeft' || key === 'ArrowRight';
    }

    function computeOffset$1(ev, elem) {
        var _a, _b;
        const win = elem.ownerDocument.defaultView;
        const rect = elem.getBoundingClientRect();
        return {
            x: ev.pageX - (((_a = (win && win.scrollX)) !== null && _a !== void 0 ? _a : 0) + rect.left),
            y: ev.pageY - (((_b = (win && win.scrollY)) !== null && _b !== void 0 ? _b : 0) + rect.top),
        };
    }
    class PointerHandler {
        constructor(element) {
            this.lastTouch_ = null;
            this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
            this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
            this.onMouseDown_ = this.onMouseDown_.bind(this);
            this.onTouchEnd_ = this.onTouchEnd_.bind(this);
            this.onTouchMove_ = this.onTouchMove_.bind(this);
            this.onTouchStart_ = this.onTouchStart_.bind(this);
            this.elem_ = element;
            this.emitter = new Emitter();
            element.addEventListener('touchstart', this.onTouchStart_, {
                passive: false,
            });
            element.addEventListener('touchmove', this.onTouchMove_, {
                passive: true,
            });
            element.addEventListener('touchend', this.onTouchEnd_);
            element.addEventListener('mousedown', this.onMouseDown_);
        }
        computePosition_(offset) {
            const rect = this.elem_.getBoundingClientRect();
            return {
                bounds: {
                    width: rect.width,
                    height: rect.height,
                },
                point: offset
                    ? {
                        x: offset.x,
                        y: offset.y,
                    }
                    : null,
            };
        }
        onMouseDown_(ev) {
            var _a;
            ev.preventDefault();
            (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
            const doc = this.elem_.ownerDocument;
            doc.addEventListener('mousemove', this.onDocumentMouseMove_);
            doc.addEventListener('mouseup', this.onDocumentMouseUp_);
            this.emitter.emit('down', {
                altKey: ev.altKey,
                data: this.computePosition_(computeOffset$1(ev, this.elem_)),
                sender: this,
                shiftKey: ev.shiftKey,
            });
        }
        onDocumentMouseMove_(ev) {
            this.emitter.emit('move', {
                altKey: ev.altKey,
                data: this.computePosition_(computeOffset$1(ev, this.elem_)),
                sender: this,
                shiftKey: ev.shiftKey,
            });
        }
        onDocumentMouseUp_(ev) {
            const doc = this.elem_.ownerDocument;
            doc.removeEventListener('mousemove', this.onDocumentMouseMove_);
            doc.removeEventListener('mouseup', this.onDocumentMouseUp_);
            this.emitter.emit('up', {
                altKey: ev.altKey,
                data: this.computePosition_(computeOffset$1(ev, this.elem_)),
                sender: this,
                shiftKey: ev.shiftKey,
            });
        }
        onTouchStart_(ev) {
            ev.preventDefault();
            const touch = ev.targetTouches.item(0);
            const rect = this.elem_.getBoundingClientRect();
            this.emitter.emit('down', {
                altKey: ev.altKey,
                data: this.computePosition_(touch
                    ? {
                        x: touch.clientX - rect.left,
                        y: touch.clientY - rect.top,
                    }
                    : undefined),
                sender: this,
                shiftKey: ev.shiftKey,
            });
            this.lastTouch_ = touch;
        }
        onTouchMove_(ev) {
            const touch = ev.targetTouches.item(0);
            const rect = this.elem_.getBoundingClientRect();
            this.emitter.emit('move', {
                altKey: ev.altKey,
                data: this.computePosition_(touch
                    ? {
                        x: touch.clientX - rect.left,
                        y: touch.clientY - rect.top,
                    }
                    : undefined),
                sender: this,
                shiftKey: ev.shiftKey,
            });
            this.lastTouch_ = touch;
        }
        onTouchEnd_(ev) {
            var _a;
            const touch = (_a = ev.targetTouches.item(0)) !== null && _a !== void 0 ? _a : this.lastTouch_;
            const rect = this.elem_.getBoundingClientRect();
            this.emitter.emit('up', {
                altKey: ev.altKey,
                data: this.computePosition_(touch
                    ? {
                        x: touch.clientX - rect.left,
                        y: touch.clientY - rect.top,
                    }
                    : undefined),
                sender: this,
                shiftKey: ev.shiftKey,
            });
        }
    }

    function mapRange(value, start1, end1, start2, end2) {
        const p = (value - start1) / (end1 - start1);
        return start2 + p * (end2 - start2);
    }
    function getDecimalDigits(value) {
        const text = String(value.toFixed(10));
        const frac = text.split('.')[1];
        return frac.replace(/0+$/, '').length;
    }
    function constrainRange(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }
    function loopRange(value, max) {
        return ((value % max) + max) % max;
    }

    const className$g = ClassName('txt');
    class NumberTextView {
        constructor(doc, config) {
            this.onChange_ = this.onChange_.bind(this);
            this.props_ = config.props;
            this.props_.emitter.on('change', this.onChange_);
            this.element = doc.createElement('div');
            this.element.classList.add(className$g(), className$g(undefined, 'num'));
            if (config.arrayPosition) {
                this.element.classList.add(className$g(undefined, config.arrayPosition));
            }
            config.viewProps.bindClassModifiers(this.element);
            const inputElem = doc.createElement('input');
            inputElem.classList.add(className$g('i'));
            inputElem.type = 'text';
            config.viewProps.bindDisabled(inputElem);
            this.element.appendChild(inputElem);
            this.inputElement = inputElem;
            this.onDraggingChange_ = this.onDraggingChange_.bind(this);
            this.dragging_ = config.dragging;
            this.dragging_.emitter.on('change', this.onDraggingChange_);
            this.element.classList.add(className$g());
            this.inputElement.classList.add(className$g('i'));
            const knobElem = doc.createElement('div');
            knobElem.classList.add(className$g('k'));
            this.element.appendChild(knobElem);
            this.knobElement = knobElem;
            const guideElem = doc.createElementNS(SVG_NS, 'svg');
            guideElem.classList.add(className$g('g'));
            this.knobElement.appendChild(guideElem);
            const bodyElem = doc.createElementNS(SVG_NS, 'path');
            bodyElem.classList.add(className$g('gb'));
            guideElem.appendChild(bodyElem);
            this.guideBodyElem_ = bodyElem;
            const headElem = doc.createElementNS(SVG_NS, 'path');
            headElem.classList.add(className$g('gh'));
            guideElem.appendChild(headElem);
            this.guideHeadElem_ = headElem;
            const tooltipElem = doc.createElement('div');
            tooltipElem.classList.add(ClassName('tt')());
            this.knobElement.appendChild(tooltipElem);
            this.tooltipElem_ = tooltipElem;
            config.value.emitter.on('change', this.onChange_);
            this.value = config.value;
            this.refresh();
        }
        onDraggingChange_(ev) {
            if (ev.rawValue === null) {
                this.element.classList.remove(className$g(undefined, 'drg'));
                return;
            }
            this.element.classList.add(className$g(undefined, 'drg'));
            const x = ev.rawValue / this.props_.get('draggingScale');
            const aox = x + (x > 0 ? -1 : x < 0 ? +1 : 0);
            const adx = constrainRange(-aox, -4, +4);
            this.guideHeadElem_.setAttributeNS(null, 'd', [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(' '));
            this.guideBodyElem_.setAttributeNS(null, 'd', `M 0,4 L${x},4`);
            const formatter = this.props_.get('formatter');
            this.tooltipElem_.textContent = formatter(this.value.rawValue);
            this.tooltipElem_.style.left = `${x}px`;
        }
        refresh() {
            const formatter = this.props_.get('formatter');
            this.inputElement.value = formatter(this.value.rawValue);
        }
        onChange_() {
            this.refresh();
        }
    }

    class NumberTextController {
        constructor(doc, config) {
            var _a;
            this.originRawValue_ = 0;
            this.onInputChange_ = this.onInputChange_.bind(this);
            this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
            this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.baseStep_ = config.baseStep;
            this.parser_ = config.parser;
            this.props = config.props;
            this.sliderProps_ = (_a = config.sliderProps) !== null && _a !== void 0 ? _a : null;
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.dragging_ = createValue(null);
            this.view = new NumberTextView(doc, {
                arrayPosition: config.arrayPosition,
                dragging: this.dragging_,
                props: this.props,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view.inputElement.addEventListener('change', this.onInputChange_);
            this.view.inputElement.addEventListener('keydown', this.onInputKeyDown_);
            this.view.inputElement.addEventListener('keyup', this.onInputKeyUp_);
            const ph = new PointerHandler(this.view.knobElement);
            ph.emitter.on('down', this.onPointerDown_);
            ph.emitter.on('move', this.onPointerMove_);
            ph.emitter.on('up', this.onPointerUp_);
        }
        constrainValue_(value) {
            var _a, _b;
            const min = (_a = this.sliderProps_) === null || _a === void 0 ? void 0 : _a.get('minValue');
            const max = (_b = this.sliderProps_) === null || _b === void 0 ? void 0 : _b.get('maxValue');
            let v = value;
            if (min !== undefined) {
                v = Math.max(v, min);
            }
            if (max !== undefined) {
                v = Math.min(v, max);
            }
            return v;
        }
        onInputChange_(e) {
            const inputElem = forceCast(e.currentTarget);
            const value = inputElem.value;
            const parsedValue = this.parser_(value);
            if (!isEmpty(parsedValue)) {
                this.value.rawValue = this.constrainValue_(parsedValue);
            }
            this.view.refresh();
        }
        onInputKeyDown_(ev) {
            const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
            if (step === 0) {
                return;
            }
            this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
                forceEmit: false,
                last: false,
            });
        }
        onInputKeyUp_(ev) {
            const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
            if (step === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true,
            });
        }
        onPointerDown_() {
            this.originRawValue_ = this.value.rawValue;
            this.dragging_.rawValue = 0;
        }
        computeDraggingValue_(data) {
            if (!data.point) {
                return null;
            }
            const dx = data.point.x - data.bounds.width / 2;
            return this.constrainValue_(this.originRawValue_ + dx * this.props.get('draggingScale'));
        }
        onPointerMove_(ev) {
            const v = this.computeDraggingValue_(ev.data);
            if (v === null) {
                return;
            }
            this.value.setRawValue(v, {
                forceEmit: false,
                last: false,
            });
            this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
        }
        onPointerUp_(ev) {
            const v = this.computeDraggingValue_(ev.data);
            if (v === null) {
                return;
            }
            this.value.setRawValue(v, {
                forceEmit: true,
                last: true,
            });
            this.dragging_.rawValue = null;
        }
    }

    const className$f = ClassName('sld');
    class SliderView {
        constructor(doc, config) {
            this.onChange_ = this.onChange_.bind(this);
            this.props_ = config.props;
            this.props_.emitter.on('change', this.onChange_);
            this.element = doc.createElement('div');
            this.element.classList.add(className$f());
            config.viewProps.bindClassModifiers(this.element);
            const trackElem = doc.createElement('div');
            trackElem.classList.add(className$f('t'));
            config.viewProps.bindTabIndex(trackElem);
            this.element.appendChild(trackElem);
            this.trackElement = trackElem;
            const knobElem = doc.createElement('div');
            knobElem.classList.add(className$f('k'));
            this.trackElement.appendChild(knobElem);
            this.knobElement = knobElem;
            config.value.emitter.on('change', this.onChange_);
            this.value = config.value;
            this.update_();
        }
        update_() {
            const p = constrainRange(mapRange(this.value.rawValue, this.props_.get('minValue'), this.props_.get('maxValue'), 0, 100), 0, 100);
            this.knobElement.style.width = `${p}%`;
        }
        onChange_() {
            this.update_();
        }
    }

    class SliderController {
        constructor(doc, config) {
            this.onKeyDown_ = this.onKeyDown_.bind(this);
            this.onKeyUp_ = this.onKeyUp_.bind(this);
            this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.baseStep_ = config.baseStep;
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.props = config.props;
            this.view = new SliderView(doc, {
                props: this.props,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.ptHandler_ = new PointerHandler(this.view.trackElement);
            this.ptHandler_.emitter.on('down', this.onPointerDownOrMove_);
            this.ptHandler_.emitter.on('move', this.onPointerDownOrMove_);
            this.ptHandler_.emitter.on('up', this.onPointerUp_);
            this.view.trackElement.addEventListener('keydown', this.onKeyDown_);
            this.view.trackElement.addEventListener('keyup', this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
            if (!d.point) {
                return;
            }
            this.value.setRawValue(mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, this.props.get('minValue'), this.props.get('maxValue')), opts);
        }
        onPointerDownOrMove_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true,
            });
        }
        onKeyDown_(ev) {
            const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
            if (step === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue + step, {
                forceEmit: false,
                last: false,
            });
        }
        onKeyUp_(ev) {
            const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
            if (step === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true,
            });
        }
    }

    const className$e = ClassName('sldtxt');
    class SliderTextView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$e());
            const sliderElem = doc.createElement('div');
            sliderElem.classList.add(className$e('s'));
            this.sliderView_ = config.sliderView;
            sliderElem.appendChild(this.sliderView_.element);
            this.element.appendChild(sliderElem);
            const textElem = doc.createElement('div');
            textElem.classList.add(className$e('t'));
            this.textView_ = config.textView;
            textElem.appendChild(this.textView_.element);
            this.element.appendChild(textElem);
        }
    }

    class SliderTextController {
        constructor(doc, config) {
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.sliderC_ = new SliderController(doc, {
                baseStep: config.baseStep,
                props: config.sliderProps,
                value: config.value,
                viewProps: this.viewProps,
            });
            this.textC_ = new NumberTextController(doc, {
                baseStep: config.baseStep,
                parser: config.parser,
                props: config.textProps,
                sliderProps: config.sliderProps,
                value: config.value,
                viewProps: config.viewProps,
            });
            this.view = new SliderTextView(doc, {
                sliderView: this.sliderC_.view,
                textView: this.textC_.view,
            });
        }
        get sliderController() {
            return this.sliderC_;
        }
        get textController() {
            return this.textC_;
        }
    }

    function writePrimitive(target, value) {
        target.write(value);
    }

    function parseListOptions(value) {
        const p = ParamsParsers;
        if (Array.isArray(value)) {
            return p.required.array(p.required.object({
                text: p.required.string,
                value: p.required.raw,
            }))(value).value;
        }
        if (typeof value === 'object') {
            return p.required.raw(value)
                .value;
        }
        return undefined;
    }
    function parsePickerLayout(value) {
        if (value === 'inline' || value === 'popup') {
            return value;
        }
        return undefined;
    }
    function parsePointDimensionParams(value) {
        const p = ParamsParsers;
        return p.required.object({
            max: p.optional.number,
            min: p.optional.number,
            step: p.optional.number,
        })(value).value;
    }
    function normalizeListOptions(options) {
        if (Array.isArray(options)) {
            return options;
        }
        const items = [];
        Object.keys(options).forEach((text) => {
            items.push({ text: text, value: options[text] });
        });
        return items;
    }
    function createListConstraint(options) {
        return !isEmpty(options)
            ? new ListConstraint(normalizeListOptions(forceCast(options)))
            : null;
    }
    function findStep(constraint) {
        const c = constraint ? findConstraint(constraint, StepConstraint) : null;
        if (!c) {
            return null;
        }
        return c.step;
    }
    function getSuitableDecimalDigits(constraint, rawValue) {
        const sc = constraint && findConstraint(constraint, StepConstraint);
        if (sc) {
            return getDecimalDigits(sc.step);
        }
        return Math.max(getDecimalDigits(rawValue), 2);
    }
    function getBaseStep(constraint) {
        const step = findStep(constraint);
        return step !== null && step !== void 0 ? step : 1;
    }
    function getSuitableDraggingScale(constraint, rawValue) {
        var _a;
        const sc = constraint && findConstraint(constraint, StepConstraint);
        const base = Math.abs((_a = sc === null || sc === void 0 ? void 0 : sc.step) !== null && _a !== void 0 ? _a : rawValue);
        return base === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base)) - 1);
    }

    const className$d = ClassName('ckb');
    class CheckboxView {
        constructor(doc, config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.element = doc.createElement('div');
            this.element.classList.add(className$d());
            config.viewProps.bindClassModifiers(this.element);
            const labelElem = doc.createElement('label');
            labelElem.classList.add(className$d('l'));
            this.element.appendChild(labelElem);
            const inputElem = doc.createElement('input');
            inputElem.classList.add(className$d('i'));
            inputElem.type = 'checkbox';
            labelElem.appendChild(inputElem);
            this.inputElement = inputElem;
            config.viewProps.bindDisabled(this.inputElement);
            const wrapperElem = doc.createElement('div');
            wrapperElem.classList.add(className$d('w'));
            labelElem.appendChild(wrapperElem);
            const markElem = createSvgIconElement(doc, 'check');
            wrapperElem.appendChild(markElem);
            config.value.emitter.on('change', this.onValueChange_);
            this.value = config.value;
            this.update_();
        }
        update_() {
            this.inputElement.checked = this.value.rawValue;
        }
        onValueChange_() {
            this.update_();
        }
    }

    class CheckboxController {
        constructor(doc, config) {
            this.onInputChange_ = this.onInputChange_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new CheckboxView(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view.inputElement.addEventListener('change', this.onInputChange_);
        }
        onInputChange_(e) {
            const inputElem = forceCast(e.currentTarget);
            this.value.rawValue = inputElem.checked;
        }
    }

    function createConstraint$6(params) {
        const constraints = [];
        const lc = createListConstraint(params.options);
        if (lc) {
            constraints.push(lc);
        }
        return new CompositeConstraint(constraints);
    }
    const BooleanInputPlugin = {
        id: 'input-bool',
        type: 'input',
        accept: (value, params) => {
            if (typeof value !== 'boolean') {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                options: p.optional.custom(parseListOptions),
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => boolFromUnknown,
            constraint: (args) => createConstraint$6(args.params),
            writer: (_args) => writePrimitive,
        },
        controller: (args) => {
            const doc = args.document;
            const value = args.value;
            const c = args.constraint;
            const lc = c && findConstraint(c, ListConstraint);
            if (lc) {
                return new ListController(doc, {
                    props: new ValueMap({
                        options: lc.values.value('options'),
                    }),
                    value: value,
                    viewProps: args.viewProps,
                });
            }
            return new CheckboxController(doc, {
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    const className$c = ClassName('col');
    class ColorView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$c());
            config.foldable.bindExpandedClass(this.element, className$c(undefined, 'expanded'));
            bindValueMap(config.foldable, 'completed', valueToClassName(this.element, className$c(undefined, 'cpl')));
            const headElem = doc.createElement('div');
            headElem.classList.add(className$c('h'));
            this.element.appendChild(headElem);
            const swatchElem = doc.createElement('div');
            swatchElem.classList.add(className$c('s'));
            headElem.appendChild(swatchElem);
            this.swatchElement = swatchElem;
            const textElem = doc.createElement('div');
            textElem.classList.add(className$c('t'));
            headElem.appendChild(textElem);
            this.textElement = textElem;
            if (config.pickerLayout === 'inline') {
                const pickerElem = doc.createElement('div');
                pickerElem.classList.add(className$c('p'));
                this.element.appendChild(pickerElem);
                this.pickerElement = pickerElem;
            }
            else {
                this.pickerElement = null;
            }
        }
    }

    function rgbToHslInt(r, g, b) {
        const rp = constrainRange(r / 255, 0, 1);
        const gp = constrainRange(g / 255, 0, 1);
        const bp = constrainRange(b / 255, 0, 1);
        const cmax = Math.max(rp, gp, bp);
        const cmin = Math.min(rp, gp, bp);
        const c = cmax - cmin;
        let h = 0;
        let s = 0;
        const l = (cmin + cmax) / 2;
        if (c !== 0) {
            s = c / (1 - Math.abs(cmax + cmin - 1));
            if (rp === cmax) {
                h = (gp - bp) / c;
            }
            else if (gp === cmax) {
                h = 2 + (bp - rp) / c;
            }
            else {
                h = 4 + (rp - gp) / c;
            }
            h = h / 6 + (h < 0 ? 1 : 0);
        }
        return [h * 360, s * 100, l * 100];
    }
    function hslToRgbInt(h, s, l) {
        const hp = ((h % 360) + 360) % 360;
        const sp = constrainRange(s / 100, 0, 1);
        const lp = constrainRange(l / 100, 0, 1);
        const c = (1 - Math.abs(2 * lp - 1)) * sp;
        const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
        const m = lp - c / 2;
        let rp, gp, bp;
        if (hp >= 0 && hp < 60) {
            [rp, gp, bp] = [c, x, 0];
        }
        else if (hp >= 60 && hp < 120) {
            [rp, gp, bp] = [x, c, 0];
        }
        else if (hp >= 120 && hp < 180) {
            [rp, gp, bp] = [0, c, x];
        }
        else if (hp >= 180 && hp < 240) {
            [rp, gp, bp] = [0, x, c];
        }
        else if (hp >= 240 && hp < 300) {
            [rp, gp, bp] = [x, 0, c];
        }
        else {
            [rp, gp, bp] = [c, 0, x];
        }
        return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
    }
    function rgbToHsvInt(r, g, b) {
        const rp = constrainRange(r / 255, 0, 1);
        const gp = constrainRange(g / 255, 0, 1);
        const bp = constrainRange(b / 255, 0, 1);
        const cmax = Math.max(rp, gp, bp);
        const cmin = Math.min(rp, gp, bp);
        const d = cmax - cmin;
        let h;
        if (d === 0) {
            h = 0;
        }
        else if (cmax === rp) {
            h = 60 * (((((gp - bp) / d) % 6) + 6) % 6);
        }
        else if (cmax === gp) {
            h = 60 * ((bp - rp) / d + 2);
        }
        else {
            h = 60 * ((rp - gp) / d + 4);
        }
        const s = cmax === 0 ? 0 : d / cmax;
        const v = cmax;
        return [h, s * 100, v * 100];
    }
    function hsvToRgbInt(h, s, v) {
        const hp = loopRange(h, 360);
        const sp = constrainRange(s / 100, 0, 1);
        const vp = constrainRange(v / 100, 0, 1);
        const c = vp * sp;
        const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
        const m = vp - c;
        let rp, gp, bp;
        if (hp >= 0 && hp < 60) {
            [rp, gp, bp] = [c, x, 0];
        }
        else if (hp >= 60 && hp < 120) {
            [rp, gp, bp] = [x, c, 0];
        }
        else if (hp >= 120 && hp < 180) {
            [rp, gp, bp] = [0, c, x];
        }
        else if (hp >= 180 && hp < 240) {
            [rp, gp, bp] = [0, x, c];
        }
        else if (hp >= 240 && hp < 300) {
            [rp, gp, bp] = [x, 0, c];
        }
        else {
            [rp, gp, bp] = [c, 0, x];
        }
        return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
    }
    function hslToHsvInt(h, s, l) {
        const sd = l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100);
        return [
            h,
            sd !== 0 ? (s * (100 - Math.abs(2 * l - 100))) / sd : 0,
            l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100),
        ];
    }
    function hsvToHslInt(h, s, v) {
        const sd = 100 - Math.abs((v * (200 - s)) / 100 - 100);
        return [h, sd !== 0 ? (s * v) / sd : 0, (v * (200 - s)) / (2 * 100)];
    }
    function removeAlphaComponent(comps) {
        return [comps[0], comps[1], comps[2]];
    }
    function appendAlphaComponent(comps, alpha) {
        return [comps[0], comps[1], comps[2], alpha];
    }
    const MODE_CONVERTER_MAP = {
        hsl: {
            hsl: (h, s, l) => [h, s, l],
            hsv: hslToHsvInt,
            rgb: hslToRgbInt,
        },
        hsv: {
            hsl: hsvToHslInt,
            hsv: (h, s, v) => [h, s, v],
            rgb: hsvToRgbInt,
        },
        rgb: {
            hsl: rgbToHslInt,
            hsv: rgbToHsvInt,
            rgb: (r, g, b) => [r, g, b],
        },
    };
    function getColorMaxComponents(mode, type) {
        return [
            type === 'float' ? 1 : mode === 'rgb' ? 255 : 360,
            type === 'float' ? 1 : mode === 'rgb' ? 255 : 100,
            type === 'float' ? 1 : mode === 'rgb' ? 255 : 100,
        ];
    }
    function loopHueRange(hue, max) {
        return hue === max ? max : loopRange(hue, max);
    }
    function constrainColorComponents(components, mode, type) {
        var _a;
        const ms = getColorMaxComponents(mode, type);
        return [
            mode === 'rgb'
                ? constrainRange(components[0], 0, ms[0])
                : loopHueRange(components[0], ms[0]),
            constrainRange(components[1], 0, ms[1]),
            constrainRange(components[2], 0, ms[2]),
            constrainRange((_a = components[3]) !== null && _a !== void 0 ? _a : 1, 0, 1),
        ];
    }
    function convertColorType(comps, mode, from, to) {
        const fms = getColorMaxComponents(mode, from);
        const tms = getColorMaxComponents(mode, to);
        return comps.map((c, index) => (c / fms[index]) * tms[index]);
    }
    function convertColor(components, from, to) {
        const intComps = convertColorType(components, from.mode, from.type, 'int');
        const result = MODE_CONVERTER_MAP[from.mode][to.mode](...intComps);
        return convertColorType(result, to.mode, 'int', to.type);
    }

    function isRgbColorComponent(obj, key) {
        if (typeof obj !== 'object' || isEmpty(obj)) {
            return false;
        }
        return key in obj && typeof obj[key] === 'number';
    }
    class Color {
        static black(type = 'int') {
            return new Color([0, 0, 0], 'rgb', type);
        }
        static fromObject(obj, type = 'int') {
            const comps = 'a' in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
            return new Color(comps, 'rgb', type);
        }
        static toRgbaObject(color, type = 'int') {
            return color.toRgbaObject(type);
        }
        static isRgbColorObject(obj) {
            return (isRgbColorComponent(obj, 'r') &&
                isRgbColorComponent(obj, 'g') &&
                isRgbColorComponent(obj, 'b'));
        }
        static isRgbaColorObject(obj) {
            return this.isRgbColorObject(obj) && isRgbColorComponent(obj, 'a');
        }
        static isColorObject(obj) {
            return this.isRgbColorObject(obj);
        }
        static equals(v1, v2) {
            if (v1.mode !== v2.mode) {
                return false;
            }
            const comps1 = v1.comps_;
            const comps2 = v2.comps_;
            for (let i = 0; i < comps1.length; i++) {
                if (comps1[i] !== comps2[i]) {
                    return false;
                }
            }
            return true;
        }
        constructor(comps, mode, type = 'int') {
            this.mode = mode;
            this.type = type;
            this.comps_ = constrainColorComponents(comps, mode, type);
        }
        getComponents(opt_mode, type = 'int') {
            return appendAlphaComponent(convertColor(removeAlphaComponent(this.comps_), { mode: this.mode, type: this.type }, { mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode, type }), this.comps_[3]);
        }
        toRgbaObject(type = 'int') {
            const rgbComps = this.getComponents('rgb', type);
            return {
                r: rgbComps[0],
                g: rgbComps[1],
                b: rgbComps[2],
                a: rgbComps[3],
            };
        }
    }

    const className$b = ClassName('colp');
    class ColorPickerView {
        constructor(doc, config) {
            this.alphaViews_ = null;
            this.element = doc.createElement('div');
            this.element.classList.add(className$b());
            config.viewProps.bindClassModifiers(this.element);
            const hsvElem = doc.createElement('div');
            hsvElem.classList.add(className$b('hsv'));
            const svElem = doc.createElement('div');
            svElem.classList.add(className$b('sv'));
            this.svPaletteView_ = config.svPaletteView;
            svElem.appendChild(this.svPaletteView_.element);
            hsvElem.appendChild(svElem);
            const hElem = doc.createElement('div');
            hElem.classList.add(className$b('h'));
            this.hPaletteView_ = config.hPaletteView;
            hElem.appendChild(this.hPaletteView_.element);
            hsvElem.appendChild(hElem);
            this.element.appendChild(hsvElem);
            const rgbElem = doc.createElement('div');
            rgbElem.classList.add(className$b('rgb'));
            this.textView_ = config.textView;
            rgbElem.appendChild(this.textView_.element);
            this.element.appendChild(rgbElem);
            if (config.alphaViews) {
                this.alphaViews_ = {
                    palette: config.alphaViews.palette,
                    text: config.alphaViews.text,
                };
                const aElem = doc.createElement('div');
                aElem.classList.add(className$b('a'));
                const apElem = doc.createElement('div');
                apElem.classList.add(className$b('ap'));
                apElem.appendChild(this.alphaViews_.palette.element);
                aElem.appendChild(apElem);
                const atElem = doc.createElement('div');
                atElem.classList.add(className$b('at'));
                atElem.appendChild(this.alphaViews_.text.element);
                aElem.appendChild(atElem);
                this.element.appendChild(aElem);
            }
        }
        get allFocusableElements() {
            const elems = [
                this.svPaletteView_.element,
                this.hPaletteView_.element,
                this.textView_.modeSelectElement,
                ...this.textView_.textViews.map((v) => v.inputElement),
            ];
            if (this.alphaViews_) {
                elems.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement);
            }
            return elems;
        }
    }

    function parseColorType(value) {
        return value === 'int' ? 'int' : value === 'float' ? 'float' : undefined;
    }
    function parseColorInputParams(params) {
        const p = ParamsParsers;
        return parseParams(params, {
            alpha: p.optional.boolean,
            color: p.optional.object({
                alpha: p.optional.boolean,
                type: p.optional.custom(parseColorType),
            }),
            expanded: p.optional.boolean,
            picker: p.optional.custom(parsePickerLayout),
        });
    }
    function getBaseStepForColor(forAlpha) {
        return forAlpha ? 0.1 : 1;
    }
    function extractColorType(params) {
        var _a;
        return (_a = params.color) === null || _a === void 0 ? void 0 : _a.type;
    }

    function equalsStringColorFormat(f1, f2) {
        return (f1.alpha === f2.alpha &&
            f1.mode === f2.mode &&
            f1.notation === f2.notation &&
            f1.type === f2.type);
    }
    function parseCssNumberOrPercentage(text, maxValue) {
        const m = text.match(/^(.+)%$/);
        if (!m) {
            return Math.min(parseFloat(text), maxValue);
        }
        return Math.min(parseFloat(m[1]) * 0.01 * maxValue, maxValue);
    }
    const ANGLE_TO_DEG_MAP = {
        deg: (angle) => angle,
        grad: (angle) => (angle * 360) / 400,
        rad: (angle) => (angle * 360) / (2 * Math.PI),
        turn: (angle) => angle * 360,
    };
    function parseCssNumberOrAngle(text) {
        const m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
        if (!m) {
            return parseFloat(text);
        }
        const angle = parseFloat(m[1]);
        const unit = m[2];
        return ANGLE_TO_DEG_MAP[unit](angle);
    }
    function parseFunctionalRgbColorComponents(text) {
        const m = text.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m) {
            return null;
        }
        const comps = [
            parseCssNumberOrPercentage(m[1], 255),
            parseCssNumberOrPercentage(m[2], 255),
            parseCssNumberOrPercentage(m[3], 255),
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
            return null;
        }
        return comps;
    }
    function createFunctionalRgbColorParser(type) {
        return (text) => {
            const comps = parseFunctionalRgbColorComponents(text);
            return comps ? new Color(comps, 'rgb', type) : null;
        };
    }
    function parseFunctionalRgbaColorComponents(text) {
        const m = text.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m) {
            return null;
        }
        const comps = [
            parseCssNumberOrPercentage(m[1], 255),
            parseCssNumberOrPercentage(m[2], 255),
            parseCssNumberOrPercentage(m[3], 255),
            parseCssNumberOrPercentage(m[4], 1),
        ];
        if (isNaN(comps[0]) ||
            isNaN(comps[1]) ||
            isNaN(comps[2]) ||
            isNaN(comps[3])) {
            return null;
        }
        return comps;
    }
    function createFunctionalRgbaColorParser(type) {
        return (text) => {
            const comps = parseFunctionalRgbaColorComponents(text);
            return comps ? new Color(comps, 'rgb', type) : null;
        };
    }
    function parseHslColorComponents(text) {
        const m = text.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m) {
            return null;
        }
        const comps = [
            parseCssNumberOrAngle(m[1]),
            parseCssNumberOrPercentage(m[2], 100),
            parseCssNumberOrPercentage(m[3], 100),
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
            return null;
        }
        return comps;
    }
    function createHslColorParser(type) {
        return (text) => {
            const comps = parseHslColorComponents(text);
            return comps ? new Color(comps, 'hsl', type) : null;
        };
    }
    function parseHslaColorComponents(text) {
        const m = text.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m) {
            return null;
        }
        const comps = [
            parseCssNumberOrAngle(m[1]),
            parseCssNumberOrPercentage(m[2], 100),
            parseCssNumberOrPercentage(m[3], 100),
            parseCssNumberOrPercentage(m[4], 1),
        ];
        if (isNaN(comps[0]) ||
            isNaN(comps[1]) ||
            isNaN(comps[2]) ||
            isNaN(comps[3])) {
            return null;
        }
        return comps;
    }
    function createHslaColorParser(type) {
        return (text) => {
            const comps = parseHslaColorComponents(text);
            return comps ? new Color(comps, 'hsl', type) : null;
        };
    }
    function parseHexRgbColorComponents(text) {
        const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
        if (mRgb) {
            return [
                parseInt(mRgb[1] + mRgb[1], 16),
                parseInt(mRgb[2] + mRgb[2], 16),
                parseInt(mRgb[3] + mRgb[3], 16),
            ];
        }
        const mRrggbb = text.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
        if (mRrggbb) {
            return [
                parseInt(mRrggbb[1], 16),
                parseInt(mRrggbb[2], 16),
                parseInt(mRrggbb[3], 16),
            ];
        }
        return null;
    }
    function parseHexRgbColor(text) {
        const comps = parseHexRgbColorComponents(text);
        return comps ? new Color(comps, 'rgb', 'int') : null;
    }
    function parseHexRgbaColorComponents(text) {
        const mRgb = text.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
        if (mRgb) {
            return [
                parseInt(mRgb[1] + mRgb[1], 16),
                parseInt(mRgb[2] + mRgb[2], 16),
                parseInt(mRgb[3] + mRgb[3], 16),
                mapRange(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1),
            ];
        }
        const mRrggbb = text.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
        if (mRrggbb) {
            return [
                parseInt(mRrggbb[1], 16),
                parseInt(mRrggbb[2], 16),
                parseInt(mRrggbb[3], 16),
                mapRange(parseInt(mRrggbb[4], 16), 0, 255, 0, 1),
            ];
        }
        return null;
    }
    function parseHexRgbaColor(text) {
        const comps = parseHexRgbaColorComponents(text);
        return comps ? new Color(comps, 'rgb', 'int') : null;
    }
    function parseObjectRgbColorComponents(text) {
        const m = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
        if (!m) {
            return null;
        }
        const comps = [
            parseFloat(m[1]),
            parseFloat(m[2]),
            parseFloat(m[3]),
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
            return null;
        }
        return comps;
    }
    function createObjectRgbColorParser(type) {
        return (text) => {
            const comps = parseObjectRgbColorComponents(text);
            return comps ? new Color(comps, 'rgb', type) : null;
        };
    }
    function parseObjectRgbaColorComponents(text) {
        const m = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
        if (!m) {
            return null;
        }
        const comps = [
            parseFloat(m[1]),
            parseFloat(m[2]),
            parseFloat(m[3]),
            parseFloat(m[4]),
        ];
        if (isNaN(comps[0]) ||
            isNaN(comps[1]) ||
            isNaN(comps[2]) ||
            isNaN(comps[3])) {
            return null;
        }
        return comps;
    }
    function createObjectRgbaColorParser(type) {
        return (text) => {
            const comps = parseObjectRgbaColorComponents(text);
            return comps ? new Color(comps, 'rgb', type) : null;
        };
    }
    const PARSER_AND_RESULT = [
        {
            parser: parseHexRgbColorComponents,
            result: {
                alpha: false,
                mode: 'rgb',
                notation: 'hex',
            },
        },
        {
            parser: parseHexRgbaColorComponents,
            result: {
                alpha: true,
                mode: 'rgb',
                notation: 'hex',
            },
        },
        {
            parser: parseFunctionalRgbColorComponents,
            result: {
                alpha: false,
                mode: 'rgb',
                notation: 'func',
            },
        },
        {
            parser: parseFunctionalRgbaColorComponents,
            result: {
                alpha: true,
                mode: 'rgb',
                notation: 'func',
            },
        },
        {
            parser: parseHslColorComponents,
            result: {
                alpha: false,
                mode: 'hsl',
                notation: 'func',
            },
        },
        {
            parser: parseHslaColorComponents,
            result: {
                alpha: true,
                mode: 'hsl',
                notation: 'func',
            },
        },
        {
            parser: parseObjectRgbColorComponents,
            result: {
                alpha: false,
                mode: 'rgb',
                notation: 'object',
            },
        },
        {
            parser: parseObjectRgbaColorComponents,
            result: {
                alpha: true,
                mode: 'rgb',
                notation: 'object',
            },
        },
    ];
    function detectStringColor(text) {
        return PARSER_AND_RESULT.reduce((prev, { parser, result: detection }) => {
            if (prev) {
                return prev;
            }
            return parser(text) ? detection : null;
        }, null);
    }
    function detectStringColorFormat(text, type = 'int') {
        const r = detectStringColor(text);
        if (!r) {
            return null;
        }
        if (r.notation === 'hex' && type !== 'float') {
            return Object.assign(Object.assign({}, r), { type: 'int' });
        }
        if (r.notation === 'func') {
            return Object.assign(Object.assign({}, r), { type: type });
        }
        return null;
    }
    const TYPE_TO_PARSERS = {
        int: [
            parseHexRgbColor,
            parseHexRgbaColor,
            createFunctionalRgbColorParser('int'),
            createFunctionalRgbaColorParser('int'),
            createHslColorParser('int'),
            createHslaColorParser('int'),
            createObjectRgbColorParser('int'),
            createObjectRgbaColorParser('int'),
        ],
        float: [
            createFunctionalRgbColorParser('float'),
            createFunctionalRgbaColorParser('float'),
            createHslColorParser('float'),
            createHslaColorParser('float'),
            createObjectRgbColorParser('float'),
            createObjectRgbaColorParser('float'),
        ],
    };
    function createColorStringBindingReader(type) {
        const parsers = TYPE_TO_PARSERS[type];
        return (value) => {
            if (typeof value !== 'string') {
                return Color.black(type);
            }
            const result = parsers.reduce((prev, parser) => {
                if (prev) {
                    return prev;
                }
                return parser(value);
            }, null);
            return result !== null && result !== void 0 ? result : Color.black(type);
        };
    }
    function createColorStringParser(type) {
        const parsers = TYPE_TO_PARSERS[type];
        return (value) => {
            return parsers.reduce((prev, parser) => {
                if (prev) {
                    return prev;
                }
                return parser(value);
            }, null);
        };
    }
    function zerofill(comp) {
        const hex = constrainRange(Math.floor(comp), 0, 255).toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
    }
    function colorToHexRgbString(value, prefix = '#') {
        const hexes = removeAlphaComponent(value.getComponents('rgb'))
            .map(zerofill)
            .join('');
        return `${prefix}${hexes}`;
    }
    function colorToHexRgbaString(value, prefix = '#') {
        const rgbaComps = value.getComponents('rgb');
        const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255]
            .map(zerofill)
            .join('');
        return `${prefix}${hexes}`;
    }
    function colorToFunctionalRgbString(value, opt_type) {
        const formatter = createNumberFormatter(opt_type === 'float' ? 2 : 0);
        const comps = removeAlphaComponent(value.getComponents('rgb', opt_type)).map((comp) => formatter(comp));
        return `rgb(${comps.join(', ')})`;
    }
    function createFunctionalRgbColorFormatter(type) {
        return (value) => {
            return colorToFunctionalRgbString(value, type);
        };
    }
    function colorToFunctionalRgbaString(value, opt_type) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(opt_type === 'float' ? 2 : 0);
        const comps = value.getComponents('rgb', opt_type).map((comp, index) => {
            const formatter = index === 3 ? aFormatter : rgbFormatter;
            return formatter(comp);
        });
        return `rgba(${comps.join(', ')})`;
    }
    function createFunctionalRgbaColorFormatter(type) {
        return (value) => {
            return colorToFunctionalRgbaString(value, type);
        };
    }
    function colorToFunctionalHslString(value) {
        const formatters = [
            createNumberFormatter(0),
            formatPercentage,
            formatPercentage,
        ];
        const comps = removeAlphaComponent(value.getComponents('hsl')).map((comp, index) => formatters[index](comp));
        return `hsl(${comps.join(', ')})`;
    }
    function colorToFunctionalHslaString(value) {
        const formatters = [
            createNumberFormatter(0),
            formatPercentage,
            formatPercentage,
            createNumberFormatter(2),
        ];
        const comps = value
            .getComponents('hsl')
            .map((comp, index) => formatters[index](comp));
        return `hsla(${comps.join(', ')})`;
    }
    function colorToObjectRgbString(value, type) {
        const formatter = createNumberFormatter(type === 'float' ? 2 : 0);
        const names = ['r', 'g', 'b'];
        const comps = removeAlphaComponent(value.getComponents('rgb', type)).map((comp, index) => `${names[index]}: ${formatter(comp)}`);
        return `{${comps.join(', ')}}`;
    }
    function createObjectRgbColorFormatter(type) {
        return (value) => colorToObjectRgbString(value, type);
    }
    function colorToObjectRgbaString(value, type) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(type === 'float' ? 2 : 0);
        const names = ['r', 'g', 'b', 'a'];
        const comps = value.getComponents('rgb', type).map((comp, index) => {
            const formatter = index === 3 ? aFormatter : rgbFormatter;
            return `${names[index]}: ${formatter(comp)}`;
        });
        return `{${comps.join(', ')}}`;
    }
    function createObjectRgbaColorFormatter(type) {
        return (value) => colorToObjectRgbaString(value, type);
    }
    const FORMAT_AND_STRINGIFIERS = [
        {
            format: {
                alpha: false,
                mode: 'rgb',
                notation: 'hex',
                type: 'int',
            },
            stringifier: colorToHexRgbString,
        },
        {
            format: {
                alpha: true,
                mode: 'rgb',
                notation: 'hex',
                type: 'int',
            },
            stringifier: colorToHexRgbaString,
        },
        {
            format: {
                alpha: false,
                mode: 'hsl',
                notation: 'func',
                type: 'int',
            },
            stringifier: colorToFunctionalHslString,
        },
        {
            format: {
                alpha: true,
                mode: 'hsl',
                notation: 'func',
                type: 'int',
            },
            stringifier: colorToFunctionalHslaString,
        },
        ...['int', 'float'].reduce((prev, type) => {
            return [
                ...prev,
                {
                    format: {
                        alpha: false,
                        mode: 'rgb',
                        notation: 'func',
                        type: type,
                    },
                    stringifier: createFunctionalRgbColorFormatter(type),
                },
                {
                    format: {
                        alpha: true,
                        mode: 'rgb',
                        notation: 'func',
                        type: type,
                    },
                    stringifier: createFunctionalRgbaColorFormatter(type),
                },
                {
                    format: {
                        alpha: false,
                        mode: 'rgb',
                        notation: 'object',
                        type: type,
                    },
                    stringifier: createObjectRgbColorFormatter(type),
                },
                {
                    format: {
                        alpha: true,
                        mode: 'rgb',
                        notation: 'object',
                        type: type,
                    },
                    stringifier: createObjectRgbaColorFormatter(type),
                },
            ];
        }, []),
    ];
    function findColorStringifier(format) {
        return FORMAT_AND_STRINGIFIERS.reduce((prev, fas) => {
            if (prev) {
                return prev;
            }
            return equalsStringColorFormat(fas.format, format)
                ? fas.stringifier
                : null;
        }, null);
    }

    const className$a = ClassName('apl');
    class APaletteView {
        constructor(doc, config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.value = config.value;
            this.value.emitter.on('change', this.onValueChange_);
            this.element = doc.createElement('div');
            this.element.classList.add(className$a());
            config.viewProps.bindClassModifiers(this.element);
            config.viewProps.bindTabIndex(this.element);
            const barElem = doc.createElement('div');
            barElem.classList.add(className$a('b'));
            this.element.appendChild(barElem);
            const colorElem = doc.createElement('div');
            colorElem.classList.add(className$a('c'));
            barElem.appendChild(colorElem);
            this.colorElem_ = colorElem;
            const markerElem = doc.createElement('div');
            markerElem.classList.add(className$a('m'));
            this.element.appendChild(markerElem);
            this.markerElem_ = markerElem;
            const previewElem = doc.createElement('div');
            previewElem.classList.add(className$a('p'));
            this.markerElem_.appendChild(previewElem);
            this.previewElem_ = previewElem;
            this.update_();
        }
        update_() {
            const c = this.value.rawValue;
            const rgbaComps = c.getComponents('rgb');
            const leftColor = new Color([rgbaComps[0], rgbaComps[1], rgbaComps[2], 0], 'rgb');
            const rightColor = new Color([rgbaComps[0], rgbaComps[1], rgbaComps[2], 255], 'rgb');
            const gradientComps = [
                'to right',
                colorToFunctionalRgbaString(leftColor),
                colorToFunctionalRgbaString(rightColor),
            ];
            this.colorElem_.style.background = `linear-gradient(${gradientComps.join(',')})`;
            this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString(c);
            const left = mapRange(rgbaComps[3], 0, 1, 0, 100);
            this.markerElem_.style.left = `${left}%`;
        }
        onValueChange_() {
            this.update_();
        }
    }

    class APaletteController {
        constructor(doc, config) {
            this.onKeyDown_ = this.onKeyDown_.bind(this);
            this.onKeyUp_ = this.onKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new APaletteView(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            this.ptHandler_ = new PointerHandler(this.view.element);
            this.ptHandler_.emitter.on('down', this.onPointerDown_);
            this.ptHandler_.emitter.on('move', this.onPointerMove_);
            this.ptHandler_.emitter.on('up', this.onPointerUp_);
            this.view.element.addEventListener('keydown', this.onKeyDown_);
            this.view.element.addEventListener('keyup', this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
            if (!d.point) {
                return;
            }
            const alpha = d.point.x / d.bounds.width;
            const c = this.value.rawValue;
            const [h, s, v] = c.getComponents('hsv');
            this.value.setRawValue(new Color([h, s, v, alpha], 'hsv'), opts);
        }
        onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true,
            });
        }
        onKeyDown_(ev) {
            const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
            if (step === 0) {
                return;
            }
            const c = this.value.rawValue;
            const [h, s, v, a] = c.getComponents('hsv');
            this.value.setRawValue(new Color([h, s, v, a + step], 'hsv'), {
                forceEmit: false,
                last: false,
            });
        }
        onKeyUp_(ev) {
            const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
            if (step === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true,
            });
        }
    }

    const className$9 = ClassName('coltxt');
    function createModeSelectElement(doc) {
        const selectElem = doc.createElement('select');
        const items = [
            { text: 'RGB', value: 'rgb' },
            { text: 'HSL', value: 'hsl' },
            { text: 'HSV', value: 'hsv' },
        ];
        selectElem.appendChild(items.reduce((frag, item) => {
            const optElem = doc.createElement('option');
            optElem.textContent = item.text;
            optElem.value = item.value;
            frag.appendChild(optElem);
            return frag;
        }, doc.createDocumentFragment()));
        return selectElem;
    }
    class ColorTextView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$9());
            config.viewProps.bindClassModifiers(this.element);
            const modeElem = doc.createElement('div');
            modeElem.classList.add(className$9('m'));
            this.modeElem_ = createModeSelectElement(doc);
            this.modeElem_.classList.add(className$9('ms'));
            modeElem.appendChild(this.modeSelectElement);
            config.viewProps.bindDisabled(this.modeElem_);
            const modeMarkerElem = doc.createElement('div');
            modeMarkerElem.classList.add(className$9('mm'));
            modeMarkerElem.appendChild(createSvgIconElement(doc, 'dropdown'));
            modeElem.appendChild(modeMarkerElem);
            this.element.appendChild(modeElem);
            const textsElem = doc.createElement('div');
            textsElem.classList.add(className$9('w'));
            this.element.appendChild(textsElem);
            this.textsElem_ = textsElem;
            this.textViews_ = config.textViews;
            this.applyTextViews_();
            bindValue(config.colorMode, (mode) => {
                this.modeElem_.value = mode;
            });
        }
        get modeSelectElement() {
            return this.modeElem_;
        }
        get textViews() {
            return this.textViews_;
        }
        set textViews(textViews) {
            this.textViews_ = textViews;
            this.applyTextViews_();
        }
        applyTextViews_() {
            removeChildElements(this.textsElem_);
            const doc = this.element.ownerDocument;
            this.textViews_.forEach((v) => {
                const compElem = doc.createElement('div');
                compElem.classList.add(className$9('c'));
                compElem.appendChild(v.element);
                this.textsElem_.appendChild(compElem);
            });
        }
    }

    function createFormatter$2(type) {
        return createNumberFormatter(type === 'float' ? 2 : 0);
    }
    function createConstraint$5(mode, type, index) {
        const max = getColorMaxComponents(mode, type)[index];
        return new DefiniteRangeConstraint({
            min: 0,
            max: max,
        });
    }
    function createComponentController(doc, config, index) {
        return new NumberTextController(doc, {
            arrayPosition: index === 0 ? 'fst' : index === 3 - 1 ? 'lst' : 'mid',
            baseStep: getBaseStepForColor(false),
            parser: config.parser,
            props: ValueMap.fromObject({
                draggingScale: config.colorType === 'float' ? 0.01 : 1,
                formatter: createFormatter$2(config.colorType),
            }),
            value: createValue(0, {
                constraint: createConstraint$5(config.colorMode, config.colorType, index),
            }),
            viewProps: config.viewProps,
        });
    }
    class ColorTextController {
        constructor(doc, config) {
            this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
            this.colorType_ = config.colorType;
            this.parser_ = config.parser;
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.colorMode = createValue(this.value.rawValue.mode);
            this.ccs_ = this.createComponentControllers_(doc);
            this.view = new ColorTextView(doc, {
                colorMode: this.colorMode,
                textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
                viewProps: this.viewProps,
            });
            this.view.modeSelectElement.addEventListener('change', this.onModeSelectChange_);
        }
        createComponentControllers_(doc) {
            const cc = {
                colorMode: this.colorMode.rawValue,
                colorType: this.colorType_,
                parser: this.parser_,
                viewProps: this.viewProps,
            };
            const ccs = [
                createComponentController(doc, cc, 0),
                createComponentController(doc, cc, 1),
                createComponentController(doc, cc, 2),
            ];
            ccs.forEach((cs, index) => {
                connectValues({
                    primary: this.value,
                    secondary: cs.value,
                    forward: (p) => {
                        return p.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[index];
                    },
                    backward: (p, s) => {
                        const pickedMode = this.colorMode.rawValue;
                        const comps = p.rawValue.getComponents(pickedMode, this.colorType_);
                        comps[index] = s.rawValue;
                        return new Color(appendAlphaComponent(removeAlphaComponent(comps), comps[3]), pickedMode, this.colorType_);
                    },
                });
            });
            return ccs;
        }
        onModeSelectChange_(ev) {
            const selectElem = ev.currentTarget;
            this.colorMode.rawValue = selectElem.value;
            this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument);
            this.view.textViews = [
                this.ccs_[0].view,
                this.ccs_[1].view,
                this.ccs_[2].view,
            ];
        }
    }

    const className$8 = ClassName('hpl');
    class HPaletteView {
        constructor(doc, config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.value = config.value;
            this.value.emitter.on('change', this.onValueChange_);
            this.element = doc.createElement('div');
            this.element.classList.add(className$8());
            config.viewProps.bindClassModifiers(this.element);
            config.viewProps.bindTabIndex(this.element);
            const colorElem = doc.createElement('div');
            colorElem.classList.add(className$8('c'));
            this.element.appendChild(colorElem);
            const markerElem = doc.createElement('div');
            markerElem.classList.add(className$8('m'));
            this.element.appendChild(markerElem);
            this.markerElem_ = markerElem;
            this.update_();
        }
        update_() {
            const c = this.value.rawValue;
            const [h] = c.getComponents('hsv');
            this.markerElem_.style.backgroundColor = colorToFunctionalRgbString(new Color([h, 100, 100], 'hsv'));
            const left = mapRange(h, 0, 360, 0, 100);
            this.markerElem_.style.left = `${left}%`;
        }
        onValueChange_() {
            this.update_();
        }
    }

    class HPaletteController {
        constructor(doc, config) {
            this.onKeyDown_ = this.onKeyDown_.bind(this);
            this.onKeyUp_ = this.onKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new HPaletteView(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            this.ptHandler_ = new PointerHandler(this.view.element);
            this.ptHandler_.emitter.on('down', this.onPointerDown_);
            this.ptHandler_.emitter.on('move', this.onPointerMove_);
            this.ptHandler_.emitter.on('up', this.onPointerUp_);
            this.view.element.addEventListener('keydown', this.onKeyDown_);
            this.view.element.addEventListener('keyup', this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
            if (!d.point) {
                return;
            }
            const hue = mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, 0, 360);
            const c = this.value.rawValue;
            const [, s, v, a] = c.getComponents('hsv');
            this.value.setRawValue(new Color([hue, s, v, a], 'hsv'), opts);
        }
        onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true,
            });
        }
        onKeyDown_(ev) {
            const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
            if (step === 0) {
                return;
            }
            const c = this.value.rawValue;
            const [h, s, v, a] = c.getComponents('hsv');
            this.value.setRawValue(new Color([h + step, s, v, a], 'hsv'), {
                forceEmit: false,
                last: false,
            });
        }
        onKeyUp_(ev) {
            const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
            if (step === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true,
            });
        }
    }

    const className$7 = ClassName('svp');
    const CANVAS_RESOL = 64;
    class SvPaletteView {
        constructor(doc, config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.value = config.value;
            this.value.emitter.on('change', this.onValueChange_);
            this.element = doc.createElement('div');
            this.element.classList.add(className$7());
            config.viewProps.bindClassModifiers(this.element);
            config.viewProps.bindTabIndex(this.element);
            const canvasElem = doc.createElement('canvas');
            canvasElem.height = CANVAS_RESOL;
            canvasElem.width = CANVAS_RESOL;
            canvasElem.classList.add(className$7('c'));
            this.element.appendChild(canvasElem);
            this.canvasElement = canvasElem;
            const markerElem = doc.createElement('div');
            markerElem.classList.add(className$7('m'));
            this.element.appendChild(markerElem);
            this.markerElem_ = markerElem;
            this.update_();
        }
        update_() {
            const ctx = getCanvasContext(this.canvasElement);
            if (!ctx) {
                return;
            }
            const c = this.value.rawValue;
            const hsvComps = c.getComponents('hsv');
            const width = this.canvasElement.width;
            const height = this.canvasElement.height;
            const imgData = ctx.getImageData(0, 0, width, height);
            const data = imgData.data;
            for (let iy = 0; iy < height; iy++) {
                for (let ix = 0; ix < width; ix++) {
                    const s = mapRange(ix, 0, width, 0, 100);
                    const v = mapRange(iy, 0, height, 100, 0);
                    const rgbComps = hsvToRgbInt(hsvComps[0], s, v);
                    const i = (iy * width + ix) * 4;
                    data[i] = rgbComps[0];
                    data[i + 1] = rgbComps[1];
                    data[i + 2] = rgbComps[2];
                    data[i + 3] = 255;
                }
            }
            ctx.putImageData(imgData, 0, 0);
            const left = mapRange(hsvComps[1], 0, 100, 0, 100);
            this.markerElem_.style.left = `${left}%`;
            const top = mapRange(hsvComps[2], 0, 100, 100, 0);
            this.markerElem_.style.top = `${top}%`;
        }
        onValueChange_() {
            this.update_();
        }
    }

    class SvPaletteController {
        constructor(doc, config) {
            this.onKeyDown_ = this.onKeyDown_.bind(this);
            this.onKeyUp_ = this.onKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new SvPaletteView(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            this.ptHandler_ = new PointerHandler(this.view.element);
            this.ptHandler_.emitter.on('down', this.onPointerDown_);
            this.ptHandler_.emitter.on('move', this.onPointerMove_);
            this.ptHandler_.emitter.on('up', this.onPointerUp_);
            this.view.element.addEventListener('keydown', this.onKeyDown_);
            this.view.element.addEventListener('keyup', this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
            if (!d.point) {
                return;
            }
            const saturation = mapRange(d.point.x, 0, d.bounds.width, 0, 100);
            const value = mapRange(d.point.y, 0, d.bounds.height, 100, 0);
            const [h, , , a] = this.value.rawValue.getComponents('hsv');
            this.value.setRawValue(new Color([h, saturation, value, a], 'hsv'), opts);
        }
        onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true,
            });
        }
        onKeyDown_(ev) {
            if (isArrowKey(ev.key)) {
                ev.preventDefault();
            }
            const [h, s, v, a] = this.value.rawValue.getComponents('hsv');
            const baseStep = getBaseStepForColor(false);
            const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
            const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
            if (ds === 0 && dv === 0) {
                return;
            }
            this.value.setRawValue(new Color([h, s + ds, v + dv, a], 'hsv'), {
                forceEmit: false,
                last: false,
            });
        }
        onKeyUp_(ev) {
            const baseStep = getBaseStepForColor(false);
            const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
            const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
            if (ds === 0 && dv === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true,
            });
        }
    }

    class ColorPickerController {
        constructor(doc, config) {
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.hPaletteC_ = new HPaletteController(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            this.svPaletteC_ = new SvPaletteController(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            this.alphaIcs_ = config.supportsAlpha
                ? {
                    palette: new APaletteController(doc, {
                        value: this.value,
                        viewProps: this.viewProps,
                    }),
                    text: new NumberTextController(doc, {
                        parser: parseNumber,
                        baseStep: 0.1,
                        props: ValueMap.fromObject({
                            draggingScale: 0.01,
                            formatter: createNumberFormatter(2),
                        }),
                        value: createValue(0, {
                            constraint: new DefiniteRangeConstraint({ min: 0, max: 1 }),
                        }),
                        viewProps: this.viewProps,
                    }),
                }
                : null;
            if (this.alphaIcs_) {
                connectValues({
                    primary: this.value,
                    secondary: this.alphaIcs_.text.value,
                    forward: (p) => {
                        return p.rawValue.getComponents()[3];
                    },
                    backward: (p, s) => {
                        const comps = p.rawValue.getComponents();
                        comps[3] = s.rawValue;
                        return new Color(comps, p.rawValue.mode);
                    },
                });
            }
            this.textC_ = new ColorTextController(doc, {
                colorType: config.colorType,
                parser: parseNumber,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view = new ColorPickerView(doc, {
                alphaViews: this.alphaIcs_
                    ? {
                        palette: this.alphaIcs_.palette.view,
                        text: this.alphaIcs_.text.view,
                    }
                    : null,
                hPaletteView: this.hPaletteC_.view,
                supportsAlpha: config.supportsAlpha,
                svPaletteView: this.svPaletteC_.view,
                textView: this.textC_.view,
                viewProps: this.viewProps,
            });
        }
        get textController() {
            return this.textC_;
        }
    }

    const className$6 = ClassName('colsw');
    class ColorSwatchView {
        constructor(doc, config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            config.value.emitter.on('change', this.onValueChange_);
            this.value = config.value;
            this.element = doc.createElement('div');
            this.element.classList.add(className$6());
            config.viewProps.bindClassModifiers(this.element);
            const swatchElem = doc.createElement('div');
            swatchElem.classList.add(className$6('sw'));
            this.element.appendChild(swatchElem);
            this.swatchElem_ = swatchElem;
            const buttonElem = doc.createElement('button');
            buttonElem.classList.add(className$6('b'));
            config.viewProps.bindDisabled(buttonElem);
            this.element.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            this.update_();
        }
        update_() {
            const value = this.value.rawValue;
            this.swatchElem_.style.backgroundColor = colorToHexRgbaString(value);
        }
        onValueChange_() {
            this.update_();
        }
    }

    class ColorSwatchController {
        constructor(doc, config) {
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new ColorSwatchView(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
        }
    }

    class ColorController {
        constructor(doc, config) {
            this.onButtonBlur_ = this.onButtonBlur_.bind(this);
            this.onButtonClick_ = this.onButtonClick_.bind(this);
            this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
            this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.foldable_ = Foldable.create(config.expanded);
            this.swatchC_ = new ColorSwatchController(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            const buttonElem = this.swatchC_.view.buttonElement;
            buttonElem.addEventListener('blur', this.onButtonBlur_);
            buttonElem.addEventListener('click', this.onButtonClick_);
            this.textC_ = new TextController(doc, {
                parser: config.parser,
                props: ValueMap.fromObject({
                    formatter: config.formatter,
                }),
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view = new ColorView(doc, {
                foldable: this.foldable_,
                pickerLayout: config.pickerLayout,
            });
            this.view.swatchElement.appendChild(this.swatchC_.view.element);
            this.view.textElement.appendChild(this.textC_.view.element);
            this.popC_ =
                config.pickerLayout === 'popup'
                    ? new PopupController(doc, {
                        viewProps: this.viewProps,
                    })
                    : null;
            const pickerC = new ColorPickerController(doc, {
                colorType: config.colorType,
                supportsAlpha: config.supportsAlpha,
                value: this.value,
                viewProps: this.viewProps,
            });
            pickerC.view.allFocusableElements.forEach((elem) => {
                elem.addEventListener('blur', this.onPopupChildBlur_);
                elem.addEventListener('keydown', this.onPopupChildKeydown_);
            });
            this.pickerC_ = pickerC;
            if (this.popC_) {
                this.view.element.appendChild(this.popC_.view.element);
                this.popC_.view.element.appendChild(pickerC.view.element);
                connectValues({
                    primary: this.foldable_.value('expanded'),
                    secondary: this.popC_.shows,
                    forward: (p) => p.rawValue,
                    backward: (_, s) => s.rawValue,
                });
            }
            else if (this.view.pickerElement) {
                this.view.pickerElement.appendChild(this.pickerC_.view.element);
                bindFoldable(this.foldable_, this.view.pickerElement);
            }
        }
        get textController() {
            return this.textC_;
        }
        onButtonBlur_(e) {
            if (!this.popC_) {
                return;
            }
            const elem = this.view.element;
            const nextTarget = forceCast(e.relatedTarget);
            if (!nextTarget || !elem.contains(nextTarget)) {
                this.popC_.shows.rawValue = false;
            }
        }
        onButtonClick_() {
            this.foldable_.set('expanded', !this.foldable_.get('expanded'));
            if (this.foldable_.get('expanded')) {
                this.pickerC_.view.allFocusableElements[0].focus();
            }
        }
        onPopupChildBlur_(ev) {
            if (!this.popC_) {
                return;
            }
            const elem = this.popC_.view.element;
            const nextTarget = findNextTarget(ev);
            if (nextTarget && elem.contains(nextTarget)) {
                return;
            }
            if (nextTarget &&
                nextTarget === this.swatchC_.view.buttonElement &&
                !supportsTouch(elem.ownerDocument)) {
                return;
            }
            this.popC_.shows.rawValue = false;
        }
        onPopupChildKeydown_(ev) {
            if (this.popC_) {
                if (ev.key === 'Escape') {
                    this.popC_.shows.rawValue = false;
                }
            }
            else if (this.view.pickerElement) {
                if (ev.key === 'Escape') {
                    this.swatchC_.view.buttonElement.focus();
                }
            }
        }
    }

    function colorFromObject(value, opt_type) {
        if (Color.isColorObject(value)) {
            return Color.fromObject(value, opt_type);
        }
        return Color.black(opt_type);
    }
    function colorToRgbNumber(value) {
        return removeAlphaComponent(value.getComponents('rgb')).reduce((result, comp) => {
            return (result << 8) | (Math.floor(comp) & 0xff);
        }, 0);
    }
    function colorToRgbaNumber(value) {
        return (value.getComponents('rgb').reduce((result, comp, index) => {
            const hex = Math.floor(index === 3 ? comp * 255 : comp) & 0xff;
            return (result << 8) | hex;
        }, 0) >>> 0);
    }
    function numberToRgbColor(num) {
        return new Color([(num >> 16) & 0xff, (num >> 8) & 0xff, num & 0xff], 'rgb');
    }
    function numberToRgbaColor(num) {
        return new Color([
            (num >> 24) & 0xff,
            (num >> 16) & 0xff,
            (num >> 8) & 0xff,
            mapRange(num & 0xff, 0, 255, 0, 1),
        ], 'rgb');
    }
    function colorFromRgbNumber(value) {
        if (typeof value !== 'number') {
            return Color.black();
        }
        return numberToRgbColor(value);
    }
    function colorFromRgbaNumber(value) {
        if (typeof value !== 'number') {
            return Color.black();
        }
        return numberToRgbaColor(value);
    }

    function createColorStringWriter(format) {
        const stringify = findColorStringifier(format);
        return stringify
            ? (target, value) => {
                writePrimitive(target, stringify(value));
            }
            : null;
    }
    function createColorNumberWriter(supportsAlpha) {
        const colorToNumber = supportsAlpha ? colorToRgbaNumber : colorToRgbNumber;
        return (target, value) => {
            writePrimitive(target, colorToNumber(value));
        };
    }
    function writeRgbaColorObject(target, value, opt_type) {
        const obj = value.toRgbaObject(opt_type);
        target.writeProperty('r', obj.r);
        target.writeProperty('g', obj.g);
        target.writeProperty('b', obj.b);
        target.writeProperty('a', obj.a);
    }
    function writeRgbColorObject(target, value, opt_type) {
        const obj = value.toRgbaObject(opt_type);
        target.writeProperty('r', obj.r);
        target.writeProperty('g', obj.g);
        target.writeProperty('b', obj.b);
    }
    function createColorObjectWriter(supportsAlpha, opt_type) {
        return (target, inValue) => {
            if (supportsAlpha) {
                writeRgbaColorObject(target, inValue, opt_type);
            }
            else {
                writeRgbColorObject(target, inValue, opt_type);
            }
        };
    }

    function shouldSupportAlpha$1(inputParams) {
        var _a;
        if ((inputParams === null || inputParams === void 0 ? void 0 : inputParams.alpha) || ((_a = inputParams === null || inputParams === void 0 ? void 0 : inputParams.color) === null || _a === void 0 ? void 0 : _a.alpha)) {
            return true;
        }
        return false;
    }
    function createFormatter$1(supportsAlpha) {
        return supportsAlpha
            ? (v) => colorToHexRgbaString(v, '0x')
            : (v) => colorToHexRgbString(v, '0x');
    }
    function isForColor(params) {
        if ('color' in params) {
            return true;
        }
        if ('view' in params && params.view === 'color') {
            return true;
        }
        return false;
    }
    const NumberColorInputPlugin = {
        id: 'input-color-number',
        type: 'input',
        accept: (value, params) => {
            if (typeof value !== 'number') {
                return null;
            }
            if (!isForColor(params)) {
                return null;
            }
            const result = parseColorInputParams(params);
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (args) => {
                return shouldSupportAlpha$1(args.params)
                    ? colorFromRgbaNumber
                    : colorFromRgbNumber;
            },
            equals: Color.equals,
            writer: (args) => {
                return createColorNumberWriter(shouldSupportAlpha$1(args.params));
            },
        },
        controller: (args) => {
            const supportsAlpha = shouldSupportAlpha$1(args.params);
            const expanded = 'expanded' in args.params ? args.params.expanded : undefined;
            const picker = 'picker' in args.params ? args.params.picker : undefined;
            return new ColorController(args.document, {
                colorType: 'int',
                expanded: expanded !== null && expanded !== void 0 ? expanded : false,
                formatter: createFormatter$1(supportsAlpha),
                parser: createColorStringParser('int'),
                pickerLayout: picker !== null && picker !== void 0 ? picker : 'popup',
                supportsAlpha: supportsAlpha,
                value: args.value,
                viewProps: args.viewProps,
            });
        },
    };

    function shouldSupportAlpha(initialValue) {
        return Color.isRgbaColorObject(initialValue);
    }
    function createColorObjectReader(opt_type) {
        return (value) => {
            return colorFromObject(value, opt_type);
        };
    }
    function createColorObjectFormatter(supportsAlpha, type) {
        return (value) => {
            if (supportsAlpha) {
                return colorToObjectRgbaString(value, type);
            }
            return colorToObjectRgbString(value, type);
        };
    }
    const ObjectColorInputPlugin = {
        id: 'input-color-object',
        type: 'input',
        accept: (value, params) => {
            if (!Color.isColorObject(value)) {
                return null;
            }
            const result = parseColorInputParams(params);
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (args) => createColorObjectReader(extractColorType(args.params)),
            equals: Color.equals,
            writer: (args) => createColorObjectWriter(shouldSupportAlpha(args.initialValue), extractColorType(args.params)),
        },
        controller: (args) => {
            var _a;
            const supportsAlpha = Color.isRgbaColorObject(args.initialValue);
            const expanded = 'expanded' in args.params ? args.params.expanded : undefined;
            const picker = 'picker' in args.params ? args.params.picker : undefined;
            const type = (_a = extractColorType(args.params)) !== null && _a !== void 0 ? _a : 'int';
            return new ColorController(args.document, {
                colorType: type,
                expanded: expanded !== null && expanded !== void 0 ? expanded : false,
                formatter: createColorObjectFormatter(supportsAlpha, type),
                parser: createColorStringParser(type),
                pickerLayout: picker !== null && picker !== void 0 ? picker : 'popup',
                supportsAlpha: supportsAlpha,
                value: args.value,
                viewProps: args.viewProps,
            });
        },
    };

    const StringColorInputPlugin = {
        id: 'input-color-string',
        type: 'input',
        accept: (value, params) => {
            if (typeof value !== 'string') {
                return null;
            }
            if ('view' in params && params.view === 'text') {
                return null;
            }
            const format = detectStringColorFormat(value, extractColorType(params));
            if (!format) {
                return null;
            }
            const stringifier = findColorStringifier(format);
            if (!stringifier) {
                return null;
            }
            const result = parseColorInputParams(params);
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (args) => { var _a; return createColorStringBindingReader((_a = extractColorType(args.params)) !== null && _a !== void 0 ? _a : 'int'); },
            equals: Color.equals,
            writer: (args) => {
                const format = detectStringColorFormat(args.initialValue, extractColorType(args.params));
                if (!format) {
                    throw TpError.shouldNeverHappen();
                }
                const writer = createColorStringWriter(format);
                if (!writer) {
                    throw TpError.notBindable();
                }
                return writer;
            },
        },
        controller: (args) => {
            const format = detectStringColorFormat(args.initialValue, extractColorType(args.params));
            if (!format) {
                throw TpError.shouldNeverHappen();
            }
            const stringifier = findColorStringifier(format);
            if (!stringifier) {
                throw TpError.shouldNeverHappen();
            }
            const expanded = 'expanded' in args.params ? args.params.expanded : undefined;
            const picker = 'picker' in args.params ? args.params.picker : undefined;
            return new ColorController(args.document, {
                colorType: format.type,
                expanded: expanded !== null && expanded !== void 0 ? expanded : false,
                formatter: stringifier,
                parser: createColorStringParser(format.type),
                pickerLayout: picker !== null && picker !== void 0 ? picker : 'popup',
                supportsAlpha: format.alpha,
                value: args.value,
                viewProps: args.viewProps,
            });
        },
    };

    class PointNdConstraint {
        constructor(config) {
            this.components = config.components;
            this.asm_ = config.assembly;
        }
        constrain(value) {
            const comps = this.asm_
                .toComponents(value)
                .map((comp, index) => { var _a, _b; return (_b = (_a = this.components[index]) === null || _a === void 0 ? void 0 : _a.constrain(comp)) !== null && _b !== void 0 ? _b : comp; });
            return this.asm_.fromComponents(comps);
        }
    }

    const className$5 = ClassName('pndtxt');
    class PointNdTextView {
        constructor(doc, config) {
            this.textViews = config.textViews;
            this.element = doc.createElement('div');
            this.element.classList.add(className$5());
            this.textViews.forEach((v) => {
                const axisElem = doc.createElement('div');
                axisElem.classList.add(className$5('a'));
                axisElem.appendChild(v.element);
                this.element.appendChild(axisElem);
            });
        }
    }

    function createAxisController(doc, config, index) {
        return new NumberTextController(doc, {
            arrayPosition: index === 0 ? 'fst' : index === config.axes.length - 1 ? 'lst' : 'mid',
            baseStep: config.axes[index].baseStep,
            parser: config.parser,
            props: config.axes[index].textProps,
            value: createValue(0, {
                constraint: config.axes[index].constraint,
            }),
            viewProps: config.viewProps,
        });
    }
    class PointNdTextController {
        constructor(doc, config) {
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.acs_ = config.axes.map((_, index) => createAxisController(doc, config, index));
            this.acs_.forEach((c, index) => {
                connectValues({
                    primary: this.value,
                    secondary: c.value,
                    forward: (p) => {
                        return config.assembly.toComponents(p.rawValue)[index];
                    },
                    backward: (p, s) => {
                        const comps = config.assembly.toComponents(p.rawValue);
                        comps[index] = s.rawValue;
                        return config.assembly.fromComponents(comps);
                    },
                });
            });
            this.view = new PointNdTextView(doc, {
                textViews: this.acs_.map((ac) => ac.view),
            });
        }
    }

    function createStepConstraint(params, initialValue) {
        if ('step' in params && !isEmpty(params.step)) {
            return new StepConstraint(params.step, initialValue);
        }
        return null;
    }
    function createRangeConstraint(params) {
        if (!isEmpty(params.max) && !isEmpty(params.min)) {
            return new DefiniteRangeConstraint({
                max: params.max,
                min: params.min,
            });
        }
        if (!isEmpty(params.max) || !isEmpty(params.min)) {
            return new RangeConstraint({
                max: params.max,
                min: params.min,
            });
        }
        return null;
    }
    function findNumberRange(c) {
        const drc = findConstraint(c, DefiniteRangeConstraint);
        if (drc) {
            return [drc.values.get('min'), drc.values.get('max')];
        }
        const rc = findConstraint(c, RangeConstraint);
        if (rc) {
            return [rc.minValue, rc.maxValue];
        }
        return [undefined, undefined];
    }
    function createConstraint$4(params,
    initialValue) {
        const constraints = [];
        const sc = createStepConstraint(params, initialValue);
        if (sc) {
            constraints.push(sc);
        }
        const rc = createRangeConstraint(params);
        if (rc) {
            constraints.push(rc);
        }
        const lc = createListConstraint(params.options);
        if (lc) {
            constraints.push(lc);
        }
        return new CompositeConstraint(constraints);
    }
    const NumberInputPlugin = {
        id: 'input-number',
        type: 'input',
        accept: (value, params) => {
            if (typeof value !== 'number') {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                format: p.optional.function,
                max: p.optional.number,
                min: p.optional.number,
                options: p.optional.custom(parseListOptions),
                step: p.optional.number,
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => numberFromUnknown,
            constraint: (args) => createConstraint$4(args.params, args.initialValue),
            writer: (_args) => writePrimitive,
        },
        controller: (args) => {
            var _a;
            const value = args.value;
            const c = args.constraint;
            const lc = c && findConstraint(c, ListConstraint);
            if (lc) {
                return new ListController(args.document, {
                    props: new ValueMap({
                        options: lc.values.value('options'),
                    }),
                    value: value,
                    viewProps: args.viewProps,
                });
            }
            const formatter = (_a = ('format' in args.params ? args.params.format : undefined)) !== null && _a !== void 0 ? _a : createNumberFormatter(getSuitableDecimalDigits(c, value.rawValue));
            const drc = c && findConstraint(c, DefiniteRangeConstraint);
            if (drc) {
                return new SliderTextController(args.document, {
                    baseStep: getBaseStep(c),
                    parser: parseNumber,
                    sliderProps: new ValueMap({
                        maxValue: drc.values.value('max'),
                        minValue: drc.values.value('min'),
                    }),
                    textProps: ValueMap.fromObject({
                        draggingScale: getSuitableDraggingScale(c, value.rawValue),
                        formatter: formatter,
                    }),
                    value: value,
                    viewProps: args.viewProps,
                });
            }
            return new NumberTextController(args.document, {
                baseStep: getBaseStep(c),
                parser: parseNumber,
                props: ValueMap.fromObject({
                    draggingScale: getSuitableDraggingScale(c, value.rawValue),
                    formatter: formatter,
                }),
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    class Point2d {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        getComponents() {
            return [this.x, this.y];
        }
        static isObject(obj) {
            if (isEmpty(obj)) {
                return false;
            }
            const x = obj.x;
            const y = obj.y;
            if (typeof x !== 'number' || typeof y !== 'number') {
                return false;
            }
            return true;
        }
        static equals(v1, v2) {
            return v1.x === v2.x && v1.y === v2.y;
        }
        toObject() {
            return {
                x: this.x,
                y: this.y,
            };
        }
    }
    const Point2dAssembly = {
        toComponents: (p) => p.getComponents(),
        fromComponents: (comps) => new Point2d(...comps),
    };

    const className$4 = ClassName('p2d');
    class Point2dView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$4());
            config.viewProps.bindClassModifiers(this.element);
            bindValue(config.expanded, valueToClassName(this.element, className$4(undefined, 'expanded')));
            const headElem = doc.createElement('div');
            headElem.classList.add(className$4('h'));
            this.element.appendChild(headElem);
            const buttonElem = doc.createElement('button');
            buttonElem.classList.add(className$4('b'));
            buttonElem.appendChild(createSvgIconElement(doc, 'p2dpad'));
            config.viewProps.bindDisabled(buttonElem);
            headElem.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            const textElem = doc.createElement('div');
            textElem.classList.add(className$4('t'));
            headElem.appendChild(textElem);
            this.textElement = textElem;
            if (config.pickerLayout === 'inline') {
                const pickerElem = doc.createElement('div');
                pickerElem.classList.add(className$4('p'));
                this.element.appendChild(pickerElem);
                this.pickerElement = pickerElem;
            }
            else {
                this.pickerElement = null;
            }
        }
    }

    const className$3 = ClassName('p2dp');
    class Point2dPickerView {
        constructor(doc, config) {
            this.onFoldableChange_ = this.onFoldableChange_.bind(this);
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.invertsY_ = config.invertsY;
            this.maxValue_ = config.maxValue;
            this.element = doc.createElement('div');
            this.element.classList.add(className$3());
            if (config.layout === 'popup') {
                this.element.classList.add(className$3(undefined, 'p'));
            }
            config.viewProps.bindClassModifiers(this.element);
            const padElem = doc.createElement('div');
            padElem.classList.add(className$3('p'));
            config.viewProps.bindTabIndex(padElem);
            this.element.appendChild(padElem);
            this.padElement = padElem;
            const svgElem = doc.createElementNS(SVG_NS, 'svg');
            svgElem.classList.add(className$3('g'));
            this.padElement.appendChild(svgElem);
            this.svgElem_ = svgElem;
            const xAxisElem = doc.createElementNS(SVG_NS, 'line');
            xAxisElem.classList.add(className$3('ax'));
            xAxisElem.setAttributeNS(null, 'x1', '0');
            xAxisElem.setAttributeNS(null, 'y1', '50%');
            xAxisElem.setAttributeNS(null, 'x2', '100%');
            xAxisElem.setAttributeNS(null, 'y2', '50%');
            this.svgElem_.appendChild(xAxisElem);
            const yAxisElem = doc.createElementNS(SVG_NS, 'line');
            yAxisElem.classList.add(className$3('ax'));
            yAxisElem.setAttributeNS(null, 'x1', '50%');
            yAxisElem.setAttributeNS(null, 'y1', '0');
            yAxisElem.setAttributeNS(null, 'x2', '50%');
            yAxisElem.setAttributeNS(null, 'y2', '100%');
            this.svgElem_.appendChild(yAxisElem);
            const lineElem = doc.createElementNS(SVG_NS, 'line');
            lineElem.classList.add(className$3('l'));
            lineElem.setAttributeNS(null, 'x1', '50%');
            lineElem.setAttributeNS(null, 'y1', '50%');
            this.svgElem_.appendChild(lineElem);
            this.lineElem_ = lineElem;
            const markerElem = doc.createElement('div');
            markerElem.classList.add(className$3('m'));
            this.padElement.appendChild(markerElem);
            this.markerElem_ = markerElem;
            config.value.emitter.on('change', this.onValueChange_);
            this.value = config.value;
            this.update_();
        }
        get allFocusableElements() {
            return [this.padElement];
        }
        update_() {
            const [x, y] = this.value.rawValue.getComponents();
            const max = this.maxValue_;
            const px = mapRange(x, -max, +max, 0, 100);
            const py = mapRange(y, -max, +max, 0, 100);
            const ipy = this.invertsY_ ? 100 - py : py;
            this.lineElem_.setAttributeNS(null, 'x2', `${px}%`);
            this.lineElem_.setAttributeNS(null, 'y2', `${ipy}%`);
            this.markerElem_.style.left = `${px}%`;
            this.markerElem_.style.top = `${ipy}%`;
        }
        onValueChange_() {
            this.update_();
        }
        onFoldableChange_() {
            this.update_();
        }
    }

    function computeOffset(ev, baseSteps, invertsY) {
        return [
            getStepForKey(baseSteps[0], getHorizontalStepKeys(ev)),
            getStepForKey(baseSteps[1], getVerticalStepKeys(ev)) * (invertsY ? 1 : -1),
        ];
    }
    class Point2dPickerController {
        constructor(doc, config) {
            this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
            this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.baseSteps_ = config.baseSteps;
            this.maxValue_ = config.maxValue;
            this.invertsY_ = config.invertsY;
            this.view = new Point2dPickerView(doc, {
                invertsY: this.invertsY_,
                layout: config.layout,
                maxValue: this.maxValue_,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.ptHandler_ = new PointerHandler(this.view.padElement);
            this.ptHandler_.emitter.on('down', this.onPointerDown_);
            this.ptHandler_.emitter.on('move', this.onPointerMove_);
            this.ptHandler_.emitter.on('up', this.onPointerUp_);
            this.view.padElement.addEventListener('keydown', this.onPadKeyDown_);
            this.view.padElement.addEventListener('keyup', this.onPadKeyUp_);
        }
        handlePointerEvent_(d, opts) {
            if (!d.point) {
                return;
            }
            const max = this.maxValue_;
            const px = mapRange(d.point.x, 0, d.bounds.width, -max, +max);
            const py = mapRange(this.invertsY_ ? d.bounds.height - d.point.y : d.point.y, 0, d.bounds.height, -max, +max);
            this.value.setRawValue(new Point2d(px, py), opts);
        }
        onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true,
            });
        }
        onPadKeyDown_(ev) {
            if (isArrowKey(ev.key)) {
                ev.preventDefault();
            }
            const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
            if (dx === 0 && dy === 0) {
                return;
            }
            this.value.setRawValue(new Point2d(this.value.rawValue.x + dx, this.value.rawValue.y + dy), {
                forceEmit: false,
                last: false,
            });
        }
        onPadKeyUp_(ev) {
            const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
            if (dx === 0 && dy === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true,
            });
        }
    }

    class Point2dController {
        constructor(doc, config) {
            var _a, _b;
            this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
            this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
            this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
            this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.foldable_ = Foldable.create(config.expanded);
            this.popC_ =
                config.pickerLayout === 'popup'
                    ? new PopupController(doc, {
                        viewProps: this.viewProps,
                    })
                    : null;
            const padC = new Point2dPickerController(doc, {
                baseSteps: [config.axes[0].baseStep, config.axes[1].baseStep],
                invertsY: config.invertsY,
                layout: config.pickerLayout,
                maxValue: config.maxValue,
                value: this.value,
                viewProps: this.viewProps,
            });
            padC.view.allFocusableElements.forEach((elem) => {
                elem.addEventListener('blur', this.onPopupChildBlur_);
                elem.addEventListener('keydown', this.onPopupChildKeydown_);
            });
            this.pickerC_ = padC;
            this.textC_ = new PointNdTextController(doc, {
                assembly: Point2dAssembly,
                axes: config.axes,
                parser: config.parser,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view = new Point2dView(doc, {
                expanded: this.foldable_.value('expanded'),
                pickerLayout: config.pickerLayout,
                viewProps: this.viewProps,
            });
            this.view.textElement.appendChild(this.textC_.view.element);
            (_a = this.view.buttonElement) === null || _a === void 0 ? void 0 : _a.addEventListener('blur', this.onPadButtonBlur_);
            (_b = this.view.buttonElement) === null || _b === void 0 ? void 0 : _b.addEventListener('click', this.onPadButtonClick_);
            if (this.popC_) {
                this.view.element.appendChild(this.popC_.view.element);
                this.popC_.view.element.appendChild(this.pickerC_.view.element);
                connectValues({
                    primary: this.foldable_.value('expanded'),
                    secondary: this.popC_.shows,
                    forward: (p) => p.rawValue,
                    backward: (_, s) => s.rawValue,
                });
            }
            else if (this.view.pickerElement) {
                this.view.pickerElement.appendChild(this.pickerC_.view.element);
                bindFoldable(this.foldable_, this.view.pickerElement);
            }
        }
        onPadButtonBlur_(e) {
            if (!this.popC_) {
                return;
            }
            const elem = this.view.element;
            const nextTarget = forceCast(e.relatedTarget);
            if (!nextTarget || !elem.contains(nextTarget)) {
                this.popC_.shows.rawValue = false;
            }
        }
        onPadButtonClick_() {
            this.foldable_.set('expanded', !this.foldable_.get('expanded'));
            if (this.foldable_.get('expanded')) {
                this.pickerC_.view.allFocusableElements[0].focus();
            }
        }
        onPopupChildBlur_(ev) {
            if (!this.popC_) {
                return;
            }
            const elem = this.popC_.view.element;
            const nextTarget = findNextTarget(ev);
            if (nextTarget && elem.contains(nextTarget)) {
                return;
            }
            if (nextTarget &&
                nextTarget === this.view.buttonElement &&
                !supportsTouch(elem.ownerDocument)) {
                return;
            }
            this.popC_.shows.rawValue = false;
        }
        onPopupChildKeydown_(ev) {
            if (this.popC_) {
                if (ev.key === 'Escape') {
                    this.popC_.shows.rawValue = false;
                }
            }
            else if (this.view.pickerElement) {
                if (ev.key === 'Escape') {
                    this.view.buttonElement.focus();
                }
            }
        }
    }

    class Point3d {
        constructor(x = 0, y = 0, z = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        getComponents() {
            return [this.x, this.y, this.z];
        }
        static isObject(obj) {
            if (isEmpty(obj)) {
                return false;
            }
            const x = obj.x;
            const y = obj.y;
            const z = obj.z;
            if (typeof x !== 'number' ||
                typeof y !== 'number' ||
                typeof z !== 'number') {
                return false;
            }
            return true;
        }
        static equals(v1, v2) {
            return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
        }
        toObject() {
            return {
                x: this.x,
                y: this.y,
                z: this.z,
            };
        }
    }
    const Point3dAssembly = {
        toComponents: (p) => p.getComponents(),
        fromComponents: (comps) => new Point3d(...comps),
    };

    function point3dFromUnknown(value) {
        return Point3d.isObject(value)
            ? new Point3d(value.x, value.y, value.z)
            : new Point3d();
    }
    function writePoint3d(target, value) {
        target.writeProperty('x', value.x);
        target.writeProperty('y', value.y);
        target.writeProperty('z', value.z);
    }

    function createConstraint$3(params, initialValue) {
        return new PointNdConstraint({
            assembly: Point3dAssembly,
            components: [
                createDimensionConstraint('x' in params ? params.x : undefined, initialValue.x),
                createDimensionConstraint('y' in params ? params.y : undefined, initialValue.y),
                createDimensionConstraint('z' in params ? params.z : undefined, initialValue.z),
            ],
        });
    }
    function createAxis$2(initialValue, constraint) {
        return {
            baseStep: getBaseStep(constraint),
            constraint: constraint,
            textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(constraint, initialValue),
                formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue)),
            }),
        };
    }
    const Point3dInputPlugin = {
        id: 'input-point3d',
        type: 'input',
        accept: (value, params) => {
            if (!Point3d.isObject(value)) {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                x: p.optional.custom(parsePointDimensionParams),
                y: p.optional.custom(parsePointDimensionParams),
                z: p.optional.custom(parsePointDimensionParams),
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => point3dFromUnknown,
            constraint: (args) => createConstraint$3(args.params, args.initialValue),
            equals: Point3d.equals,
            writer: (_args) => writePoint3d,
        },
        controller: (args) => {
            const value = args.value;
            const c = args.constraint;
            if (!(c instanceof PointNdConstraint)) {
                throw TpError.shouldNeverHappen();
            }
            return new PointNdTextController(args.document, {
                assembly: Point3dAssembly,
                axes: [
                    createAxis$2(value.rawValue.x, c.components[0]),
                    createAxis$2(value.rawValue.y, c.components[1]),
                    createAxis$2(value.rawValue.z, c.components[2]),
                ],
                parser: parseNumber,
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    class Point4d {
        constructor(x = 0, y = 0, z = 0, w = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        getComponents() {
            return [this.x, this.y, this.z, this.w];
        }
        static isObject(obj) {
            if (isEmpty(obj)) {
                return false;
            }
            const x = obj.x;
            const y = obj.y;
            const z = obj.z;
            const w = obj.w;
            if (typeof x !== 'number' ||
                typeof y !== 'number' ||
                typeof z !== 'number' ||
                typeof w !== 'number') {
                return false;
            }
            return true;
        }
        static equals(v1, v2) {
            return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
        }
        toObject() {
            return {
                x: this.x,
                y: this.y,
                z: this.z,
                w: this.w,
            };
        }
    }
    const Point4dAssembly = {
        toComponents: (p) => p.getComponents(),
        fromComponents: (comps) => new Point4d(...comps),
    };

    function point4dFromUnknown(value) {
        return Point4d.isObject(value)
            ? new Point4d(value.x, value.y, value.z, value.w)
            : new Point4d();
    }
    function writePoint4d(target, value) {
        target.writeProperty('x', value.x);
        target.writeProperty('y', value.y);
        target.writeProperty('z', value.z);
        target.writeProperty('w', value.w);
    }

    function createConstraint$2(params, initialValue) {
        return new PointNdConstraint({
            assembly: Point4dAssembly,
            components: [
                createDimensionConstraint('x' in params ? params.x : undefined, initialValue.x),
                createDimensionConstraint('y' in params ? params.y : undefined, initialValue.y),
                createDimensionConstraint('z' in params ? params.z : undefined, initialValue.z),
                createDimensionConstraint('w' in params ? params.w : undefined, initialValue.w),
            ],
        });
    }
    function createAxis$1(initialValue, constraint) {
        return {
            baseStep: getBaseStep(constraint),
            constraint: constraint,
            textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(constraint, initialValue),
                formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue)),
            }),
        };
    }
    const Point4dInputPlugin = {
        id: 'input-point4d',
        type: 'input',
        accept: (value, params) => {
            if (!Point4d.isObject(value)) {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                x: p.optional.custom(parsePointDimensionParams),
                y: p.optional.custom(parsePointDimensionParams),
                z: p.optional.custom(parsePointDimensionParams),
                w: p.optional.custom(parsePointDimensionParams),
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => point4dFromUnknown,
            constraint: (args) => createConstraint$2(args.params, args.initialValue),
            equals: Point4d.equals,
            writer: (_args) => writePoint4d,
        },
        controller: (args) => {
            const value = args.value;
            const c = args.constraint;
            if (!(c instanceof PointNdConstraint)) {
                throw TpError.shouldNeverHappen();
            }
            return new PointNdTextController(args.document, {
                assembly: Point4dAssembly,
                axes: value.rawValue
                    .getComponents()
                    .map((comp, index) => createAxis$1(comp, c.components[index])),
                parser: parseNumber,
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    function createConstraint$1(params) {
        const constraints = [];
        const lc = createListConstraint(params.options);
        if (lc) {
            constraints.push(lc);
        }
        return new CompositeConstraint(constraints);
    }
    const StringInputPlugin = {
        id: 'input-string',
        type: 'input',
        accept: (value, params) => {
            if (typeof value !== 'string') {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                options: p.optional.custom(parseListOptions),
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => stringFromUnknown,
            constraint: (args) => createConstraint$1(args.params),
            writer: (_args) => writePrimitive,
        },
        controller: (args) => {
            const doc = args.document;
            const value = args.value;
            const c = args.constraint;
            const lc = c && findConstraint(c, ListConstraint);
            if (lc) {
                return new ListController(doc, {
                    props: new ValueMap({
                        options: lc.values.value('options'),
                    }),
                    value: value,
                    viewProps: args.viewProps,
                });
            }
            return new TextController(doc, {
                parser: (v) => v,
                props: ValueMap.fromObject({
                    formatter: formatString,
                }),
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    const Constants = {
        monitor: {
            defaultInterval: 200,
            defaultLineCount: 3,
        },
    };

    const className$2 = ClassName('mll');
    class MultiLogView {
        constructor(doc, config) {
            this.onValueUpdate_ = this.onValueUpdate_.bind(this);
            this.formatter_ = config.formatter;
            this.element = doc.createElement('div');
            this.element.classList.add(className$2());
            config.viewProps.bindClassModifiers(this.element);
            const textareaElem = doc.createElement('textarea');
            textareaElem.classList.add(className$2('i'));
            textareaElem.style.height = `calc(var(--bld-us) * ${config.lineCount})`;
            textareaElem.readOnly = true;
            config.viewProps.bindDisabled(textareaElem);
            this.element.appendChild(textareaElem);
            this.textareaElem_ = textareaElem;
            config.value.emitter.on('change', this.onValueUpdate_);
            this.value = config.value;
            this.update_();
        }
        update_() {
            const elem = this.textareaElem_;
            const shouldScroll = elem.scrollTop === elem.scrollHeight - elem.clientHeight;
            const lines = [];
            this.value.rawValue.forEach((value) => {
                if (value !== undefined) {
                    lines.push(this.formatter_(value));
                }
            });
            elem.textContent = lines.join('\n');
            if (shouldScroll) {
                elem.scrollTop = elem.scrollHeight;
            }
        }
        onValueUpdate_() {
            this.update_();
        }
    }

    class MultiLogController {
        constructor(doc, config) {
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new MultiLogView(doc, {
                formatter: config.formatter,
                lineCount: config.lineCount,
                value: this.value,
                viewProps: this.viewProps,
            });
        }
    }

    const className$1 = ClassName('sgl');
    class SingleLogView {
        constructor(doc, config) {
            this.onValueUpdate_ = this.onValueUpdate_.bind(this);
            this.formatter_ = config.formatter;
            this.element = doc.createElement('div');
            this.element.classList.add(className$1());
            config.viewProps.bindClassModifiers(this.element);
            const inputElem = doc.createElement('input');
            inputElem.classList.add(className$1('i'));
            inputElem.readOnly = true;
            inputElem.type = 'text';
            config.viewProps.bindDisabled(inputElem);
            this.element.appendChild(inputElem);
            this.inputElement = inputElem;
            config.value.emitter.on('change', this.onValueUpdate_);
            this.value = config.value;
            this.update_();
        }
        update_() {
            const values = this.value.rawValue;
            const lastValue = values[values.length - 1];
            this.inputElement.value =
                lastValue !== undefined ? this.formatter_(lastValue) : '';
        }
        onValueUpdate_() {
            this.update_();
        }
    }

    class SingleLogController {
        constructor(doc, config) {
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new SingleLogView(doc, {
                formatter: config.formatter,
                value: this.value,
                viewProps: this.viewProps,
            });
        }
    }

    const BooleanMonitorPlugin = {
        id: 'monitor-bool',
        type: 'monitor',
        accept: (value, params) => {
            if (typeof value !== 'boolean') {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                lineCount: p.optional.number,
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => boolFromUnknown,
        },
        controller: (args) => {
            var _a;
            if (args.value.rawValue.length === 1) {
                return new SingleLogController(args.document, {
                    formatter: BooleanFormatter,
                    value: args.value,
                    viewProps: args.viewProps,
                });
            }
            return new MultiLogController(args.document, {
                formatter: BooleanFormatter,
                lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
                value: args.value,
                viewProps: args.viewProps,
            });
        },
    };

    const className = ClassName('grl');
    class GraphLogView {
        constructor(doc, config) {
            this.onCursorChange_ = this.onCursorChange_.bind(this);
            this.onValueUpdate_ = this.onValueUpdate_.bind(this);
            this.element = doc.createElement('div');
            this.element.classList.add(className());
            config.viewProps.bindClassModifiers(this.element);
            this.formatter_ = config.formatter;
            this.props_ = config.props;
            this.cursor_ = config.cursor;
            this.cursor_.emitter.on('change', this.onCursorChange_);
            const svgElem = doc.createElementNS(SVG_NS, 'svg');
            svgElem.classList.add(className('g'));
            svgElem.style.height = `calc(var(--bld-us) * ${config.lineCount})`;
            this.element.appendChild(svgElem);
            this.svgElem_ = svgElem;
            const lineElem = doc.createElementNS(SVG_NS, 'polyline');
            this.svgElem_.appendChild(lineElem);
            this.lineElem_ = lineElem;
            const tooltipElem = doc.createElement('div');
            tooltipElem.classList.add(className('t'), ClassName('tt')());
            this.element.appendChild(tooltipElem);
            this.tooltipElem_ = tooltipElem;
            config.value.emitter.on('change', this.onValueUpdate_);
            this.value = config.value;
            this.update_();
        }
        get graphElement() {
            return this.svgElem_;
        }
        update_() {
            const bounds = this.svgElem_.getBoundingClientRect();
            const maxIndex = this.value.rawValue.length - 1;
            const min = this.props_.get('minValue');
            const max = this.props_.get('maxValue');
            const points = [];
            this.value.rawValue.forEach((v, index) => {
                if (v === undefined) {
                    return;
                }
                const x = mapRange(index, 0, maxIndex, 0, bounds.width);
                const y = mapRange(v, min, max, bounds.height, 0);
                points.push([x, y].join(','));
            });
            this.lineElem_.setAttributeNS(null, 'points', points.join(' '));
            const tooltipElem = this.tooltipElem_;
            const value = this.value.rawValue[this.cursor_.rawValue];
            if (value === undefined) {
                tooltipElem.classList.remove(className('t', 'a'));
                return;
            }
            const tx = mapRange(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
            const ty = mapRange(value, min, max, bounds.height, 0);
            tooltipElem.style.left = `${tx}px`;
            tooltipElem.style.top = `${ty}px`;
            tooltipElem.textContent = `${this.formatter_(value)}`;
            if (!tooltipElem.classList.contains(className('t', 'a'))) {
                tooltipElem.classList.add(className('t', 'a'), className('t', 'in'));
                forceReflow(tooltipElem);
                tooltipElem.classList.remove(className('t', 'in'));
            }
        }
        onValueUpdate_() {
            this.update_();
        }
        onCursorChange_() {
            this.update_();
        }
    }

    class GraphLogController {
        constructor(doc, config) {
            this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
            this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
            this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
            this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
            this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
            this.props_ = config.props;
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.cursor_ = createValue(-1);
            this.view = new GraphLogView(doc, {
                cursor: this.cursor_,
                formatter: config.formatter,
                lineCount: config.lineCount,
                props: this.props_,
                value: this.value,
                viewProps: this.viewProps,
            });
            if (!supportsTouch(doc)) {
                this.view.element.addEventListener('mousemove', this.onGraphMouseMove_);
                this.view.element.addEventListener('mouseleave', this.onGraphMouseLeave_);
            }
            else {
                const ph = new PointerHandler(this.view.element);
                ph.emitter.on('down', this.onGraphPointerDown_);
                ph.emitter.on('move', this.onGraphPointerMove_);
                ph.emitter.on('up', this.onGraphPointerUp_);
            }
        }
        onGraphMouseLeave_() {
            this.cursor_.rawValue = -1;
        }
        onGraphMouseMove_(ev) {
            const bounds = this.view.element.getBoundingClientRect();
            this.cursor_.rawValue = Math.floor(mapRange(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length));
        }
        onGraphPointerDown_(ev) {
            this.onGraphPointerMove_(ev);
        }
        onGraphPointerMove_(ev) {
            if (!ev.data.point) {
                this.cursor_.rawValue = -1;
                return;
            }
            this.cursor_.rawValue = Math.floor(mapRange(ev.data.point.x, 0, ev.data.bounds.width, 0, this.value.rawValue.length));
        }
        onGraphPointerUp_() {
            this.cursor_.rawValue = -1;
        }
    }

    function createFormatter(params) {
        return 'format' in params && !isEmpty(params.format)
            ? params.format
            : createNumberFormatter(2);
    }
    function createTextMonitor(args) {
        var _a;
        if (args.value.rawValue.length === 1) {
            return new SingleLogController(args.document, {
                formatter: createFormatter(args.params),
                value: args.value,
                viewProps: args.viewProps,
            });
        }
        return new MultiLogController(args.document, {
            formatter: createFormatter(args.params),
            lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
            value: args.value,
            viewProps: args.viewProps,
        });
    }
    function createGraphMonitor(args) {
        var _a, _b, _c;
        return new GraphLogController(args.document, {
            formatter: createFormatter(args.params),
            lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
            props: ValueMap.fromObject({
                maxValue: (_b = ('max' in args.params ? args.params.max : null)) !== null && _b !== void 0 ? _b : 100,
                minValue: (_c = ('min' in args.params ? args.params.min : null)) !== null && _c !== void 0 ? _c : 0,
            }),
            value: args.value,
            viewProps: args.viewProps,
        });
    }
    function shouldShowGraph(params) {
        return 'view' in params && params.view === 'graph';
    }
    const NumberMonitorPlugin = {
        id: 'monitor-number',
        type: 'monitor',
        accept: (value, params) => {
            if (typeof value !== 'number') {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                format: p.optional.function,
                lineCount: p.optional.number,
                max: p.optional.number,
                min: p.optional.number,
                view: p.optional.string,
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            defaultBufferSize: (params) => (shouldShowGraph(params) ? 64 : 1),
            reader: (_args) => numberFromUnknown,
        },
        controller: (args) => {
            if (shouldShowGraph(args.params)) {
                return createGraphMonitor(args);
            }
            return createTextMonitor(args);
        },
    };

    const StringMonitorPlugin = {
        id: 'monitor-string',
        type: 'monitor',
        accept: (value, params) => {
            if (typeof value !== 'string') {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                lineCount: p.optional.number,
                multiline: p.optional.boolean,
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => stringFromUnknown,
        },
        controller: (args) => {
            var _a;
            const value = args.value;
            const multiline = value.rawValue.length > 1 ||
                ('multiline' in args.params && args.params.multiline);
            if (multiline) {
                return new MultiLogController(args.document, {
                    formatter: formatString,
                    lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
                    value: value,
                    viewProps: args.viewProps,
                });
            }
            return new SingleLogController(args.document, {
                formatter: formatString,
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    function createInputBindingController(plugin, args) {
        var _a;
        const result = plugin.accept(args.target.read(), args.params);
        if (isEmpty(result)) {
            return null;
        }
        const p = ParamsParsers;
        const valueArgs = {
            target: args.target,
            initialValue: result.initialValue,
            params: result.params,
        };
        const reader = plugin.binding.reader(valueArgs);
        const constraint = plugin.binding.constraint
            ? plugin.binding.constraint(valueArgs)
            : undefined;
        const value = createValue(reader(result.initialValue), {
            constraint: constraint,
            equals: plugin.binding.equals,
        });
        const binding = new InputBinding({
            reader: reader,
            target: args.target,
            value: value,
            writer: plugin.binding.writer(valueArgs),
        });
        const disabled = p.optional.boolean(args.params.disabled).value;
        const hidden = p.optional.boolean(args.params.hidden).value;
        const controller = plugin.controller({
            constraint: constraint,
            document: args.document,
            initialValue: result.initialValue,
            params: result.params,
            value: binding.value,
            viewProps: ViewProps.create({
                disabled: disabled,
                hidden: hidden,
            }),
        });
        return new InputBindingController(args.document, {
            binding: binding,
            blade: createBlade(),
            props: ValueMap.fromObject({
                label: 'label' in args.params
                    ? (_a = p.optional.string(args.params.label).value) !== null && _a !== void 0 ? _a : null
                    : args.target.key,
            }),
            valueController: controller,
        });
    }

    function createTicker(document, interval) {
        return interval === 0
            ? new ManualTicker()
            : new IntervalTicker(document, interval !== null && interval !== void 0 ? interval : Constants.monitor.defaultInterval);
    }
    function createMonitorBindingController(plugin, args) {
        var _a, _b, _c;
        const p = ParamsParsers;
        const result = plugin.accept(args.target.read(), args.params);
        if (isEmpty(result)) {
            return null;
        }
        const bindingArgs = {
            target: args.target,
            initialValue: result.initialValue,
            params: result.params,
        };
        const reader = plugin.binding.reader(bindingArgs);
        const bufferSize = (_b = (_a = p.optional.number(args.params.bufferSize).value) !== null && _a !== void 0 ? _a : (plugin.binding.defaultBufferSize &&
            plugin.binding.defaultBufferSize(result.params))) !== null && _b !== void 0 ? _b : 1;
        const interval = p.optional.number(args.params.interval).value;
        const binding = new MonitorBinding({
            reader: reader,
            target: args.target,
            ticker: createTicker(args.document, interval),
            value: initializeBuffer(bufferSize),
        });
        const disabled = p.optional.boolean(args.params.disabled).value;
        const hidden = p.optional.boolean(args.params.hidden).value;
        const controller = plugin.controller({
            document: args.document,
            params: result.params,
            value: binding.value,
            viewProps: ViewProps.create({
                disabled: disabled,
                hidden: hidden,
            }),
        });
        return new MonitorBindingController(args.document, {
            binding: binding,
            blade: createBlade(),
            props: ValueMap.fromObject({
                label: 'label' in args.params
                    ? (_c = p.optional.string(args.params.label).value) !== null && _c !== void 0 ? _c : null
                    : args.target.key,
            }),
            valueController: controller,
        });
    }

    class PluginPool {
        constructor() {
            this.pluginsMap_ = {
                blades: [],
                inputs: [],
                monitors: [],
            };
        }
        getAll() {
            return [
                ...this.pluginsMap_.blades,
                ...this.pluginsMap_.inputs,
                ...this.pluginsMap_.monitors,
            ];
        }
        register(r) {
            if (r.type === 'blade') {
                this.pluginsMap_.blades.unshift(r);
            }
            else if (r.type === 'input') {
                this.pluginsMap_.inputs.unshift(r);
            }
            else if (r.type === 'monitor') {
                this.pluginsMap_.monitors.unshift(r);
            }
        }
        createInput(document, target, params) {
            const initialValue = target.read();
            if (isEmpty(initialValue)) {
                throw new TpError({
                    context: {
                        key: target.key,
                    },
                    type: 'nomatchingcontroller',
                });
            }
            const bc = this.pluginsMap_.inputs.reduce((result, plugin) => result !== null && result !== void 0 ? result : createInputBindingController(plugin, {
                document: document,
                target: target,
                params: params,
            }), null);
            if (bc) {
                return bc;
            }
            throw new TpError({
                context: {
                    key: target.key,
                },
                type: 'nomatchingcontroller',
            });
        }
        createMonitor(document, target, params) {
            const bc = this.pluginsMap_.monitors.reduce((result, plugin) => result !== null && result !== void 0 ? result : createMonitorBindingController(plugin, {
                document: document,
                params: params,
                target: target,
            }), null);
            if (bc) {
                return bc;
            }
            throw new TpError({
                context: {
                    key: target.key,
                },
                type: 'nomatchingcontroller',
            });
        }
        createBlade(document, params) {
            const bc = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : createBladeController(plugin, {
                document: document,
                params: params,
            }), null);
            if (!bc) {
                throw new TpError({
                    type: 'nomatchingview',
                    context: {
                        params: params,
                    },
                });
            }
            return bc;
        }
        createBladeApi(bc) {
            if (bc instanceof InputBindingController) {
                return new InputBindingApi(bc);
            }
            if (bc instanceof MonitorBindingController) {
                return new MonitorBindingApi(bc);
            }
            if (bc instanceof RackController) {
                return new RackApi(bc, this);
            }
            const api = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : plugin.api({
                controller: bc,
                pool: this,
            }), null);
            if (!api) {
                throw TpError.shouldNeverHappen();
            }
            return api;
        }
    }

    function createDefaultPluginPool() {
        const pool = new PluginPool();
        [
            Point2dInputPlugin,
            Point3dInputPlugin,
            Point4dInputPlugin,
            StringInputPlugin,
            NumberInputPlugin,
            StringColorInputPlugin,
            ObjectColorInputPlugin,
            NumberColorInputPlugin,
            BooleanInputPlugin,
            BooleanMonitorPlugin,
            StringMonitorPlugin,
            NumberMonitorPlugin,
            ButtonBladePlugin,
            FolderBladePlugin,
            SeparatorBladePlugin,
            TabBladePlugin,
        ].forEach((p) => {
            pool.register(p);
        });
        return pool;
    }

    function point2dFromUnknown(value) {
        return Point2d.isObject(value)
            ? new Point2d(value.x, value.y)
            : new Point2d();
    }
    function writePoint2d(target, value) {
        target.writeProperty('x', value.x);
        target.writeProperty('y', value.y);
    }

    function createDimensionConstraint(params, initialValue) {
        if (!params) {
            return undefined;
        }
        const constraints = [];
        const cs = createStepConstraint(params, initialValue);
        if (cs) {
            constraints.push(cs);
        }
        const rs = createRangeConstraint(params);
        if (rs) {
            constraints.push(rs);
        }
        return new CompositeConstraint(constraints);
    }
    function createConstraint(params, initialValue) {
        return new PointNdConstraint({
            assembly: Point2dAssembly,
            components: [
                createDimensionConstraint('x' in params ? params.x : undefined, initialValue.x),
                createDimensionConstraint('y' in params ? params.y : undefined, initialValue.y),
            ],
        });
    }
    function getSuitableMaxDimensionValue(constraint, rawValue) {
        const [min, max] = constraint ? findNumberRange(constraint) : [];
        if (!isEmpty(min) || !isEmpty(max)) {
            return Math.max(Math.abs(min !== null && min !== void 0 ? min : 0), Math.abs(max !== null && max !== void 0 ? max : 0));
        }
        const step = getBaseStep(constraint);
        return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
    }
    function getSuitableMaxValue(initialValue, constraint) {
        const xc = constraint instanceof PointNdConstraint
            ? constraint.components[0]
            : undefined;
        const yc = constraint instanceof PointNdConstraint
            ? constraint.components[1]
            : undefined;
        const xr = getSuitableMaxDimensionValue(xc, initialValue.x);
        const yr = getSuitableMaxDimensionValue(yc, initialValue.y);
        return Math.max(xr, yr);
    }
    function createAxis(initialValue, constraint) {
        return {
            baseStep: getBaseStep(constraint),
            constraint: constraint,
            textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(constraint, initialValue),
                formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue)),
            }),
        };
    }
    function shouldInvertY(params) {
        if (!('y' in params)) {
            return false;
        }
        const yParams = params.y;
        if (!yParams) {
            return false;
        }
        return 'inverted' in yParams ? !!yParams.inverted : false;
    }
    const Point2dInputPlugin = {
        id: 'input-point2d',
        type: 'input',
        accept: (value, params) => {
            if (!Point2d.isObject(value)) {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                expanded: p.optional.boolean,
                picker: p.optional.custom(parsePickerLayout),
                x: p.optional.custom(parsePointDimensionParams),
                y: p.optional.object({
                    inverted: p.optional.boolean,
                    max: p.optional.number,
                    min: p.optional.number,
                    step: p.optional.number,
                }),
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => point2dFromUnknown,
            constraint: (args) => createConstraint(args.params, args.initialValue),
            equals: Point2d.equals,
            writer: (_args) => writePoint2d,
        },
        controller: (args) => {
            const doc = args.document;
            const value = args.value;
            const c = args.constraint;
            if (!(c instanceof PointNdConstraint)) {
                throw TpError.shouldNeverHappen();
            }
            const expanded = 'expanded' in args.params ? args.params.expanded : undefined;
            const picker = 'picker' in args.params ? args.params.picker : undefined;
            return new Point2dController(doc, {
                axes: [
                    createAxis(value.rawValue.x, c.components[0]),
                    createAxis(value.rawValue.y, c.components[1]),
                ],
                expanded: expanded !== null && expanded !== void 0 ? expanded : false,
                invertsY: shouldInvertY(args.params),
                maxValue: getSuitableMaxValue(value.rawValue, c),
                parser: parseNumber,
                pickerLayout: picker !== null && picker !== void 0 ? picker : 'popup',
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    class ListApi extends BladeApi {
        constructor(controller) {
            super(controller);
            this.emitter_ = new Emitter();
            this.controller_.valueController.value.emitter.on('change', (ev) => {
                this.emitter_.emit('change', {
                    event: new TpChangeEvent(this, ev.rawValue),
                });
            });
        }
        get label() {
            return this.controller_.props.get('label');
        }
        set label(label) {
            this.controller_.props.set('label', label);
        }
        get options() {
            return this.controller_.valueController.props.get('options');
        }
        set options(options) {
            this.controller_.valueController.props.set('options', options);
        }
        get value() {
            return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
            this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
    }

    class SliderApi extends BladeApi {
        constructor(controller) {
            super(controller);
            this.emitter_ = new Emitter();
            this.controller_.valueController.value.emitter.on('change', (ev) => {
                this.emitter_.emit('change', {
                    event: new TpChangeEvent(this, ev.rawValue),
                });
            });
        }
        get label() {
            return this.controller_.props.get('label');
        }
        set label(label) {
            this.controller_.props.set('label', label);
        }
        get maxValue() {
            return this.controller_.valueController.sliderController.props.get('maxValue');
        }
        set maxValue(maxValue) {
            this.controller_.valueController.sliderController.props.set('maxValue', maxValue);
        }
        get minValue() {
            return this.controller_.valueController.sliderController.props.get('minValue');
        }
        set minValue(minValue) {
            this.controller_.valueController.sliderController.props.set('minValue', minValue);
        }
        get value() {
            return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
            this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
    }

    class TextApi extends BladeApi {
        constructor(controller) {
            super(controller);
            this.emitter_ = new Emitter();
            this.controller_.valueController.value.emitter.on('change', (ev) => {
                this.emitter_.emit('change', {
                    event: new TpChangeEvent(this, ev.rawValue),
                });
            });
        }
        get label() {
            return this.controller_.props.get('label');
        }
        set label(label) {
            this.controller_.props.set('label', label);
        }
        get formatter() {
            return this.controller_.valueController.props.get('formatter');
        }
        set formatter(formatter) {
            this.controller_.valueController.props.set('formatter', formatter);
        }
        get value() {
            return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
            this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
    }

    const ListBladePlugin = (function () {
        return {
            id: 'list',
            type: 'blade',
            accept(params) {
                const p = ParamsParsers;
                const result = parseParams(params, {
                    options: p.required.custom(parseListOptions),
                    value: p.required.raw,
                    view: p.required.constant('list'),
                    label: p.optional.string,
                });
                return result ? { params: result } : null;
            },
            controller(args) {
                const lc = new ListConstraint(normalizeListOptions(args.params.options));
                const value = createValue(args.params.value, {
                    constraint: lc,
                });
                const ic = new ListController(args.document, {
                    props: new ValueMap({
                        options: lc.values.value('options'),
                    }),
                    value: value,
                    viewProps: args.viewProps,
                });
                return new LabeledValueController(args.document, {
                    blade: args.blade,
                    props: ValueMap.fromObject({
                        label: args.params.label,
                    }),
                    valueController: ic,
                });
            },
            api(args) {
                if (!(args.controller instanceof LabeledValueController)) {
                    return null;
                }
                if (!(args.controller.valueController instanceof ListController)) {
                    return null;
                }
                return new ListApi(args.controller);
            },
        };
    })();

    /**
     * @hidden
     */
    function exportPresetJson(targets) {
        return targets.reduce((result, target) => {
            return Object.assign(result, {
                [target.presetKey]: target.read(),
            });
        }, {});
    }
    /**
     * @hidden
     */
    function importPresetJson(bindings, preset) {
        bindings.forEach((binding) => {
            const value = preset[binding.target.presetKey];
            if (value !== undefined) {
                binding.writer(binding.target, binding.reader(value));
            }
        });
    }

    class RootApi extends FolderApi {
        /**
         * @hidden
         */
        constructor(controller, pool) {
            super(controller, pool);
        }
        get element() {
            return this.controller_.view.element;
        }
        /**
         * Imports a preset of all inputs.
         * @param preset The preset object to import.
         */
        importPreset(preset) {
            const bindings = this.controller_.rackController.rack
                .find(InputBindingController)
                .map((ibc) => {
                return ibc.binding;
            });
            importPresetJson(bindings, preset);
            this.refresh();
        }
        /**
         * Exports a preset of all inputs.
         * @return An exported preset object.
         */
        exportPreset() {
            const targets = this.controller_.rackController.rack
                .find(InputBindingController)
                .map((ibc) => {
                return ibc.binding.target;
            });
            return exportPresetJson(targets);
        }
        /**
         * Refreshes all bindings of the pane.
         */
        refresh() {
            // Force-read all input bindings
            this.controller_.rackController.rack
                .find(InputBindingController)
                .forEach((ibc) => {
                ibc.binding.read();
            });
            // Force-read all monitor bindings
            this.controller_.rackController.rack
                .find(MonitorBindingController)
                .forEach((mbc) => {
                mbc.binding.read();
            });
        }
    }

    class RootController extends FolderController {
        constructor(doc, config) {
            super(doc, {
                expanded: config.expanded,
                blade: config.blade,
                props: config.props,
                root: true,
                viewProps: config.viewProps,
            });
        }
    }

    const SliderBladePlugin = {
        id: 'slider',
        type: 'blade',
        accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
                max: p.required.number,
                min: p.required.number,
                view: p.required.constant('slider'),
                format: p.optional.function,
                label: p.optional.string,
                value: p.optional.number,
            });
            return result ? { params: result } : null;
        },
        controller(args) {
            var _a, _b;
            const initialValue = (_a = args.params.value) !== null && _a !== void 0 ? _a : 0;
            const drc = new DefiniteRangeConstraint({
                max: args.params.max,
                min: args.params.min,
            });
            const vc = new SliderTextController(args.document, {
                baseStep: 1,
                parser: parseNumber,
                sliderProps: new ValueMap({
                    maxValue: drc.values.value('max'),
                    minValue: drc.values.value('min'),
                }),
                textProps: ValueMap.fromObject({
                    draggingScale: getSuitableDraggingScale(undefined, initialValue),
                    formatter: (_b = args.params.format) !== null && _b !== void 0 ? _b : numberToString,
                }),
                value: createValue(initialValue, {
                    constraint: drc,
                }),
                viewProps: args.viewProps,
            });
            return new LabeledValueController(args.document, {
                blade: args.blade,
                props: ValueMap.fromObject({
                    label: args.params.label,
                }),
                valueController: vc,
            });
        },
        api(args) {
            if (!(args.controller instanceof LabeledValueController)) {
                return null;
            }
            if (!(args.controller.valueController instanceof SliderTextController)) {
                return null;
            }
            return new SliderApi(args.controller);
        },
    };

    const TextBladePlugin = (function () {
        return {
            id: 'text',
            type: 'blade',
            accept(params) {
                const p = ParamsParsers;
                const result = parseParams(params, {
                    parse: p.required.function,
                    value: p.required.raw,
                    view: p.required.constant('text'),
                    format: p.optional.function,
                    label: p.optional.string,
                });
                return result ? { params: result } : null;
            },
            controller(args) {
                var _a;
                const ic = new TextController(args.document, {
                    parser: args.params.parse,
                    props: ValueMap.fromObject({
                        formatter: (_a = args.params.format) !== null && _a !== void 0 ? _a : ((v) => String(v)),
                    }),
                    value: createValue(args.params.value),
                    viewProps: args.viewProps,
                });
                return new LabeledValueController(args.document, {
                    blade: args.blade,
                    props: ValueMap.fromObject({
                        label: args.params.label,
                    }),
                    valueController: ic,
                });
            },
            api(args) {
                if (!(args.controller instanceof LabeledValueController)) {
                    return null;
                }
                if (!(args.controller.valueController instanceof TextController)) {
                    return null;
                }
                return new TextApi(args.controller);
            },
        };
    })();

    function createDefaultWrapperElement(doc) {
        const elem = doc.createElement('div');
        elem.classList.add(ClassName('dfw')());
        if (doc.body) {
            doc.body.appendChild(elem);
        }
        return elem;
    }
    function embedStyle(doc, id, css) {
        if (doc.querySelector(`style[data-tp-style=${id}]`)) {
            return;
        }
        const styleElem = doc.createElement('style');
        styleElem.dataset.tpStyle = id;
        styleElem.textContent = css;
        doc.head.appendChild(styleElem);
    }
    /**
     * The root pane of Tweakpane.
     */
    class Pane extends RootApi {
        constructor(opt_config) {
            var _a, _b;
            const config = opt_config !== null && opt_config !== void 0 ? opt_config : {};
            const doc = (_a = config.document) !== null && _a !== void 0 ? _a : getWindowDocument();
            const pool = createDefaultPluginPool();
            const rootController = new RootController(doc, {
                expanded: config.expanded,
                blade: createBlade(),
                props: ValueMap.fromObject({
                    title: config.title,
                }),
                viewProps: ViewProps.create(),
            });
            super(rootController, pool);
            this.pool_ = pool;
            this.containerElem_ = (_b = config.container) !== null && _b !== void 0 ? _b : createDefaultWrapperElement(doc);
            this.containerElem_.appendChild(this.element);
            this.doc_ = doc;
            this.usesDefaultWrapper_ = !config.container;
            this.setUpDefaultPlugins_();
        }
        get document() {
            if (!this.doc_) {
                throw TpError.alreadyDisposed();
            }
            return this.doc_;
        }
        dispose() {
            const containerElem = this.containerElem_;
            if (!containerElem) {
                throw TpError.alreadyDisposed();
            }
            if (this.usesDefaultWrapper_) {
                const parentElem = containerElem.parentElement;
                if (parentElem) {
                    parentElem.removeChild(containerElem);
                }
            }
            this.containerElem_ = null;
            this.doc_ = null;
            super.dispose();
        }
        registerPlugin(bundle) {
            const plugins = 'plugin' in bundle
                ? [bundle.plugin]
                : 'plugins' in bundle
                    ? bundle.plugins
                    : [];
            plugins.forEach((p) => {
                this.pool_.register(p);
                this.embedPluginStyle_(p);
            });
        }
        embedPluginStyle_(plugin) {
            if (plugin.css) {
                embedStyle(this.document, `plugin-${plugin.id}`, plugin.css);
            }
        }
        setUpDefaultPlugins_() {
            // NOTE: This string literal will be replaced with the default CSS by Rollup at the compilation time
            embedStyle(this.document, 'default', '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}');
            this.pool_.getAll().forEach((plugin) => {
                this.embedPluginStyle_(plugin);
            });
            this.registerPlugin({
                plugins: [
                    SliderBladePlugin,
                    ListBladePlugin,
                    TabBladePlugin,
                    TextBladePlugin,
                ],
            });
        }
    }

    const VERSION = new Semver('3.1.7');

    exports.BladeApi = BladeApi;
    exports.ButtonApi = ButtonApi;
    exports.FolderApi = FolderApi;
    exports.InputBindingApi = InputBindingApi;
    exports.ListApi = ListApi;
    exports.MonitorBindingApi = MonitorBindingApi;
    exports.Pane = Pane;
    exports.SeparatorApi = SeparatorApi;
    exports.SliderApi = SliderApi;
    exports.TabApi = TabApi;
    exports.TabPageApi = TabPageApi;
    exports.TextApi = TextApi;
    exports.TpChangeEvent = TpChangeEvent;
    exports.VERSION = VERSION;

    Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],4:[function(require,module,exports){
// https://d3js.org v7.8.5 Copyright 2010-2023 Mike Bostock
!function (t, n) {
  "object" == typeof exports && "undefined" != typeof module ? n(exports) : "function" == typeof define && define.amd ? define(["exports"], n) : n((t = "undefined" != typeof globalThis ? globalThis : t || self).d3 = t.d3 || {});
}(this, function (t) {
  "use strict";

  function n(t, n) {
    return null == t || null == n ? NaN : t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN;
  }
  function e(t, n) {
    return null == t || null == n ? NaN : n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN;
  }
  function r(t) {
    let r, o, a;
    function u(t, n, e = 0, i = t.length) {
      if (e < i) {
        if (0 !== r(n, n)) return i;
        do {
          const r = e + i >>> 1;
          o(t[r], n) < 0 ? e = r + 1 : i = r;
        } while (e < i);
      }
      return e;
    }
    return 2 !== t.length ? (r = n, o = (e, r) => n(t(e), r), a = (n, e) => t(n) - e) : (r = t === n || t === e ? t : i, o = t, a = t), {
      left: u,
      center: function (t, n, e = 0, r = t.length) {
        const i = u(t, n, e, r - 1);
        return i > e && a(t[i - 1], n) > -a(t[i], n) ? i - 1 : i;
      },
      right: function (t, n, e = 0, i = t.length) {
        if (e < i) {
          if (0 !== r(n, n)) return i;
          do {
            const r = e + i >>> 1;
            o(t[r], n) <= 0 ? e = r + 1 : i = r;
          } while (e < i);
        }
        return e;
      }
    };
  }
  function i() {
    return 0;
  }
  function o(t) {
    return null === t ? NaN : +t;
  }
  const a = r(n),
    u = a.right,
    c = a.left,
    f = r(o).center;
  var s = u;
  const l = d(y),
    h = d(function (t) {
      const n = y(t);
      return (t, e, r, i, o) => {
        n(t, e, (r <<= 2) + 0, (i <<= 2) + 0, o <<= 2), n(t, e, r + 1, i + 1, o), n(t, e, r + 2, i + 2, o), n(t, e, r + 3, i + 3, o);
      };
    });
  function d(t) {
    return function (n, e, r = e) {
      if (!((e = +e) >= 0)) throw new RangeError("invalid rx");
      if (!((r = +r) >= 0)) throw new RangeError("invalid ry");
      let {
        data: i,
        width: o,
        height: a
      } = n;
      if (!((o = Math.floor(o)) >= 0)) throw new RangeError("invalid width");
      if (!((a = Math.floor(void 0 !== a ? a : i.length / o)) >= 0)) throw new RangeError("invalid height");
      if (!o || !a || !e && !r) return n;
      const u = e && t(e),
        c = r && t(r),
        f = i.slice();
      return u && c ? (p(u, f, i, o, a), p(u, i, f, o, a), p(u, f, i, o, a), g(c, i, f, o, a), g(c, f, i, o, a), g(c, i, f, o, a)) : u ? (p(u, i, f, o, a), p(u, f, i, o, a), p(u, i, f, o, a)) : c && (g(c, i, f, o, a), g(c, f, i, o, a), g(c, i, f, o, a)), n;
    };
  }
  function p(t, n, e, r, i) {
    for (let o = 0, a = r * i; o < a;) t(n, e, o, o += r, 1);
  }
  function g(t, n, e, r, i) {
    for (let o = 0, a = r * i; o < r; ++o) t(n, e, o, o + a, r);
  }
  function y(t) {
    const n = Math.floor(t);
    if (n === t) return function (t) {
      const n = 2 * t + 1;
      return (e, r, i, o, a) => {
        if (!((o -= a) >= i)) return;
        let u = t * r[i];
        const c = a * t;
        for (let t = i, n = i + c; t < n; t += a) u += r[Math.min(o, t)];
        for (let t = i, f = o; t <= f; t += a) u += r[Math.min(o, t + c)], e[t] = u / n, u -= r[Math.max(i, t - c)];
      };
    }(t);
    const e = t - n,
      r = 2 * t + 1;
    return (t, i, o, a, u) => {
      if (!((a -= u) >= o)) return;
      let c = n * i[o];
      const f = u * n,
        s = f + u;
      for (let t = o, n = o + f; t < n; t += u) c += i[Math.min(a, t)];
      for (let n = o, l = a; n <= l; n += u) c += i[Math.min(a, n + f)], t[n] = (c + e * (i[Math.max(o, n - s)] + i[Math.min(a, n + s)])) / r, c -= i[Math.max(o, n - f)];
    };
  }
  function v(t, n) {
    let e = 0;
    if (void 0 === n) for (let n of t) null != n && (n = +n) >= n && ++e;else {
      let r = -1;
      for (let i of t) null != (i = n(i, ++r, t)) && (i = +i) >= i && ++e;
    }
    return e;
  }
  function _(t) {
    return 0 | t.length;
  }
  function b(t) {
    return !(t > 0);
  }
  function m(t) {
    return "object" != typeof t || "length" in t ? t : Array.from(t);
  }
  function x(t, n) {
    let e,
      r = 0,
      i = 0,
      o = 0;
    if (void 0 === n) for (let n of t) null != n && (n = +n) >= n && (e = n - i, i += e / ++r, o += e * (n - i));else {
      let a = -1;
      for (let u of t) null != (u = n(u, ++a, t)) && (u = +u) >= u && (e = u - i, i += e / ++r, o += e * (u - i));
    }
    if (r > 1) return o / (r - 1);
  }
  function w(t, n) {
    const e = x(t, n);
    return e ? Math.sqrt(e) : e;
  }
  function M(t, n) {
    let e, r;
    if (void 0 === n) for (const n of t) null != n && (void 0 === e ? n >= n && (e = r = n) : (e > n && (e = n), r < n && (r = n)));else {
      let i = -1;
      for (let o of t) null != (o = n(o, ++i, t)) && (void 0 === e ? o >= o && (e = r = o) : (e > o && (e = o), r < o && (r = o)));
    }
    return [e, r];
  }
  class T {
    constructor() {
      this._partials = new Float64Array(32), this._n = 0;
    }
    add(t) {
      const n = this._partials;
      let e = 0;
      for (let r = 0; r < this._n && r < 32; r++) {
        const i = n[r],
          o = t + i,
          a = Math.abs(t) < Math.abs(i) ? t - (o - i) : i - (o - t);
        a && (n[e++] = a), t = o;
      }
      return n[e] = t, this._n = e + 1, this;
    }
    valueOf() {
      const t = this._partials;
      let n,
        e,
        r,
        i = this._n,
        o = 0;
      if (i > 0) {
        for (o = t[--i]; i > 0 && (n = o, e = t[--i], o = n + e, r = e - (o - n), !r););
        i > 0 && (r < 0 && t[i - 1] < 0 || r > 0 && t[i - 1] > 0) && (e = 2 * r, n = o + e, e == n - o && (o = n));
      }
      return o;
    }
  }
  class InternMap extends Map {
    constructor(t, n = N) {
      if (super(), Object.defineProperties(this, {
        _intern: {
          value: new Map()
        },
        _key: {
          value: n
        }
      }), null != t) for (const [n, e] of t) this.set(n, e);
    }
    get(t) {
      return super.get(A(this, t));
    }
    has(t) {
      return super.has(A(this, t));
    }
    set(t, n) {
      return super.set(S(this, t), n);
    }
    delete(t) {
      return super.delete(E(this, t));
    }
  }
  class InternSet extends Set {
    constructor(t, n = N) {
      if (super(), Object.defineProperties(this, {
        _intern: {
          value: new Map()
        },
        _key: {
          value: n
        }
      }), null != t) for (const n of t) this.add(n);
    }
    has(t) {
      return super.has(A(this, t));
    }
    add(t) {
      return super.add(S(this, t));
    }
    delete(t) {
      return super.delete(E(this, t));
    }
  }
  function A({
    _intern: t,
    _key: n
  }, e) {
    const r = n(e);
    return t.has(r) ? t.get(r) : e;
  }
  function S({
    _intern: t,
    _key: n
  }, e) {
    const r = n(e);
    return t.has(r) ? t.get(r) : (t.set(r, e), e);
  }
  function E({
    _intern: t,
    _key: n
  }, e) {
    const r = n(e);
    return t.has(r) && (e = t.get(r), t.delete(r)), e;
  }
  function N(t) {
    return null !== t && "object" == typeof t ? t.valueOf() : t;
  }
  function k(t) {
    return t;
  }
  function C(t, ...n) {
    return F(t, k, k, n);
  }
  function P(t, ...n) {
    return F(t, Array.from, k, n);
  }
  function z(t, n) {
    for (let e = 1, r = n.length; e < r; ++e) t = t.flatMap(t => t.pop().map(([n, e]) => [...t, n, e]));
    return t;
  }
  function $(t, n, ...e) {
    return F(t, k, n, e);
  }
  function D(t, n, ...e) {
    return F(t, Array.from, n, e);
  }
  function R(t) {
    if (1 !== t.length) throw new Error("duplicate key");
    return t[0];
  }
  function F(t, n, e, r) {
    return function t(i, o) {
      if (o >= r.length) return e(i);
      const a = new InternMap(),
        u = r[o++];
      let c = -1;
      for (const t of i) {
        const n = u(t, ++c, i),
          e = a.get(n);
        e ? e.push(t) : a.set(n, [t]);
      }
      for (const [n, e] of a) a.set(n, t(e, o));
      return n(a);
    }(t, 0);
  }
  function q(t, n) {
    return Array.from(n, n => t[n]);
  }
  function U(t, ...n) {
    if ("function" != typeof t[Symbol.iterator]) throw new TypeError("values is not iterable");
    t = Array.from(t);
    let [e] = n;
    if (e && 2 !== e.length || n.length > 1) {
      const r = Uint32Array.from(t, (t, n) => n);
      return n.length > 1 ? (n = n.map(n => t.map(n)), r.sort((t, e) => {
        for (const r of n) {
          const n = O(r[t], r[e]);
          if (n) return n;
        }
      })) : (e = t.map(e), r.sort((t, n) => O(e[t], e[n]))), q(t, r);
    }
    return t.sort(I(e));
  }
  function I(t = n) {
    if (t === n) return O;
    if ("function" != typeof t) throw new TypeError("compare is not a function");
    return (n, e) => {
      const r = t(n, e);
      return r || 0 === r ? r : (0 === t(e, e)) - (0 === t(n, n));
    };
  }
  function O(t, n) {
    return (null == t || !(t >= t)) - (null == n || !(n >= n)) || (t < n ? -1 : t > n ? 1 : 0);
  }
  var B = Array.prototype.slice;
  function Y(t) {
    return () => t;
  }
  const L = Math.sqrt(50),
    j = Math.sqrt(10),
    H = Math.sqrt(2);
  function X(t, n, e) {
    const r = (n - t) / Math.max(0, e),
      i = Math.floor(Math.log10(r)),
      o = r / Math.pow(10, i),
      a = o >= L ? 10 : o >= j ? 5 : o >= H ? 2 : 1;
    let u, c, f;
    return i < 0 ? (f = Math.pow(10, -i) / a, u = Math.round(t * f), c = Math.round(n * f), u / f < t && ++u, c / f > n && --c, f = -f) : (f = Math.pow(10, i) * a, u = Math.round(t / f), c = Math.round(n / f), u * f < t && ++u, c * f > n && --c), c < u && .5 <= e && e < 2 ? X(t, n, 2 * e) : [u, c, f];
  }
  function G(t, n, e) {
    if (!((e = +e) > 0)) return [];
    if ((t = +t) === (n = +n)) return [t];
    const r = n < t,
      [i, o, a] = r ? X(n, t, e) : X(t, n, e);
    if (!(o >= i)) return [];
    const u = o - i + 1,
      c = new Array(u);
    if (r) {
      if (a < 0) for (let t = 0; t < u; ++t) c[t] = (o - t) / -a;else for (let t = 0; t < u; ++t) c[t] = (o - t) * a;
    } else if (a < 0) for (let t = 0; t < u; ++t) c[t] = (i + t) / -a;else for (let t = 0; t < u; ++t) c[t] = (i + t) * a;
    return c;
  }
  function V(t, n, e) {
    return X(t = +t, n = +n, e = +e)[2];
  }
  function W(t, n, e) {
    e = +e;
    const r = (n = +n) < (t = +t),
      i = r ? V(n, t, e) : V(t, n, e);
    return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);
  }
  function Z(t, n, e) {
    let r;
    for (;;) {
      const i = V(t, n, e);
      if (i === r || 0 === i || !isFinite(i)) return [t, n];
      i > 0 ? (t = Math.floor(t / i) * i, n = Math.ceil(n / i) * i) : i < 0 && (t = Math.ceil(t * i) / i, n = Math.floor(n * i) / i), r = i;
    }
  }
  function K(t) {
    return Math.max(1, Math.ceil(Math.log(v(t)) / Math.LN2) + 1);
  }
  function Q() {
    var t = k,
      n = M,
      e = K;
    function r(r) {
      Array.isArray(r) || (r = Array.from(r));
      var i,
        o,
        a,
        u = r.length,
        c = new Array(u);
      for (i = 0; i < u; ++i) c[i] = t(r[i], i, r);
      var f = n(c),
        l = f[0],
        h = f[1],
        d = e(c, l, h);
      if (!Array.isArray(d)) {
        const t = h,
          e = +d;
        if (n === M && ([l, h] = Z(l, h, e)), (d = G(l, h, e))[0] <= l && (a = V(l, h, e)), d[d.length - 1] >= h) if (t >= h && n === M) {
          const t = V(l, h, e);
          isFinite(t) && (t > 0 ? h = (Math.floor(h / t) + 1) * t : t < 0 && (h = (Math.ceil(h * -t) + 1) / -t));
        } else d.pop();
      }
      for (var p = d.length, g = 0, y = p; d[g] <= l;) ++g;
      for (; d[y - 1] > h;) --y;
      (g || y < p) && (d = d.slice(g, y), p = y - g);
      var v,
        _ = new Array(p + 1);
      for (i = 0; i <= p; ++i) (v = _[i] = []).x0 = i > 0 ? d[i - 1] : l, v.x1 = i < p ? d[i] : h;
      if (isFinite(a)) {
        if (a > 0) for (i = 0; i < u; ++i) null != (o = c[i]) && l <= o && o <= h && _[Math.min(p, Math.floor((o - l) / a))].push(r[i]);else if (a < 0) for (i = 0; i < u; ++i) if (null != (o = c[i]) && l <= o && o <= h) {
          const t = Math.floor((l - o) * a);
          _[Math.min(p, t + (d[t] <= o))].push(r[i]);
        }
      } else for (i = 0; i < u; ++i) null != (o = c[i]) && l <= o && o <= h && _[s(d, o, 0, p)].push(r[i]);
      return _;
    }
    return r.value = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : Y(n), r) : t;
    }, r.domain = function (t) {
      return arguments.length ? (n = "function" == typeof t ? t : Y([t[0], t[1]]), r) : n;
    }, r.thresholds = function (t) {
      return arguments.length ? (e = "function" == typeof t ? t : Y(Array.isArray(t) ? B.call(t) : t), r) : e;
    }, r;
  }
  function J(t, n) {
    let e;
    if (void 0 === n) for (const n of t) null != n && (e < n || void 0 === e && n >= n) && (e = n);else {
      let r = -1;
      for (let i of t) null != (i = n(i, ++r, t)) && (e < i || void 0 === e && i >= i) && (e = i);
    }
    return e;
  }
  function tt(t, n) {
    let e,
      r = -1,
      i = -1;
    if (void 0 === n) for (const n of t) ++i, null != n && (e < n || void 0 === e && n >= n) && (e = n, r = i);else for (let o of t) null != (o = n(o, ++i, t)) && (e < o || void 0 === e && o >= o) && (e = o, r = i);
    return r;
  }
  function nt(t, n) {
    let e;
    if (void 0 === n) for (const n of t) null != n && (e > n || void 0 === e && n >= n) && (e = n);else {
      let r = -1;
      for (let i of t) null != (i = n(i, ++r, t)) && (e > i || void 0 === e && i >= i) && (e = i);
    }
    return e;
  }
  function et(t, n) {
    let e,
      r = -1,
      i = -1;
    if (void 0 === n) for (const n of t) ++i, null != n && (e > n || void 0 === e && n >= n) && (e = n, r = i);else for (let o of t) null != (o = n(o, ++i, t)) && (e > o || void 0 === e && o >= o) && (e = o, r = i);
    return r;
  }
  function rt(t, n, e = 0, r = 1 / 0, i) {
    if (n = Math.floor(n), e = Math.floor(Math.max(0, e)), r = Math.floor(Math.min(t.length - 1, r)), !(e <= n && n <= r)) return t;
    for (i = void 0 === i ? O : I(i); r > e;) {
      if (r - e > 600) {
        const o = r - e + 1,
          a = n - e + 1,
          u = Math.log(o),
          c = .5 * Math.exp(2 * u / 3),
          f = .5 * Math.sqrt(u * c * (o - c) / o) * (a - o / 2 < 0 ? -1 : 1);
        rt(t, n, Math.max(e, Math.floor(n - a * c / o + f)), Math.min(r, Math.floor(n + (o - a) * c / o + f)), i);
      }
      const o = t[n];
      let a = e,
        u = r;
      for (it(t, e, n), i(t[r], o) > 0 && it(t, e, r); a < u;) {
        for (it(t, a, u), ++a, --u; i(t[a], o) < 0;) ++a;
        for (; i(t[u], o) > 0;) --u;
      }
      0 === i(t[e], o) ? it(t, e, u) : (++u, it(t, u, r)), u <= n && (e = u + 1), n <= u && (r = u - 1);
    }
    return t;
  }
  function it(t, n, e) {
    const r = t[n];
    t[n] = t[e], t[e] = r;
  }
  function ot(t, e = n) {
    let r,
      i = !1;
    if (1 === e.length) {
      let o;
      for (const a of t) {
        const t = e(a);
        (i ? n(t, o) > 0 : 0 === n(t, t)) && (r = a, o = t, i = !0);
      }
    } else for (const n of t) (i ? e(n, r) > 0 : 0 === e(n, n)) && (r = n, i = !0);
    return r;
  }
  function at(t, n, e) {
    if (t = Float64Array.from(function* (t, n) {
      if (void 0 === n) for (let n of t) null != n && (n = +n) >= n && (yield n);else {
        let e = -1;
        for (let r of t) null != (r = n(r, ++e, t)) && (r = +r) >= r && (yield r);
      }
    }(t, e)), (r = t.length) && !isNaN(n = +n)) {
      if (n <= 0 || r < 2) return nt(t);
      if (n >= 1) return J(t);
      var r,
        i = (r - 1) * n,
        o = Math.floor(i),
        a = J(rt(t, o).subarray(0, o + 1));
      return a + (nt(t.subarray(o + 1)) - a) * (i - o);
    }
  }
  function ut(t, n, e = o) {
    if ((r = t.length) && !isNaN(n = +n)) {
      if (n <= 0 || r < 2) return +e(t[0], 0, t);
      if (n >= 1) return +e(t[r - 1], r - 1, t);
      var r,
        i = (r - 1) * n,
        a = Math.floor(i),
        u = +e(t[a], a, t);
      return u + (+e(t[a + 1], a + 1, t) - u) * (i - a);
    }
  }
  function ct(t, n, e = o) {
    if (!isNaN(n = +n)) {
      if (r = Float64Array.from(t, (n, r) => o(e(t[r], r, t))), n <= 0) return et(r);
      if (n >= 1) return tt(r);
      var r,
        i = Uint32Array.from(t, (t, n) => n),
        a = r.length - 1,
        u = Math.floor(a * n);
      return rt(i, u, 0, a, (t, n) => O(r[t], r[n])), (u = ot(i.subarray(0, u + 1), t => r[t])) >= 0 ? u : -1;
    }
  }
  function ft(t) {
    return Array.from(function* (t) {
      for (const n of t) yield* n;
    }(t));
  }
  function st(t, n) {
    return [t, n];
  }
  function lt(t, n, e) {
    t = +t, n = +n, e = (i = arguments.length) < 2 ? (n = t, t = 0, 1) : i < 3 ? 1 : +e;
    for (var r = -1, i = 0 | Math.max(0, Math.ceil((n - t) / e)), o = new Array(i); ++r < i;) o[r] = t + r * e;
    return o;
  }
  function ht(t, e = n) {
    if (1 === e.length) return et(t, e);
    let r,
      i = -1,
      o = -1;
    for (const n of t) ++o, (i < 0 ? 0 === e(n, n) : e(n, r) < 0) && (r = n, i = o);
    return i;
  }
  var dt = pt(Math.random);
  function pt(t) {
    return function (n, e = 0, r = n.length) {
      let i = r - (e = +e);
      for (; i;) {
        const r = t() * i-- | 0,
          o = n[i + e];
        n[i + e] = n[r + e], n[r + e] = o;
      }
      return n;
    };
  }
  function gt(t) {
    if (!(i = t.length)) return [];
    for (var n = -1, e = nt(t, yt), r = new Array(e); ++n < e;) for (var i, o = -1, a = r[n] = new Array(i); ++o < i;) a[o] = t[o][n];
    return r;
  }
  function yt(t) {
    return t.length;
  }
  function vt(t) {
    return t instanceof InternSet ? t : new InternSet(t);
  }
  function _t(t, n) {
    const e = t[Symbol.iterator](),
      r = new Set();
    for (const t of n) {
      const n = bt(t);
      if (r.has(n)) continue;
      let i, o;
      for (; ({
        value: i,
        done: o
      } = e.next());) {
        if (o) return !1;
        const t = bt(i);
        if (r.add(t), Object.is(n, t)) break;
      }
    }
    return !0;
  }
  function bt(t) {
    return null !== t && "object" == typeof t ? t.valueOf() : t;
  }
  function mt(t) {
    return t;
  }
  var xt = 1,
    wt = 2,
    Mt = 3,
    Tt = 4,
    At = 1e-6;
  function St(t) {
    return "translate(" + t + ",0)";
  }
  function Et(t) {
    return "translate(0," + t + ")";
  }
  function Nt(t) {
    return n => +t(n);
  }
  function kt(t, n) {
    return n = Math.max(0, t.bandwidth() - 2 * n) / 2, t.round() && (n = Math.round(n)), e => +t(e) + n;
  }
  function Ct() {
    return !this.__axis;
  }
  function Pt(t, n) {
    var e = [],
      r = null,
      i = null,
      o = 6,
      a = 6,
      u = 3,
      c = "undefined" != typeof window && window.devicePixelRatio > 1 ? 0 : .5,
      f = t === xt || t === Tt ? -1 : 1,
      s = t === Tt || t === wt ? "x" : "y",
      l = t === xt || t === Mt ? St : Et;
    function h(h) {
      var d = null == r ? n.ticks ? n.ticks.apply(n, e) : n.domain() : r,
        p = null == i ? n.tickFormat ? n.tickFormat.apply(n, e) : mt : i,
        g = Math.max(o, 0) + u,
        y = n.range(),
        v = +y[0] + c,
        _ = +y[y.length - 1] + c,
        b = (n.bandwidth ? kt : Nt)(n.copy(), c),
        m = h.selection ? h.selection() : h,
        x = m.selectAll(".domain").data([null]),
        w = m.selectAll(".tick").data(d, n).order(),
        M = w.exit(),
        T = w.enter().append("g").attr("class", "tick"),
        A = w.select("line"),
        S = w.select("text");
      x = x.merge(x.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), w = w.merge(T), A = A.merge(T.append("line").attr("stroke", "currentColor").attr(s + "2", f * o)), S = S.merge(T.append("text").attr("fill", "currentColor").attr(s, f * g).attr("dy", t === xt ? "0em" : t === Mt ? "0.71em" : "0.32em")), h !== m && (x = x.transition(h), w = w.transition(h), A = A.transition(h), S = S.transition(h), M = M.transition(h).attr("opacity", At).attr("transform", function (t) {
        return isFinite(t = b(t)) ? l(t + c) : this.getAttribute("transform");
      }), T.attr("opacity", At).attr("transform", function (t) {
        var n = this.parentNode.__axis;
        return l((n && isFinite(n = n(t)) ? n : b(t)) + c);
      })), M.remove(), x.attr("d", t === Tt || t === wt ? a ? "M" + f * a + "," + v + "H" + c + "V" + _ + "H" + f * a : "M" + c + "," + v + "V" + _ : a ? "M" + v + "," + f * a + "V" + c + "H" + _ + "V" + f * a : "M" + v + "," + c + "H" + _), w.attr("opacity", 1).attr("transform", function (t) {
        return l(b(t) + c);
      }), A.attr(s + "2", f * o), S.attr(s, f * g).text(p), m.filter(Ct).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", t === wt ? "start" : t === Tt ? "end" : "middle"), m.each(function () {
        this.__axis = b;
      });
    }
    return h.scale = function (t) {
      return arguments.length ? (n = t, h) : n;
    }, h.ticks = function () {
      return e = Array.from(arguments), h;
    }, h.tickArguments = function (t) {
      return arguments.length ? (e = null == t ? [] : Array.from(t), h) : e.slice();
    }, h.tickValues = function (t) {
      return arguments.length ? (r = null == t ? null : Array.from(t), h) : r && r.slice();
    }, h.tickFormat = function (t) {
      return arguments.length ? (i = t, h) : i;
    }, h.tickSize = function (t) {
      return arguments.length ? (o = a = +t, h) : o;
    }, h.tickSizeInner = function (t) {
      return arguments.length ? (o = +t, h) : o;
    }, h.tickSizeOuter = function (t) {
      return arguments.length ? (a = +t, h) : a;
    }, h.tickPadding = function (t) {
      return arguments.length ? (u = +t, h) : u;
    }, h.offset = function (t) {
      return arguments.length ? (c = +t, h) : c;
    }, h;
  }
  var zt = {
    value: () => {}
  };
  function $t() {
    for (var t, n = 0, e = arguments.length, r = {}; n < e; ++n) {
      if (!(t = arguments[n] + "") || t in r || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
      r[t] = [];
    }
    return new Dt(r);
  }
  function Dt(t) {
    this._ = t;
  }
  function Rt(t, n) {
    for (var e, r = 0, i = t.length; r < i; ++r) if ((e = t[r]).name === n) return e.value;
  }
  function Ft(t, n, e) {
    for (var r = 0, i = t.length; r < i; ++r) if (t[r].name === n) {
      t[r] = zt, t = t.slice(0, r).concat(t.slice(r + 1));
      break;
    }
    return null != e && t.push({
      name: n,
      value: e
    }), t;
  }
  Dt.prototype = $t.prototype = {
    constructor: Dt,
    on: function (t, n) {
      var e,
        r,
        i = this._,
        o = (r = i, (t + "").trim().split(/^|\s+/).map(function (t) {
          var n = "",
            e = t.indexOf(".");
          if (e >= 0 && (n = t.slice(e + 1), t = t.slice(0, e)), t && !r.hasOwnProperty(t)) throw new Error("unknown type: " + t);
          return {
            type: t,
            name: n
          };
        })),
        a = -1,
        u = o.length;
      if (!(arguments.length < 2)) {
        if (null != n && "function" != typeof n) throw new Error("invalid callback: " + n);
        for (; ++a < u;) if (e = (t = o[a]).type) i[e] = Ft(i[e], t.name, n);else if (null == n) for (e in i) i[e] = Ft(i[e], t.name, null);
        return this;
      }
      for (; ++a < u;) if ((e = (t = o[a]).type) && (e = Rt(i[e], t.name))) return e;
    },
    copy: function () {
      var t = {},
        n = this._;
      for (var e in n) t[e] = n[e].slice();
      return new Dt(t);
    },
    call: function (t, n) {
      if ((e = arguments.length - 2) > 0) for (var e, r, i = new Array(e), o = 0; o < e; ++o) i[o] = arguments[o + 2];
      if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      for (o = 0, e = (r = this._[t]).length; o < e; ++o) r[o].value.apply(n, i);
    },
    apply: function (t, n, e) {
      if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      for (var r = this._[t], i = 0, o = r.length; i < o; ++i) r[i].value.apply(n, e);
    }
  };
  var qt = "http://www.w3.org/1999/xhtml",
    Ut = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: qt,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
  function It(t) {
    var n = t += "",
      e = n.indexOf(":");
    return e >= 0 && "xmlns" !== (n = t.slice(0, e)) && (t = t.slice(e + 1)), Ut.hasOwnProperty(n) ? {
      space: Ut[n],
      local: t
    } : t;
  }
  function Ot(t) {
    return function () {
      var n = this.ownerDocument,
        e = this.namespaceURI;
      return e === qt && n.documentElement.namespaceURI === qt ? n.createElement(t) : n.createElementNS(e, t);
    };
  }
  function Bt(t) {
    return function () {
      return this.ownerDocument.createElementNS(t.space, t.local);
    };
  }
  function Yt(t) {
    var n = It(t);
    return (n.local ? Bt : Ot)(n);
  }
  function Lt() {}
  function jt(t) {
    return null == t ? Lt : function () {
      return this.querySelector(t);
    };
  }
  function Ht(t) {
    return null == t ? [] : Array.isArray(t) ? t : Array.from(t);
  }
  function Xt() {
    return [];
  }
  function Gt(t) {
    return null == t ? Xt : function () {
      return this.querySelectorAll(t);
    };
  }
  function Vt(t) {
    return function () {
      return this.matches(t);
    };
  }
  function Wt(t) {
    return function (n) {
      return n.matches(t);
    };
  }
  var Zt = Array.prototype.find;
  function Kt() {
    return this.firstElementChild;
  }
  var Qt = Array.prototype.filter;
  function Jt() {
    return Array.from(this.children);
  }
  function tn(t) {
    return new Array(t.length);
  }
  function nn(t, n) {
    this.ownerDocument = t.ownerDocument, this.namespaceURI = t.namespaceURI, this._next = null, this._parent = t, this.__data__ = n;
  }
  function en(t, n, e, r, i, o) {
    for (var a, u = 0, c = n.length, f = o.length; u < f; ++u) (a = n[u]) ? (a.__data__ = o[u], r[u] = a) : e[u] = new nn(t, o[u]);
    for (; u < c; ++u) (a = n[u]) && (i[u] = a);
  }
  function rn(t, n, e, r, i, o, a) {
    var u,
      c,
      f,
      s = new Map(),
      l = n.length,
      h = o.length,
      d = new Array(l);
    for (u = 0; u < l; ++u) (c = n[u]) && (d[u] = f = a.call(c, c.__data__, u, n) + "", s.has(f) ? i[u] = c : s.set(f, c));
    for (u = 0; u < h; ++u) f = a.call(t, o[u], u, o) + "", (c = s.get(f)) ? (r[u] = c, c.__data__ = o[u], s.delete(f)) : e[u] = new nn(t, o[u]);
    for (u = 0; u < l; ++u) (c = n[u]) && s.get(d[u]) === c && (i[u] = c);
  }
  function on(t) {
    return t.__data__;
  }
  function an(t) {
    return "object" == typeof t && "length" in t ? t : Array.from(t);
  }
  function un(t, n) {
    return t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN;
  }
  function cn(t) {
    return function () {
      this.removeAttribute(t);
    };
  }
  function fn(t) {
    return function () {
      this.removeAttributeNS(t.space, t.local);
    };
  }
  function sn(t, n) {
    return function () {
      this.setAttribute(t, n);
    };
  }
  function ln(t, n) {
    return function () {
      this.setAttributeNS(t.space, t.local, n);
    };
  }
  function hn(t, n) {
    return function () {
      var e = n.apply(this, arguments);
      null == e ? this.removeAttribute(t) : this.setAttribute(t, e);
    };
  }
  function dn(t, n) {
    return function () {
      var e = n.apply(this, arguments);
      null == e ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, e);
    };
  }
  function pn(t) {
    return t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView;
  }
  function gn(t) {
    return function () {
      this.style.removeProperty(t);
    };
  }
  function yn(t, n, e) {
    return function () {
      this.style.setProperty(t, n, e);
    };
  }
  function vn(t, n, e) {
    return function () {
      var r = n.apply(this, arguments);
      null == r ? this.style.removeProperty(t) : this.style.setProperty(t, r, e);
    };
  }
  function _n(t, n) {
    return t.style.getPropertyValue(n) || pn(t).getComputedStyle(t, null).getPropertyValue(n);
  }
  function bn(t) {
    return function () {
      delete this[t];
    };
  }
  function mn(t, n) {
    return function () {
      this[t] = n;
    };
  }
  function xn(t, n) {
    return function () {
      var e = n.apply(this, arguments);
      null == e ? delete this[t] : this[t] = e;
    };
  }
  function wn(t) {
    return t.trim().split(/^|\s+/);
  }
  function Mn(t) {
    return t.classList || new Tn(t);
  }
  function Tn(t) {
    this._node = t, this._names = wn(t.getAttribute("class") || "");
  }
  function An(t, n) {
    for (var e = Mn(t), r = -1, i = n.length; ++r < i;) e.add(n[r]);
  }
  function Sn(t, n) {
    for (var e = Mn(t), r = -1, i = n.length; ++r < i;) e.remove(n[r]);
  }
  function En(t) {
    return function () {
      An(this, t);
    };
  }
  function Nn(t) {
    return function () {
      Sn(this, t);
    };
  }
  function kn(t, n) {
    return function () {
      (n.apply(this, arguments) ? An : Sn)(this, t);
    };
  }
  function Cn() {
    this.textContent = "";
  }
  function Pn(t) {
    return function () {
      this.textContent = t;
    };
  }
  function zn(t) {
    return function () {
      var n = t.apply(this, arguments);
      this.textContent = null == n ? "" : n;
    };
  }
  function $n() {
    this.innerHTML = "";
  }
  function Dn(t) {
    return function () {
      this.innerHTML = t;
    };
  }
  function Rn(t) {
    return function () {
      var n = t.apply(this, arguments);
      this.innerHTML = null == n ? "" : n;
    };
  }
  function Fn() {
    this.nextSibling && this.parentNode.appendChild(this);
  }
  function qn() {
    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function Un() {
    return null;
  }
  function In() {
    var t = this.parentNode;
    t && t.removeChild(this);
  }
  function On() {
    var t = this.cloneNode(!1),
      n = this.parentNode;
    return n ? n.insertBefore(t, this.nextSibling) : t;
  }
  function Bn() {
    var t = this.cloneNode(!0),
      n = this.parentNode;
    return n ? n.insertBefore(t, this.nextSibling) : t;
  }
  function Yn(t) {
    return function () {
      var n = this.__on;
      if (n) {
        for (var e, r = 0, i = -1, o = n.length; r < o; ++r) e = n[r], t.type && e.type !== t.type || e.name !== t.name ? n[++i] = e : this.removeEventListener(e.type, e.listener, e.options);
        ++i ? n.length = i : delete this.__on;
      }
    };
  }
  function Ln(t, n, e) {
    return function () {
      var r,
        i = this.__on,
        o = function (t) {
          return function (n) {
            t.call(this, n, this.__data__);
          };
        }(n);
      if (i) for (var a = 0, u = i.length; a < u; ++a) if ((r = i[a]).type === t.type && r.name === t.name) return this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = o, r.options = e), void (r.value = n);
      this.addEventListener(t.type, o, e), r = {
        type: t.type,
        name: t.name,
        value: n,
        listener: o,
        options: e
      }, i ? i.push(r) : this.__on = [r];
    };
  }
  function jn(t, n, e) {
    var r = pn(t),
      i = r.CustomEvent;
    "function" == typeof i ? i = new i(n, e) : (i = r.document.createEvent("Event"), e ? (i.initEvent(n, e.bubbles, e.cancelable), i.detail = e.detail) : i.initEvent(n, !1, !1)), t.dispatchEvent(i);
  }
  function Hn(t, n) {
    return function () {
      return jn(this, t, n);
    };
  }
  function Xn(t, n) {
    return function () {
      return jn(this, t, n.apply(this, arguments));
    };
  }
  nn.prototype = {
    constructor: nn,
    appendChild: function (t) {
      return this._parent.insertBefore(t, this._next);
    },
    insertBefore: function (t, n) {
      return this._parent.insertBefore(t, n);
    },
    querySelector: function (t) {
      return this._parent.querySelector(t);
    },
    querySelectorAll: function (t) {
      return this._parent.querySelectorAll(t);
    }
  }, Tn.prototype = {
    add: function (t) {
      this._names.indexOf(t) < 0 && (this._names.push(t), this._node.setAttribute("class", this._names.join(" ")));
    },
    remove: function (t) {
      var n = this._names.indexOf(t);
      n >= 0 && (this._names.splice(n, 1), this._node.setAttribute("class", this._names.join(" ")));
    },
    contains: function (t) {
      return this._names.indexOf(t) >= 0;
    }
  };
  var Gn = [null];
  function Vn(t, n) {
    this._groups = t, this._parents = n;
  }
  function Wn() {
    return new Vn([[document.documentElement]], Gn);
  }
  function Zn(t) {
    return "string" == typeof t ? new Vn([[document.querySelector(t)]], [document.documentElement]) : new Vn([[t]], Gn);
  }
  Vn.prototype = Wn.prototype = {
    constructor: Vn,
    select: function (t) {
      "function" != typeof t && (t = jt(t));
      for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i) for (var o, a, u = n[i], c = u.length, f = r[i] = new Array(c), s = 0; s < c; ++s) (o = u[s]) && (a = t.call(o, o.__data__, s, u)) && ("__data__" in o && (a.__data__ = o.__data__), f[s] = a);
      return new Vn(r, this._parents);
    },
    selectAll: function (t) {
      t = "function" == typeof t ? function (t) {
        return function () {
          return Ht(t.apply(this, arguments));
        };
      }(t) : Gt(t);
      for (var n = this._groups, e = n.length, r = [], i = [], o = 0; o < e; ++o) for (var a, u = n[o], c = u.length, f = 0; f < c; ++f) (a = u[f]) && (r.push(t.call(a, a.__data__, f, u)), i.push(a));
      return new Vn(r, i);
    },
    selectChild: function (t) {
      return this.select(null == t ? Kt : function (t) {
        return function () {
          return Zt.call(this.children, t);
        };
      }("function" == typeof t ? t : Wt(t)));
    },
    selectChildren: function (t) {
      return this.selectAll(null == t ? Jt : function (t) {
        return function () {
          return Qt.call(this.children, t);
        };
      }("function" == typeof t ? t : Wt(t)));
    },
    filter: function (t) {
      "function" != typeof t && (t = Vt(t));
      for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i) for (var o, a = n[i], u = a.length, c = r[i] = [], f = 0; f < u; ++f) (o = a[f]) && t.call(o, o.__data__, f, a) && c.push(o);
      return new Vn(r, this._parents);
    },
    data: function (t, n) {
      if (!arguments.length) return Array.from(this, on);
      var e = n ? rn : en,
        r = this._parents,
        i = this._groups;
      "function" != typeof t && (t = function (t) {
        return function () {
          return t;
        };
      }(t));
      for (var o = i.length, a = new Array(o), u = new Array(o), c = new Array(o), f = 0; f < o; ++f) {
        var s = r[f],
          l = i[f],
          h = l.length,
          d = an(t.call(s, s && s.__data__, f, r)),
          p = d.length,
          g = u[f] = new Array(p),
          y = a[f] = new Array(p);
        e(s, l, g, y, c[f] = new Array(h), d, n);
        for (var v, _, b = 0, m = 0; b < p; ++b) if (v = g[b]) {
          for (b >= m && (m = b + 1); !(_ = y[m]) && ++m < p;);
          v._next = _ || null;
        }
      }
      return (a = new Vn(a, r))._enter = u, a._exit = c, a;
    },
    enter: function () {
      return new Vn(this._enter || this._groups.map(tn), this._parents);
    },
    exit: function () {
      return new Vn(this._exit || this._groups.map(tn), this._parents);
    },
    join: function (t, n, e) {
      var r = this.enter(),
        i = this,
        o = this.exit();
      return "function" == typeof t ? (r = t(r)) && (r = r.selection()) : r = r.append(t + ""), null != n && (i = n(i)) && (i = i.selection()), null == e ? o.remove() : e(o), r && i ? r.merge(i).order() : i;
    },
    merge: function (t) {
      for (var n = t.selection ? t.selection() : t, e = this._groups, r = n._groups, i = e.length, o = r.length, a = Math.min(i, o), u = new Array(i), c = 0; c < a; ++c) for (var f, s = e[c], l = r[c], h = s.length, d = u[c] = new Array(h), p = 0; p < h; ++p) (f = s[p] || l[p]) && (d[p] = f);
      for (; c < i; ++c) u[c] = e[c];
      return new Vn(u, this._parents);
    },
    selection: function () {
      return this;
    },
    order: function () {
      for (var t = this._groups, n = -1, e = t.length; ++n < e;) for (var r, i = t[n], o = i.length - 1, a = i[o]; --o >= 0;) (r = i[o]) && (a && 4 ^ r.compareDocumentPosition(a) && a.parentNode.insertBefore(r, a), a = r);
      return this;
    },
    sort: function (t) {
      function n(n, e) {
        return n && e ? t(n.__data__, e.__data__) : !n - !e;
      }
      t || (t = un);
      for (var e = this._groups, r = e.length, i = new Array(r), o = 0; o < r; ++o) {
        for (var a, u = e[o], c = u.length, f = i[o] = new Array(c), s = 0; s < c; ++s) (a = u[s]) && (f[s] = a);
        f.sort(n);
      }
      return new Vn(i, this._parents).order();
    },
    call: function () {
      var t = arguments[0];
      return arguments[0] = this, t.apply(null, arguments), this;
    },
    nodes: function () {
      return Array.from(this);
    },
    node: function () {
      for (var t = this._groups, n = 0, e = t.length; n < e; ++n) for (var r = t[n], i = 0, o = r.length; i < o; ++i) {
        var a = r[i];
        if (a) return a;
      }
      return null;
    },
    size: function () {
      let t = 0;
      for (const n of this) ++t;
      return t;
    },
    empty: function () {
      return !this.node();
    },
    each: function (t) {
      for (var n = this._groups, e = 0, r = n.length; e < r; ++e) for (var i, o = n[e], a = 0, u = o.length; a < u; ++a) (i = o[a]) && t.call(i, i.__data__, a, o);
      return this;
    },
    attr: function (t, n) {
      var e = It(t);
      if (arguments.length < 2) {
        var r = this.node();
        return e.local ? r.getAttributeNS(e.space, e.local) : r.getAttribute(e);
      }
      return this.each((null == n ? e.local ? fn : cn : "function" == typeof n ? e.local ? dn : hn : e.local ? ln : sn)(e, n));
    },
    style: function (t, n, e) {
      return arguments.length > 1 ? this.each((null == n ? gn : "function" == typeof n ? vn : yn)(t, n, null == e ? "" : e)) : _n(this.node(), t);
    },
    property: function (t, n) {
      return arguments.length > 1 ? this.each((null == n ? bn : "function" == typeof n ? xn : mn)(t, n)) : this.node()[t];
    },
    classed: function (t, n) {
      var e = wn(t + "");
      if (arguments.length < 2) {
        for (var r = Mn(this.node()), i = -1, o = e.length; ++i < o;) if (!r.contains(e[i])) return !1;
        return !0;
      }
      return this.each(("function" == typeof n ? kn : n ? En : Nn)(e, n));
    },
    text: function (t) {
      return arguments.length ? this.each(null == t ? Cn : ("function" == typeof t ? zn : Pn)(t)) : this.node().textContent;
    },
    html: function (t) {
      return arguments.length ? this.each(null == t ? $n : ("function" == typeof t ? Rn : Dn)(t)) : this.node().innerHTML;
    },
    raise: function () {
      return this.each(Fn);
    },
    lower: function () {
      return this.each(qn);
    },
    append: function (t) {
      var n = "function" == typeof t ? t : Yt(t);
      return this.select(function () {
        return this.appendChild(n.apply(this, arguments));
      });
    },
    insert: function (t, n) {
      var e = "function" == typeof t ? t : Yt(t),
        r = null == n ? Un : "function" == typeof n ? n : jt(n);
      return this.select(function () {
        return this.insertBefore(e.apply(this, arguments), r.apply(this, arguments) || null);
      });
    },
    remove: function () {
      return this.each(In);
    },
    clone: function (t) {
      return this.select(t ? Bn : On);
    },
    datum: function (t) {
      return arguments.length ? this.property("__data__", t) : this.node().__data__;
    },
    on: function (t, n, e) {
      var r,
        i,
        o = function (t) {
          return t.trim().split(/^|\s+/).map(function (t) {
            var n = "",
              e = t.indexOf(".");
            return e >= 0 && (n = t.slice(e + 1), t = t.slice(0, e)), {
              type: t,
              name: n
            };
          });
        }(t + ""),
        a = o.length;
      if (!(arguments.length < 2)) {
        for (u = n ? Ln : Yn, r = 0; r < a; ++r) this.each(u(o[r], n, e));
        return this;
      }
      var u = this.node().__on;
      if (u) for (var c, f = 0, s = u.length; f < s; ++f) for (r = 0, c = u[f]; r < a; ++r) if ((i = o[r]).type === c.type && i.name === c.name) return c.value;
    },
    dispatch: function (t, n) {
      return this.each(("function" == typeof n ? Xn : Hn)(t, n));
    },
    [Symbol.iterator]: function* () {
      for (var t = this._groups, n = 0, e = t.length; n < e; ++n) for (var r, i = t[n], o = 0, a = i.length; o < a; ++o) (r = i[o]) && (yield r);
    }
  };
  var Kn = 0;
  function Qn() {
    return new Jn();
  }
  function Jn() {
    this._ = "@" + (++Kn).toString(36);
  }
  function te(t) {
    let n;
    for (; n = t.sourceEvent;) t = n;
    return t;
  }
  function ne(t, n) {
    if (t = te(t), void 0 === n && (n = t.currentTarget), n) {
      var e = n.ownerSVGElement || n;
      if (e.createSVGPoint) {
        var r = e.createSVGPoint();
        return r.x = t.clientX, r.y = t.clientY, [(r = r.matrixTransform(n.getScreenCTM().inverse())).x, r.y];
      }
      if (n.getBoundingClientRect) {
        var i = n.getBoundingClientRect();
        return [t.clientX - i.left - n.clientLeft, t.clientY - i.top - n.clientTop];
      }
    }
    return [t.pageX, t.pageY];
  }
  Jn.prototype = Qn.prototype = {
    constructor: Jn,
    get: function (t) {
      for (var n = this._; !(n in t);) if (!(t = t.parentNode)) return;
      return t[n];
    },
    set: function (t, n) {
      return t[this._] = n;
    },
    remove: function (t) {
      return this._ in t && delete t[this._];
    },
    toString: function () {
      return this._;
    }
  };
  const ee = {
      passive: !1
    },
    re = {
      capture: !0,
      passive: !1
    };
  function ie(t) {
    t.stopImmediatePropagation();
  }
  function oe(t) {
    t.preventDefault(), t.stopImmediatePropagation();
  }
  function ae(t) {
    var n = t.document.documentElement,
      e = Zn(t).on("dragstart.drag", oe, re);
    "onselectstart" in n ? e.on("selectstart.drag", oe, re) : (n.__noselect = n.style.MozUserSelect, n.style.MozUserSelect = "none");
  }
  function ue(t, n) {
    var e = t.document.documentElement,
      r = Zn(t).on("dragstart.drag", null);
    n && (r.on("click.drag", oe, re), setTimeout(function () {
      r.on("click.drag", null);
    }, 0)), "onselectstart" in e ? r.on("selectstart.drag", null) : (e.style.MozUserSelect = e.__noselect, delete e.__noselect);
  }
  var ce = t => () => t;
  function fe(t, {
    sourceEvent: n,
    subject: e,
    target: r,
    identifier: i,
    active: o,
    x: a,
    y: u,
    dx: c,
    dy: f,
    dispatch: s
  }) {
    Object.defineProperties(this, {
      type: {
        value: t,
        enumerable: !0,
        configurable: !0
      },
      sourceEvent: {
        value: n,
        enumerable: !0,
        configurable: !0
      },
      subject: {
        value: e,
        enumerable: !0,
        configurable: !0
      },
      target: {
        value: r,
        enumerable: !0,
        configurable: !0
      },
      identifier: {
        value: i,
        enumerable: !0,
        configurable: !0
      },
      active: {
        value: o,
        enumerable: !0,
        configurable: !0
      },
      x: {
        value: a,
        enumerable: !0,
        configurable: !0
      },
      y: {
        value: u,
        enumerable: !0,
        configurable: !0
      },
      dx: {
        value: c,
        enumerable: !0,
        configurable: !0
      },
      dy: {
        value: f,
        enumerable: !0,
        configurable: !0
      },
      _: {
        value: s
      }
    });
  }
  function se(t) {
    return !t.ctrlKey && !t.button;
  }
  function le() {
    return this.parentNode;
  }
  function he(t, n) {
    return null == n ? {
      x: t.x,
      y: t.y
    } : n;
  }
  function de() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function pe(t, n, e) {
    t.prototype = n.prototype = e, e.constructor = t;
  }
  function ge(t, n) {
    var e = Object.create(t.prototype);
    for (var r in n) e[r] = n[r];
    return e;
  }
  function ye() {}
  fe.prototype.on = function () {
    var t = this._.on.apply(this._, arguments);
    return t === this._ ? this : t;
  };
  var ve = .7,
    _e = 1 / ve,
    be = "\\s*([+-]?\\d+)\\s*",
    me = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    xe = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    we = /^#([0-9a-f]{3,8})$/,
    Me = new RegExp(`^rgb\\(${be},${be},${be}\\)$`),
    Te = new RegExp(`^rgb\\(${xe},${xe},${xe}\\)$`),
    Ae = new RegExp(`^rgba\\(${be},${be},${be},${me}\\)$`),
    Se = new RegExp(`^rgba\\(${xe},${xe},${xe},${me}\\)$`),
    Ee = new RegExp(`^hsl\\(${me},${xe},${xe}\\)$`),
    Ne = new RegExp(`^hsla\\(${me},${xe},${xe},${me}\\)$`),
    ke = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
  function Ce() {
    return this.rgb().formatHex();
  }
  function Pe() {
    return this.rgb().formatRgb();
  }
  function ze(t) {
    var n, e;
    return t = (t + "").trim().toLowerCase(), (n = we.exec(t)) ? (e = n[1].length, n = parseInt(n[1], 16), 6 === e ? $e(n) : 3 === e ? new qe(n >> 8 & 15 | n >> 4 & 240, n >> 4 & 15 | 240 & n, (15 & n) << 4 | 15 & n, 1) : 8 === e ? De(n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, (255 & n) / 255) : 4 === e ? De(n >> 12 & 15 | n >> 8 & 240, n >> 8 & 15 | n >> 4 & 240, n >> 4 & 15 | 240 & n, ((15 & n) << 4 | 15 & n) / 255) : null) : (n = Me.exec(t)) ? new qe(n[1], n[2], n[3], 1) : (n = Te.exec(t)) ? new qe(255 * n[1] / 100, 255 * n[2] / 100, 255 * n[3] / 100, 1) : (n = Ae.exec(t)) ? De(n[1], n[2], n[3], n[4]) : (n = Se.exec(t)) ? De(255 * n[1] / 100, 255 * n[2] / 100, 255 * n[3] / 100, n[4]) : (n = Ee.exec(t)) ? Le(n[1], n[2] / 100, n[3] / 100, 1) : (n = Ne.exec(t)) ? Le(n[1], n[2] / 100, n[3] / 100, n[4]) : ke.hasOwnProperty(t) ? $e(ke[t]) : "transparent" === t ? new qe(NaN, NaN, NaN, 0) : null;
  }
  function $e(t) {
    return new qe(t >> 16 & 255, t >> 8 & 255, 255 & t, 1);
  }
  function De(t, n, e, r) {
    return r <= 0 && (t = n = e = NaN), new qe(t, n, e, r);
  }
  function Re(t) {
    return t instanceof ye || (t = ze(t)), t ? new qe((t = t.rgb()).r, t.g, t.b, t.opacity) : new qe();
  }
  function Fe(t, n, e, r) {
    return 1 === arguments.length ? Re(t) : new qe(t, n, e, null == r ? 1 : r);
  }
  function qe(t, n, e, r) {
    this.r = +t, this.g = +n, this.b = +e, this.opacity = +r;
  }
  function Ue() {
    return `#${Ye(this.r)}${Ye(this.g)}${Ye(this.b)}`;
  }
  function Ie() {
    const t = Oe(this.opacity);
    return `${1 === t ? "rgb(" : "rgba("}${Be(this.r)}, ${Be(this.g)}, ${Be(this.b)}${1 === t ? ")" : `, ${t})`}`;
  }
  function Oe(t) {
    return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
  }
  function Be(t) {
    return Math.max(0, Math.min(255, Math.round(t) || 0));
  }
  function Ye(t) {
    return ((t = Be(t)) < 16 ? "0" : "") + t.toString(16);
  }
  function Le(t, n, e, r) {
    return r <= 0 ? t = n = e = NaN : e <= 0 || e >= 1 ? t = n = NaN : n <= 0 && (t = NaN), new Xe(t, n, e, r);
  }
  function je(t) {
    if (t instanceof Xe) return new Xe(t.h, t.s, t.l, t.opacity);
    if (t instanceof ye || (t = ze(t)), !t) return new Xe();
    if (t instanceof Xe) return t;
    var n = (t = t.rgb()).r / 255,
      e = t.g / 255,
      r = t.b / 255,
      i = Math.min(n, e, r),
      o = Math.max(n, e, r),
      a = NaN,
      u = o - i,
      c = (o + i) / 2;
    return u ? (a = n === o ? (e - r) / u + 6 * (e < r) : e === o ? (r - n) / u + 2 : (n - e) / u + 4, u /= c < .5 ? o + i : 2 - o - i, a *= 60) : u = c > 0 && c < 1 ? 0 : a, new Xe(a, u, c, t.opacity);
  }
  function He(t, n, e, r) {
    return 1 === arguments.length ? je(t) : new Xe(t, n, e, null == r ? 1 : r);
  }
  function Xe(t, n, e, r) {
    this.h = +t, this.s = +n, this.l = +e, this.opacity = +r;
  }
  function Ge(t) {
    return (t = (t || 0) % 360) < 0 ? t + 360 : t;
  }
  function Ve(t) {
    return Math.max(0, Math.min(1, t || 0));
  }
  function We(t, n, e) {
    return 255 * (t < 60 ? n + (e - n) * t / 60 : t < 180 ? e : t < 240 ? n + (e - n) * (240 - t) / 60 : n);
  }
  pe(ye, ze, {
    copy(t) {
      return Object.assign(new this.constructor(), this, t);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: Ce,
    formatHex: Ce,
    formatHex8: function () {
      return this.rgb().formatHex8();
    },
    formatHsl: function () {
      return je(this).formatHsl();
    },
    formatRgb: Pe,
    toString: Pe
  }), pe(qe, Fe, ge(ye, {
    brighter(t) {
      return t = null == t ? _e : Math.pow(_e, t), new qe(this.r * t, this.g * t, this.b * t, this.opacity);
    },
    darker(t) {
      return t = null == t ? ve : Math.pow(ve, t), new qe(this.r * t, this.g * t, this.b * t, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new qe(Be(this.r), Be(this.g), Be(this.b), Oe(this.opacity));
    },
    displayable() {
      return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: Ue,
    formatHex: Ue,
    formatHex8: function () {
      return `#${Ye(this.r)}${Ye(this.g)}${Ye(this.b)}${Ye(255 * (isNaN(this.opacity) ? 1 : this.opacity))}`;
    },
    formatRgb: Ie,
    toString: Ie
  })), pe(Xe, He, ge(ye, {
    brighter(t) {
      return t = null == t ? _e : Math.pow(_e, t), new Xe(this.h, this.s, this.l * t, this.opacity);
    },
    darker(t) {
      return t = null == t ? ve : Math.pow(ve, t), new Xe(this.h, this.s, this.l * t, this.opacity);
    },
    rgb() {
      var t = this.h % 360 + 360 * (this.h < 0),
        n = isNaN(t) || isNaN(this.s) ? 0 : this.s,
        e = this.l,
        r = e + (e < .5 ? e : 1 - e) * n,
        i = 2 * e - r;
      return new qe(We(t >= 240 ? t - 240 : t + 120, i, r), We(t, i, r), We(t < 120 ? t + 240 : t - 120, i, r), this.opacity);
    },
    clamp() {
      return new Xe(Ge(this.h), Ve(this.s), Ve(this.l), Oe(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl() {
      const t = Oe(this.opacity);
      return `${1 === t ? "hsl(" : "hsla("}${Ge(this.h)}, ${100 * Ve(this.s)}%, ${100 * Ve(this.l)}%${1 === t ? ")" : `, ${t})`}`;
    }
  }));
  const Ze = Math.PI / 180,
    Ke = 180 / Math.PI,
    Qe = .96422,
    Je = 1,
    tr = .82521,
    nr = 4 / 29,
    er = 6 / 29,
    rr = 3 * er * er,
    ir = er * er * er;
  function or(t) {
    if (t instanceof ur) return new ur(t.l, t.a, t.b, t.opacity);
    if (t instanceof pr) return gr(t);
    t instanceof qe || (t = Re(t));
    var n,
      e,
      r = lr(t.r),
      i = lr(t.g),
      o = lr(t.b),
      a = cr((.2225045 * r + .7168786 * i + .0606169 * o) / Je);
    return r === i && i === o ? n = e = a : (n = cr((.4360747 * r + .3850649 * i + .1430804 * o) / Qe), e = cr((.0139322 * r + .0971045 * i + .7141733 * o) / tr)), new ur(116 * a - 16, 500 * (n - a), 200 * (a - e), t.opacity);
  }
  function ar(t, n, e, r) {
    return 1 === arguments.length ? or(t) : new ur(t, n, e, null == r ? 1 : r);
  }
  function ur(t, n, e, r) {
    this.l = +t, this.a = +n, this.b = +e, this.opacity = +r;
  }
  function cr(t) {
    return t > ir ? Math.pow(t, 1 / 3) : t / rr + nr;
  }
  function fr(t) {
    return t > er ? t * t * t : rr * (t - nr);
  }
  function sr(t) {
    return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);
  }
  function lr(t) {
    return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);
  }
  function hr(t) {
    if (t instanceof pr) return new pr(t.h, t.c, t.l, t.opacity);
    if (t instanceof ur || (t = or(t)), 0 === t.a && 0 === t.b) return new pr(NaN, 0 < t.l && t.l < 100 ? 0 : NaN, t.l, t.opacity);
    var n = Math.atan2(t.b, t.a) * Ke;
    return new pr(n < 0 ? n + 360 : n, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity);
  }
  function dr(t, n, e, r) {
    return 1 === arguments.length ? hr(t) : new pr(t, n, e, null == r ? 1 : r);
  }
  function pr(t, n, e, r) {
    this.h = +t, this.c = +n, this.l = +e, this.opacity = +r;
  }
  function gr(t) {
    if (isNaN(t.h)) return new ur(t.l, 0, 0, t.opacity);
    var n = t.h * Ze;
    return new ur(t.l, Math.cos(n) * t.c, Math.sin(n) * t.c, t.opacity);
  }
  pe(ur, ar, ge(ye, {
    brighter(t) {
      return new ur(this.l + 18 * (null == t ? 1 : t), this.a, this.b, this.opacity);
    },
    darker(t) {
      return new ur(this.l - 18 * (null == t ? 1 : t), this.a, this.b, this.opacity);
    },
    rgb() {
      var t = (this.l + 16) / 116,
        n = isNaN(this.a) ? t : t + this.a / 500,
        e = isNaN(this.b) ? t : t - this.b / 200;
      return new qe(sr(3.1338561 * (n = Qe * fr(n)) - 1.6168667 * (t = Je * fr(t)) - .4906146 * (e = tr * fr(e))), sr(-.9787684 * n + 1.9161415 * t + .033454 * e), sr(.0719453 * n - .2289914 * t + 1.4052427 * e), this.opacity);
    }
  })), pe(pr, dr, ge(ye, {
    brighter(t) {
      return new pr(this.h, this.c, this.l + 18 * (null == t ? 1 : t), this.opacity);
    },
    darker(t) {
      return new pr(this.h, this.c, this.l - 18 * (null == t ? 1 : t), this.opacity);
    },
    rgb() {
      return gr(this).rgb();
    }
  }));
  var yr = -.14861,
    vr = 1.78277,
    _r = -.29227,
    br = -.90649,
    mr = 1.97294,
    xr = mr * br,
    wr = mr * vr,
    Mr = vr * _r - br * yr;
  function Tr(t, n, e, r) {
    return 1 === arguments.length ? function (t) {
      if (t instanceof Ar) return new Ar(t.h, t.s, t.l, t.opacity);
      t instanceof qe || (t = Re(t));
      var n = t.r / 255,
        e = t.g / 255,
        r = t.b / 255,
        i = (Mr * r + xr * n - wr * e) / (Mr + xr - wr),
        o = r - i,
        a = (mr * (e - i) - _r * o) / br,
        u = Math.sqrt(a * a + o * o) / (mr * i * (1 - i)),
        c = u ? Math.atan2(a, o) * Ke - 120 : NaN;
      return new Ar(c < 0 ? c + 360 : c, u, i, t.opacity);
    }(t) : new Ar(t, n, e, null == r ? 1 : r);
  }
  function Ar(t, n, e, r) {
    this.h = +t, this.s = +n, this.l = +e, this.opacity = +r;
  }
  function Sr(t, n, e, r, i) {
    var o = t * t,
      a = o * t;
    return ((1 - 3 * t + 3 * o - a) * n + (4 - 6 * o + 3 * a) * e + (1 + 3 * t + 3 * o - 3 * a) * r + a * i) / 6;
  }
  function Er(t) {
    var n = t.length - 1;
    return function (e) {
      var r = e <= 0 ? e = 0 : e >= 1 ? (e = 1, n - 1) : Math.floor(e * n),
        i = t[r],
        o = t[r + 1],
        a = r > 0 ? t[r - 1] : 2 * i - o,
        u = r < n - 1 ? t[r + 2] : 2 * o - i;
      return Sr((e - r / n) * n, a, i, o, u);
    };
  }
  function Nr(t) {
    var n = t.length;
    return function (e) {
      var r = Math.floor(((e %= 1) < 0 ? ++e : e) * n),
        i = t[(r + n - 1) % n],
        o = t[r % n],
        a = t[(r + 1) % n],
        u = t[(r + 2) % n];
      return Sr((e - r / n) * n, i, o, a, u);
    };
  }
  pe(Ar, Tr, ge(ye, {
    brighter(t) {
      return t = null == t ? _e : Math.pow(_e, t), new Ar(this.h, this.s, this.l * t, this.opacity);
    },
    darker(t) {
      return t = null == t ? ve : Math.pow(ve, t), new Ar(this.h, this.s, this.l * t, this.opacity);
    },
    rgb() {
      var t = isNaN(this.h) ? 0 : (this.h + 120) * Ze,
        n = +this.l,
        e = isNaN(this.s) ? 0 : this.s * n * (1 - n),
        r = Math.cos(t),
        i = Math.sin(t);
      return new qe(255 * (n + e * (yr * r + vr * i)), 255 * (n + e * (_r * r + br * i)), 255 * (n + e * (mr * r)), this.opacity);
    }
  }));
  var kr = t => () => t;
  function Cr(t, n) {
    return function (e) {
      return t + e * n;
    };
  }
  function Pr(t, n) {
    var e = n - t;
    return e ? Cr(t, e > 180 || e < -180 ? e - 360 * Math.round(e / 360) : e) : kr(isNaN(t) ? n : t);
  }
  function zr(t) {
    return 1 == (t = +t) ? $r : function (n, e) {
      return e - n ? function (t, n, e) {
        return t = Math.pow(t, e), n = Math.pow(n, e) - t, e = 1 / e, function (r) {
          return Math.pow(t + r * n, e);
        };
      }(n, e, t) : kr(isNaN(n) ? e : n);
    };
  }
  function $r(t, n) {
    var e = n - t;
    return e ? Cr(t, e) : kr(isNaN(t) ? n : t);
  }
  var Dr = function t(n) {
    var e = zr(n);
    function r(t, n) {
      var r = e((t = Fe(t)).r, (n = Fe(n)).r),
        i = e(t.g, n.g),
        o = e(t.b, n.b),
        a = $r(t.opacity, n.opacity);
      return function (n) {
        return t.r = r(n), t.g = i(n), t.b = o(n), t.opacity = a(n), t + "";
      };
    }
    return r.gamma = t, r;
  }(1);
  function Rr(t) {
    return function (n) {
      var e,
        r,
        i = n.length,
        o = new Array(i),
        a = new Array(i),
        u = new Array(i);
      for (e = 0; e < i; ++e) r = Fe(n[e]), o[e] = r.r || 0, a[e] = r.g || 0, u[e] = r.b || 0;
      return o = t(o), a = t(a), u = t(u), r.opacity = 1, function (t) {
        return r.r = o(t), r.g = a(t), r.b = u(t), r + "";
      };
    };
  }
  var Fr = Rr(Er),
    qr = Rr(Nr);
  function Ur(t, n) {
    n || (n = []);
    var e,
      r = t ? Math.min(n.length, t.length) : 0,
      i = n.slice();
    return function (o) {
      for (e = 0; e < r; ++e) i[e] = t[e] * (1 - o) + n[e] * o;
      return i;
    };
  }
  function Ir(t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView);
  }
  function Or(t, n) {
    var e,
      r = n ? n.length : 0,
      i = t ? Math.min(r, t.length) : 0,
      o = new Array(i),
      a = new Array(r);
    for (e = 0; e < i; ++e) o[e] = Gr(t[e], n[e]);
    for (; e < r; ++e) a[e] = n[e];
    return function (t) {
      for (e = 0; e < i; ++e) a[e] = o[e](t);
      return a;
    };
  }
  function Br(t, n) {
    var e = new Date();
    return t = +t, n = +n, function (r) {
      return e.setTime(t * (1 - r) + n * r), e;
    };
  }
  function Yr(t, n) {
    return t = +t, n = +n, function (e) {
      return t * (1 - e) + n * e;
    };
  }
  function Lr(t, n) {
    var e,
      r = {},
      i = {};
    for (e in null !== t && "object" == typeof t || (t = {}), null !== n && "object" == typeof n || (n = {}), n) e in t ? r[e] = Gr(t[e], n[e]) : i[e] = n[e];
    return function (t) {
      for (e in r) i[e] = r[e](t);
      return i;
    };
  }
  var jr = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    Hr = new RegExp(jr.source, "g");
  function Xr(t, n) {
    var e,
      r,
      i,
      o = jr.lastIndex = Hr.lastIndex = 0,
      a = -1,
      u = [],
      c = [];
    for (t += "", n += ""; (e = jr.exec(t)) && (r = Hr.exec(n));) (i = r.index) > o && (i = n.slice(o, i), u[a] ? u[a] += i : u[++a] = i), (e = e[0]) === (r = r[0]) ? u[a] ? u[a] += r : u[++a] = r : (u[++a] = null, c.push({
      i: a,
      x: Yr(e, r)
    })), o = Hr.lastIndex;
    return o < n.length && (i = n.slice(o), u[a] ? u[a] += i : u[++a] = i), u.length < 2 ? c[0] ? function (t) {
      return function (n) {
        return t(n) + "";
      };
    }(c[0].x) : function (t) {
      return function () {
        return t;
      };
    }(n) : (n = c.length, function (t) {
      for (var e, r = 0; r < n; ++r) u[(e = c[r]).i] = e.x(t);
      return u.join("");
    });
  }
  function Gr(t, n) {
    var e,
      r = typeof n;
    return null == n || "boolean" === r ? kr(n) : ("number" === r ? Yr : "string" === r ? (e = ze(n)) ? (n = e, Dr) : Xr : n instanceof ze ? Dr : n instanceof Date ? Br : Ir(n) ? Ur : Array.isArray(n) ? Or : "function" != typeof n.valueOf && "function" != typeof n.toString || isNaN(n) ? Lr : Yr)(t, n);
  }
  function Vr(t, n) {
    return t = +t, n = +n, function (e) {
      return Math.round(t * (1 - e) + n * e);
    };
  }
  var Wr,
    Zr = 180 / Math.PI,
    Kr = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };
  function Qr(t, n, e, r, i, o) {
    var a, u, c;
    return (a = Math.sqrt(t * t + n * n)) && (t /= a, n /= a), (c = t * e + n * r) && (e -= t * c, r -= n * c), (u = Math.sqrt(e * e + r * r)) && (e /= u, r /= u, c /= u), t * r < n * e && (t = -t, n = -n, c = -c, a = -a), {
      translateX: i,
      translateY: o,
      rotate: Math.atan2(n, t) * Zr,
      skewX: Math.atan(c) * Zr,
      scaleX: a,
      scaleY: u
    };
  }
  function Jr(t, n, e, r) {
    function i(t) {
      return t.length ? t.pop() + " " : "";
    }
    return function (o, a) {
      var u = [],
        c = [];
      return o = t(o), a = t(a), function (t, r, i, o, a, u) {
        if (t !== i || r !== o) {
          var c = a.push("translate(", null, n, null, e);
          u.push({
            i: c - 4,
            x: Yr(t, i)
          }, {
            i: c - 2,
            x: Yr(r, o)
          });
        } else (i || o) && a.push("translate(" + i + n + o + e);
      }(o.translateX, o.translateY, a.translateX, a.translateY, u, c), function (t, n, e, o) {
        t !== n ? (t - n > 180 ? n += 360 : n - t > 180 && (t += 360), o.push({
          i: e.push(i(e) + "rotate(", null, r) - 2,
          x: Yr(t, n)
        })) : n && e.push(i(e) + "rotate(" + n + r);
      }(o.rotate, a.rotate, u, c), function (t, n, e, o) {
        t !== n ? o.push({
          i: e.push(i(e) + "skewX(", null, r) - 2,
          x: Yr(t, n)
        }) : n && e.push(i(e) + "skewX(" + n + r);
      }(o.skewX, a.skewX, u, c), function (t, n, e, r, o, a) {
        if (t !== e || n !== r) {
          var u = o.push(i(o) + "scale(", null, ",", null, ")");
          a.push({
            i: u - 4,
            x: Yr(t, e)
          }, {
            i: u - 2,
            x: Yr(n, r)
          });
        } else 1 === e && 1 === r || o.push(i(o) + "scale(" + e + "," + r + ")");
      }(o.scaleX, o.scaleY, a.scaleX, a.scaleY, u, c), o = a = null, function (t) {
        for (var n, e = -1, r = c.length; ++e < r;) u[(n = c[e]).i] = n.x(t);
        return u.join("");
      };
    };
  }
  var ti = Jr(function (t) {
      const n = new ("function" == typeof DOMMatrix ? DOMMatrix : WebKitCSSMatrix)(t + "");
      return n.isIdentity ? Kr : Qr(n.a, n.b, n.c, n.d, n.e, n.f);
    }, "px, ", "px)", "deg)"),
    ni = Jr(function (t) {
      return null == t ? Kr : (Wr || (Wr = document.createElementNS("http://www.w3.org/2000/svg", "g")), Wr.setAttribute("transform", t), (t = Wr.transform.baseVal.consolidate()) ? Qr((t = t.matrix).a, t.b, t.c, t.d, t.e, t.f) : Kr);
    }, ", ", ")", ")");
  function ei(t) {
    return ((t = Math.exp(t)) + 1 / t) / 2;
  }
  var ri = function t(n, e, r) {
    function i(t, i) {
      var o,
        a,
        u = t[0],
        c = t[1],
        f = t[2],
        s = i[0],
        l = i[1],
        h = i[2],
        d = s - u,
        p = l - c,
        g = d * d + p * p;
      if (g < 1e-12) a = Math.log(h / f) / n, o = function (t) {
        return [u + t * d, c + t * p, f * Math.exp(n * t * a)];
      };else {
        var y = Math.sqrt(g),
          v = (h * h - f * f + r * g) / (2 * f * e * y),
          _ = (h * h - f * f - r * g) / (2 * h * e * y),
          b = Math.log(Math.sqrt(v * v + 1) - v),
          m = Math.log(Math.sqrt(_ * _ + 1) - _);
        a = (m - b) / n, o = function (t) {
          var r = t * a,
            i = ei(b),
            o = f / (e * y) * (i * function (t) {
              return ((t = Math.exp(2 * t)) - 1) / (t + 1);
            }(n * r + b) - function (t) {
              return ((t = Math.exp(t)) - 1 / t) / 2;
            }(b));
          return [u + o * d, c + o * p, f * i / ei(n * r + b)];
        };
      }
      return o.duration = 1e3 * a * n / Math.SQRT2, o;
    }
    return i.rho = function (n) {
      var e = Math.max(.001, +n),
        r = e * e;
      return t(e, r, r * r);
    }, i;
  }(Math.SQRT2, 2, 4);
  function ii(t) {
    return function (n, e) {
      var r = t((n = He(n)).h, (e = He(e)).h),
        i = $r(n.s, e.s),
        o = $r(n.l, e.l),
        a = $r(n.opacity, e.opacity);
      return function (t) {
        return n.h = r(t), n.s = i(t), n.l = o(t), n.opacity = a(t), n + "";
      };
    };
  }
  var oi = ii(Pr),
    ai = ii($r);
  function ui(t) {
    return function (n, e) {
      var r = t((n = dr(n)).h, (e = dr(e)).h),
        i = $r(n.c, e.c),
        o = $r(n.l, e.l),
        a = $r(n.opacity, e.opacity);
      return function (t) {
        return n.h = r(t), n.c = i(t), n.l = o(t), n.opacity = a(t), n + "";
      };
    };
  }
  var ci = ui(Pr),
    fi = ui($r);
  function si(t) {
    return function n(e) {
      function r(n, r) {
        var i = t((n = Tr(n)).h, (r = Tr(r)).h),
          o = $r(n.s, r.s),
          a = $r(n.l, r.l),
          u = $r(n.opacity, r.opacity);
        return function (t) {
          return n.h = i(t), n.s = o(t), n.l = a(Math.pow(t, e)), n.opacity = u(t), n + "";
        };
      }
      return e = +e, r.gamma = n, r;
    }(1);
  }
  var li = si(Pr),
    hi = si($r);
  function di(t, n) {
    void 0 === n && (n = t, t = Gr);
    for (var e = 0, r = n.length - 1, i = n[0], o = new Array(r < 0 ? 0 : r); e < r;) o[e] = t(i, i = n[++e]);
    return function (t) {
      var n = Math.max(0, Math.min(r - 1, Math.floor(t *= r)));
      return o[n](t - n);
    };
  }
  var pi,
    gi,
    yi = 0,
    vi = 0,
    _i = 0,
    bi = 1e3,
    mi = 0,
    xi = 0,
    wi = 0,
    Mi = "object" == typeof performance && performance.now ? performance : Date,
    Ti = "object" == typeof window && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (t) {
      setTimeout(t, 17);
    };
  function Ai() {
    return xi || (Ti(Si), xi = Mi.now() + wi);
  }
  function Si() {
    xi = 0;
  }
  function Ei() {
    this._call = this._time = this._next = null;
  }
  function Ni(t, n, e) {
    var r = new Ei();
    return r.restart(t, n, e), r;
  }
  function ki() {
    Ai(), ++yi;
    for (var t, n = pi; n;) (t = xi - n._time) >= 0 && n._call.call(void 0, t), n = n._next;
    --yi;
  }
  function Ci() {
    xi = (mi = Mi.now()) + wi, yi = vi = 0;
    try {
      ki();
    } finally {
      yi = 0, function () {
        var t,
          n,
          e = pi,
          r = 1 / 0;
        for (; e;) e._call ? (r > e._time && (r = e._time), t = e, e = e._next) : (n = e._next, e._next = null, e = t ? t._next = n : pi = n);
        gi = t, zi(r);
      }(), xi = 0;
    }
  }
  function Pi() {
    var t = Mi.now(),
      n = t - mi;
    n > bi && (wi -= n, mi = t);
  }
  function zi(t) {
    yi || (vi && (vi = clearTimeout(vi)), t - xi > 24 ? (t < 1 / 0 && (vi = setTimeout(Ci, t - Mi.now() - wi)), _i && (_i = clearInterval(_i))) : (_i || (mi = Mi.now(), _i = setInterval(Pi, bi)), yi = 1, Ti(Ci)));
  }
  function $i(t, n, e) {
    var r = new Ei();
    return n = null == n ? 0 : +n, r.restart(e => {
      r.stop(), t(e + n);
    }, n, e), r;
  }
  Ei.prototype = Ni.prototype = {
    constructor: Ei,
    restart: function (t, n, e) {
      if ("function" != typeof t) throw new TypeError("callback is not a function");
      e = (null == e ? Ai() : +e) + (null == n ? 0 : +n), this._next || gi === this || (gi ? gi._next = this : pi = this, gi = this), this._call = t, this._time = e, zi();
    },
    stop: function () {
      this._call && (this._call = null, this._time = 1 / 0, zi());
    }
  };
  var Di = $t("start", "end", "cancel", "interrupt"),
    Ri = [],
    Fi = 0,
    qi = 1,
    Ui = 2,
    Ii = 3,
    Oi = 4,
    Bi = 5,
    Yi = 6;
  function Li(t, n, e, r, i, o) {
    var a = t.__transition;
    if (a) {
      if (e in a) return;
    } else t.__transition = {};
    !function (t, n, e) {
      var r,
        i = t.__transition;
      function o(t) {
        e.state = qi, e.timer.restart(a, e.delay, e.time), e.delay <= t && a(t - e.delay);
      }
      function a(o) {
        var f, s, l, h;
        if (e.state !== qi) return c();
        for (f in i) if ((h = i[f]).name === e.name) {
          if (h.state === Ii) return $i(a);
          h.state === Oi ? (h.state = Yi, h.timer.stop(), h.on.call("interrupt", t, t.__data__, h.index, h.group), delete i[f]) : +f < n && (h.state = Yi, h.timer.stop(), h.on.call("cancel", t, t.__data__, h.index, h.group), delete i[f]);
        }
        if ($i(function () {
          e.state === Ii && (e.state = Oi, e.timer.restart(u, e.delay, e.time), u(o));
        }), e.state = Ui, e.on.call("start", t, t.__data__, e.index, e.group), e.state === Ui) {
          for (e.state = Ii, r = new Array(l = e.tween.length), f = 0, s = -1; f < l; ++f) (h = e.tween[f].value.call(t, t.__data__, e.index, e.group)) && (r[++s] = h);
          r.length = s + 1;
        }
      }
      function u(n) {
        for (var i = n < e.duration ? e.ease.call(null, n / e.duration) : (e.timer.restart(c), e.state = Bi, 1), o = -1, a = r.length; ++o < a;) r[o].call(t, i);
        e.state === Bi && (e.on.call("end", t, t.__data__, e.index, e.group), c());
      }
      function c() {
        for (var r in e.state = Yi, e.timer.stop(), delete i[n], i) return;
        delete t.__transition;
      }
      i[n] = e, e.timer = Ni(o, 0, e.time);
    }(t, e, {
      name: n,
      index: r,
      group: i,
      on: Di,
      tween: Ri,
      time: o.time,
      delay: o.delay,
      duration: o.duration,
      ease: o.ease,
      timer: null,
      state: Fi
    });
  }
  function ji(t, n) {
    var e = Xi(t, n);
    if (e.state > Fi) throw new Error("too late; already scheduled");
    return e;
  }
  function Hi(t, n) {
    var e = Xi(t, n);
    if (e.state > Ii) throw new Error("too late; already running");
    return e;
  }
  function Xi(t, n) {
    var e = t.__transition;
    if (!e || !(e = e[n])) throw new Error("transition not found");
    return e;
  }
  function Gi(t, n) {
    var e,
      r,
      i,
      o = t.__transition,
      a = !0;
    if (o) {
      for (i in n = null == n ? null : n + "", o) (e = o[i]).name === n ? (r = e.state > Ui && e.state < Bi, e.state = Yi, e.timer.stop(), e.on.call(r ? "interrupt" : "cancel", t, t.__data__, e.index, e.group), delete o[i]) : a = !1;
      a && delete t.__transition;
    }
  }
  function Vi(t, n) {
    var e, r;
    return function () {
      var i = Hi(this, t),
        o = i.tween;
      if (o !== e) for (var a = 0, u = (r = e = o).length; a < u; ++a) if (r[a].name === n) {
        (r = r.slice()).splice(a, 1);
        break;
      }
      i.tween = r;
    };
  }
  function Wi(t, n, e) {
    var r, i;
    if ("function" != typeof e) throw new Error();
    return function () {
      var o = Hi(this, t),
        a = o.tween;
      if (a !== r) {
        i = (r = a).slice();
        for (var u = {
            name: n,
            value: e
          }, c = 0, f = i.length; c < f; ++c) if (i[c].name === n) {
          i[c] = u;
          break;
        }
        c === f && i.push(u);
      }
      o.tween = i;
    };
  }
  function Zi(t, n, e) {
    var r = t._id;
    return t.each(function () {
      var t = Hi(this, r);
      (t.value || (t.value = {}))[n] = e.apply(this, arguments);
    }), function (t) {
      return Xi(t, r).value[n];
    };
  }
  function Ki(t, n) {
    var e;
    return ("number" == typeof n ? Yr : n instanceof ze ? Dr : (e = ze(n)) ? (n = e, Dr) : Xr)(t, n);
  }
  function Qi(t) {
    return function () {
      this.removeAttribute(t);
    };
  }
  function Ji(t) {
    return function () {
      this.removeAttributeNS(t.space, t.local);
    };
  }
  function to(t, n, e) {
    var r,
      i,
      o = e + "";
    return function () {
      var a = this.getAttribute(t);
      return a === o ? null : a === r ? i : i = n(r = a, e);
    };
  }
  function no(t, n, e) {
    var r,
      i,
      o = e + "";
    return function () {
      var a = this.getAttributeNS(t.space, t.local);
      return a === o ? null : a === r ? i : i = n(r = a, e);
    };
  }
  function eo(t, n, e) {
    var r, i, o;
    return function () {
      var a,
        u,
        c = e(this);
      if (null != c) return (a = this.getAttribute(t)) === (u = c + "") ? null : a === r && u === i ? o : (i = u, o = n(r = a, c));
      this.removeAttribute(t);
    };
  }
  function ro(t, n, e) {
    var r, i, o;
    return function () {
      var a,
        u,
        c = e(this);
      if (null != c) return (a = this.getAttributeNS(t.space, t.local)) === (u = c + "") ? null : a === r && u === i ? o : (i = u, o = n(r = a, c));
      this.removeAttributeNS(t.space, t.local);
    };
  }
  function io(t, n) {
    var e, r;
    function i() {
      var i = n.apply(this, arguments);
      return i !== r && (e = (r = i) && function (t, n) {
        return function (e) {
          this.setAttributeNS(t.space, t.local, n.call(this, e));
        };
      }(t, i)), e;
    }
    return i._value = n, i;
  }
  function oo(t, n) {
    var e, r;
    function i() {
      var i = n.apply(this, arguments);
      return i !== r && (e = (r = i) && function (t, n) {
        return function (e) {
          this.setAttribute(t, n.call(this, e));
        };
      }(t, i)), e;
    }
    return i._value = n, i;
  }
  function ao(t, n) {
    return function () {
      ji(this, t).delay = +n.apply(this, arguments);
    };
  }
  function uo(t, n) {
    return n = +n, function () {
      ji(this, t).delay = n;
    };
  }
  function co(t, n) {
    return function () {
      Hi(this, t).duration = +n.apply(this, arguments);
    };
  }
  function fo(t, n) {
    return n = +n, function () {
      Hi(this, t).duration = n;
    };
  }
  var so = Wn.prototype.constructor;
  function lo(t) {
    return function () {
      this.style.removeProperty(t);
    };
  }
  var ho = 0;
  function po(t, n, e, r) {
    this._groups = t, this._parents = n, this._name = e, this._id = r;
  }
  function go(t) {
    return Wn().transition(t);
  }
  function yo() {
    return ++ho;
  }
  var vo = Wn.prototype;
  po.prototype = go.prototype = {
    constructor: po,
    select: function (t) {
      var n = this._name,
        e = this._id;
      "function" != typeof t && (t = jt(t));
      for (var r = this._groups, i = r.length, o = new Array(i), a = 0; a < i; ++a) for (var u, c, f = r[a], s = f.length, l = o[a] = new Array(s), h = 0; h < s; ++h) (u = f[h]) && (c = t.call(u, u.__data__, h, f)) && ("__data__" in u && (c.__data__ = u.__data__), l[h] = c, Li(l[h], n, e, h, l, Xi(u, e)));
      return new po(o, this._parents, n, e);
    },
    selectAll: function (t) {
      var n = this._name,
        e = this._id;
      "function" != typeof t && (t = Gt(t));
      for (var r = this._groups, i = r.length, o = [], a = [], u = 0; u < i; ++u) for (var c, f = r[u], s = f.length, l = 0; l < s; ++l) if (c = f[l]) {
        for (var h, d = t.call(c, c.__data__, l, f), p = Xi(c, e), g = 0, y = d.length; g < y; ++g) (h = d[g]) && Li(h, n, e, g, d, p);
        o.push(d), a.push(c);
      }
      return new po(o, a, n, e);
    },
    selectChild: vo.selectChild,
    selectChildren: vo.selectChildren,
    filter: function (t) {
      "function" != typeof t && (t = Vt(t));
      for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i) for (var o, a = n[i], u = a.length, c = r[i] = [], f = 0; f < u; ++f) (o = a[f]) && t.call(o, o.__data__, f, a) && c.push(o);
      return new po(r, this._parents, this._name, this._id);
    },
    merge: function (t) {
      if (t._id !== this._id) throw new Error();
      for (var n = this._groups, e = t._groups, r = n.length, i = e.length, o = Math.min(r, i), a = new Array(r), u = 0; u < o; ++u) for (var c, f = n[u], s = e[u], l = f.length, h = a[u] = new Array(l), d = 0; d < l; ++d) (c = f[d] || s[d]) && (h[d] = c);
      for (; u < r; ++u) a[u] = n[u];
      return new po(a, this._parents, this._name, this._id);
    },
    selection: function () {
      return new so(this._groups, this._parents);
    },
    transition: function () {
      for (var t = this._name, n = this._id, e = yo(), r = this._groups, i = r.length, o = 0; o < i; ++o) for (var a, u = r[o], c = u.length, f = 0; f < c; ++f) if (a = u[f]) {
        var s = Xi(a, n);
        Li(a, t, e, f, u, {
          time: s.time + s.delay + s.duration,
          delay: 0,
          duration: s.duration,
          ease: s.ease
        });
      }
      return new po(r, this._parents, t, e);
    },
    call: vo.call,
    nodes: vo.nodes,
    node: vo.node,
    size: vo.size,
    empty: vo.empty,
    each: vo.each,
    on: function (t, n) {
      var e = this._id;
      return arguments.length < 2 ? Xi(this.node(), e).on.on(t) : this.each(function (t, n, e) {
        var r,
          i,
          o = function (t) {
            return (t + "").trim().split(/^|\s+/).every(function (t) {
              var n = t.indexOf(".");
              return n >= 0 && (t = t.slice(0, n)), !t || "start" === t;
            });
          }(n) ? ji : Hi;
        return function () {
          var a = o(this, t),
            u = a.on;
          u !== r && (i = (r = u).copy()).on(n, e), a.on = i;
        };
      }(e, t, n));
    },
    attr: function (t, n) {
      var e = It(t),
        r = "transform" === e ? ni : Ki;
      return this.attrTween(t, "function" == typeof n ? (e.local ? ro : eo)(e, r, Zi(this, "attr." + t, n)) : null == n ? (e.local ? Ji : Qi)(e) : (e.local ? no : to)(e, r, n));
    },
    attrTween: function (t, n) {
      var e = "attr." + t;
      if (arguments.length < 2) return (e = this.tween(e)) && e._value;
      if (null == n) return this.tween(e, null);
      if ("function" != typeof n) throw new Error();
      var r = It(t);
      return this.tween(e, (r.local ? io : oo)(r, n));
    },
    style: function (t, n, e) {
      var r = "transform" == (t += "") ? ti : Ki;
      return null == n ? this.styleTween(t, function (t, n) {
        var e, r, i;
        return function () {
          var o = _n(this, t),
            a = (this.style.removeProperty(t), _n(this, t));
          return o === a ? null : o === e && a === r ? i : i = n(e = o, r = a);
        };
      }(t, r)).on("end.style." + t, lo(t)) : "function" == typeof n ? this.styleTween(t, function (t, n, e) {
        var r, i, o;
        return function () {
          var a = _n(this, t),
            u = e(this),
            c = u + "";
          return null == u && (this.style.removeProperty(t), c = u = _n(this, t)), a === c ? null : a === r && c === i ? o : (i = c, o = n(r = a, u));
        };
      }(t, r, Zi(this, "style." + t, n))).each(function (t, n) {
        var e,
          r,
          i,
          o,
          a = "style." + n,
          u = "end." + a;
        return function () {
          var c = Hi(this, t),
            f = c.on,
            s = null == c.value[a] ? o || (o = lo(n)) : void 0;
          f === e && i === s || (r = (e = f).copy()).on(u, i = s), c.on = r;
        };
      }(this._id, t)) : this.styleTween(t, function (t, n, e) {
        var r,
          i,
          o = e + "";
        return function () {
          var a = _n(this, t);
          return a === o ? null : a === r ? i : i = n(r = a, e);
        };
      }(t, r, n), e).on("end.style." + t, null);
    },
    styleTween: function (t, n, e) {
      var r = "style." + (t += "");
      if (arguments.length < 2) return (r = this.tween(r)) && r._value;
      if (null == n) return this.tween(r, null);
      if ("function" != typeof n) throw new Error();
      return this.tween(r, function (t, n, e) {
        var r, i;
        function o() {
          var o = n.apply(this, arguments);
          return o !== i && (r = (i = o) && function (t, n, e) {
            return function (r) {
              this.style.setProperty(t, n.call(this, r), e);
            };
          }(t, o, e)), r;
        }
        return o._value = n, o;
      }(t, n, null == e ? "" : e));
    },
    text: function (t) {
      return this.tween("text", "function" == typeof t ? function (t) {
        return function () {
          var n = t(this);
          this.textContent = null == n ? "" : n;
        };
      }(Zi(this, "text", t)) : function (t) {
        return function () {
          this.textContent = t;
        };
      }(null == t ? "" : t + ""));
    },
    textTween: function (t) {
      var n = "text";
      if (arguments.length < 1) return (n = this.tween(n)) && n._value;
      if (null == t) return this.tween(n, null);
      if ("function" != typeof t) throw new Error();
      return this.tween(n, function (t) {
        var n, e;
        function r() {
          var r = t.apply(this, arguments);
          return r !== e && (n = (e = r) && function (t) {
            return function (n) {
              this.textContent = t.call(this, n);
            };
          }(r)), n;
        }
        return r._value = t, r;
      }(t));
    },
    remove: function () {
      return this.on("end.remove", function (t) {
        return function () {
          var n = this.parentNode;
          for (var e in this.__transition) if (+e !== t) return;
          n && n.removeChild(this);
        };
      }(this._id));
    },
    tween: function (t, n) {
      var e = this._id;
      if (t += "", arguments.length < 2) {
        for (var r, i = Xi(this.node(), e).tween, o = 0, a = i.length; o < a; ++o) if ((r = i[o]).name === t) return r.value;
        return null;
      }
      return this.each((null == n ? Vi : Wi)(e, t, n));
    },
    delay: function (t) {
      var n = this._id;
      return arguments.length ? this.each(("function" == typeof t ? ao : uo)(n, t)) : Xi(this.node(), n).delay;
    },
    duration: function (t) {
      var n = this._id;
      return arguments.length ? this.each(("function" == typeof t ? co : fo)(n, t)) : Xi(this.node(), n).duration;
    },
    ease: function (t) {
      var n = this._id;
      return arguments.length ? this.each(function (t, n) {
        if ("function" != typeof n) throw new Error();
        return function () {
          Hi(this, t).ease = n;
        };
      }(n, t)) : Xi(this.node(), n).ease;
    },
    easeVarying: function (t) {
      if ("function" != typeof t) throw new Error();
      return this.each(function (t, n) {
        return function () {
          var e = n.apply(this, arguments);
          if ("function" != typeof e) throw new Error();
          Hi(this, t).ease = e;
        };
      }(this._id, t));
    },
    end: function () {
      var t,
        n,
        e = this,
        r = e._id,
        i = e.size();
      return new Promise(function (o, a) {
        var u = {
            value: a
          },
          c = {
            value: function () {
              0 == --i && o();
            }
          };
        e.each(function () {
          var e = Hi(this, r),
            i = e.on;
          i !== t && ((n = (t = i).copy())._.cancel.push(u), n._.interrupt.push(u), n._.end.push(c)), e.on = n;
        }), 0 === i && o();
      });
    },
    [Symbol.iterator]: vo[Symbol.iterator]
  };
  function _o(t) {
    return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
  }
  function bo(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }
  var mo = function t(n) {
      function e(t) {
        return Math.pow(t, n);
      }
      return n = +n, e.exponent = t, e;
    }(3),
    xo = function t(n) {
      function e(t) {
        return 1 - Math.pow(1 - t, n);
      }
      return n = +n, e.exponent = t, e;
    }(3),
    wo = function t(n) {
      function e(t) {
        return ((t *= 2) <= 1 ? Math.pow(t, n) : 2 - Math.pow(2 - t, n)) / 2;
      }
      return n = +n, e.exponent = t, e;
    }(3),
    Mo = Math.PI,
    To = Mo / 2;
  function Ao(t) {
    return (1 - Math.cos(Mo * t)) / 2;
  }
  function So(t) {
    return 1.0009775171065494 * (Math.pow(2, -10 * t) - .0009765625);
  }
  function Eo(t) {
    return ((t *= 2) <= 1 ? So(1 - t) : 2 - So(t - 1)) / 2;
  }
  function No(t) {
    return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
  }
  var ko = 4 / 11,
    Co = 6 / 11,
    Po = 8 / 11,
    zo = 3 / 4,
    $o = 9 / 11,
    Do = 10 / 11,
    Ro = 15 / 16,
    Fo = 21 / 22,
    qo = 63 / 64,
    Uo = 1 / ko / ko;
  function Io(t) {
    return (t = +t) < ko ? Uo * t * t : t < Po ? Uo * (t -= Co) * t + zo : t < Do ? Uo * (t -= $o) * t + Ro : Uo * (t -= Fo) * t + qo;
  }
  var Oo = 1.70158,
    Bo = function t(n) {
      function e(t) {
        return (t = +t) * t * (n * (t - 1) + t);
      }
      return n = +n, e.overshoot = t, e;
    }(Oo),
    Yo = function t(n) {
      function e(t) {
        return --t * t * ((t + 1) * n + t) + 1;
      }
      return n = +n, e.overshoot = t, e;
    }(Oo),
    Lo = function t(n) {
      function e(t) {
        return ((t *= 2) < 1 ? t * t * ((n + 1) * t - n) : (t -= 2) * t * ((n + 1) * t + n) + 2) / 2;
      }
      return n = +n, e.overshoot = t, e;
    }(Oo),
    jo = 2 * Math.PI,
    Ho = function t(n, e) {
      var r = Math.asin(1 / (n = Math.max(1, n))) * (e /= jo);
      function i(t) {
        return n * So(- --t) * Math.sin((r - t) / e);
      }
      return i.amplitude = function (n) {
        return t(n, e * jo);
      }, i.period = function (e) {
        return t(n, e);
      }, i;
    }(1, .3),
    Xo = function t(n, e) {
      var r = Math.asin(1 / (n = Math.max(1, n))) * (e /= jo);
      function i(t) {
        return 1 - n * So(t = +t) * Math.sin((t + r) / e);
      }
      return i.amplitude = function (n) {
        return t(n, e * jo);
      }, i.period = function (e) {
        return t(n, e);
      }, i;
    }(1, .3),
    Go = function t(n, e) {
      var r = Math.asin(1 / (n = Math.max(1, n))) * (e /= jo);
      function i(t) {
        return ((t = 2 * t - 1) < 0 ? n * So(-t) * Math.sin((r - t) / e) : 2 - n * So(t) * Math.sin((r + t) / e)) / 2;
      }
      return i.amplitude = function (n) {
        return t(n, e * jo);
      }, i.period = function (e) {
        return t(n, e);
      }, i;
    }(1, .3),
    Vo = {
      time: null,
      delay: 0,
      duration: 250,
      ease: bo
    };
  function Wo(t, n) {
    for (var e; !(e = t.__transition) || !(e = e[n]);) if (!(t = t.parentNode)) throw new Error(`transition ${n} not found`);
    return e;
  }
  Wn.prototype.interrupt = function (t) {
    return this.each(function () {
      Gi(this, t);
    });
  }, Wn.prototype.transition = function (t) {
    var n, e;
    t instanceof po ? (n = t._id, t = t._name) : (n = yo(), (e = Vo).time = Ai(), t = null == t ? null : t + "");
    for (var r = this._groups, i = r.length, o = 0; o < i; ++o) for (var a, u = r[o], c = u.length, f = 0; f < c; ++f) (a = u[f]) && Li(a, t, n, f, u, e || Wo(a, n));
    return new po(r, this._parents, t, n);
  };
  var Zo = [null];
  var Ko = t => () => t;
  function Qo(t, {
    sourceEvent: n,
    target: e,
    selection: r,
    mode: i,
    dispatch: o
  }) {
    Object.defineProperties(this, {
      type: {
        value: t,
        enumerable: !0,
        configurable: !0
      },
      sourceEvent: {
        value: n,
        enumerable: !0,
        configurable: !0
      },
      target: {
        value: e,
        enumerable: !0,
        configurable: !0
      },
      selection: {
        value: r,
        enumerable: !0,
        configurable: !0
      },
      mode: {
        value: i,
        enumerable: !0,
        configurable: !0
      },
      _: {
        value: o
      }
    });
  }
  function Jo(t) {
    t.preventDefault(), t.stopImmediatePropagation();
  }
  var ta = {
      name: "drag"
    },
    na = {
      name: "space"
    },
    ea = {
      name: "handle"
    },
    ra = {
      name: "center"
    };
  const {
    abs: ia,
    max: oa,
    min: aa
  } = Math;
  function ua(t) {
    return [+t[0], +t[1]];
  }
  function ca(t) {
    return [ua(t[0]), ua(t[1])];
  }
  var fa = {
      name: "x",
      handles: ["w", "e"].map(va),
      input: function (t, n) {
        return null == t ? null : [[+t[0], n[0][1]], [+t[1], n[1][1]]];
      },
      output: function (t) {
        return t && [t[0][0], t[1][0]];
      }
    },
    sa = {
      name: "y",
      handles: ["n", "s"].map(va),
      input: function (t, n) {
        return null == t ? null : [[n[0][0], +t[0]], [n[1][0], +t[1]]];
      },
      output: function (t) {
        return t && [t[0][1], t[1][1]];
      }
    },
    la = {
      name: "xy",
      handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(va),
      input: function (t) {
        return null == t ? null : ca(t);
      },
      output: function (t) {
        return t;
      }
    },
    ha = {
      overlay: "crosshair",
      selection: "move",
      n: "ns-resize",
      e: "ew-resize",
      s: "ns-resize",
      w: "ew-resize",
      nw: "nwse-resize",
      ne: "nesw-resize",
      se: "nwse-resize",
      sw: "nesw-resize"
    },
    da = {
      e: "w",
      w: "e",
      nw: "ne",
      ne: "nw",
      se: "sw",
      sw: "se"
    },
    pa = {
      n: "s",
      s: "n",
      nw: "sw",
      ne: "se",
      se: "ne",
      sw: "nw"
    },
    ga = {
      overlay: 1,
      selection: 1,
      n: null,
      e: 1,
      s: null,
      w: -1,
      nw: -1,
      ne: 1,
      se: 1,
      sw: -1
    },
    ya = {
      overlay: 1,
      selection: 1,
      n: -1,
      e: null,
      s: 1,
      w: null,
      nw: -1,
      ne: -1,
      se: 1,
      sw: 1
    };
  function va(t) {
    return {
      type: t
    };
  }
  function _a(t) {
    return !t.ctrlKey && !t.button;
  }
  function ba() {
    var t = this.ownerSVGElement || this;
    return t.hasAttribute("viewBox") ? [[(t = t.viewBox.baseVal).x, t.y], [t.x + t.width, t.y + t.height]] : [[0, 0], [t.width.baseVal.value, t.height.baseVal.value]];
  }
  function ma() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function xa(t) {
    for (; !t.__brush;) if (!(t = t.parentNode)) return;
    return t.__brush;
  }
  function wa(t) {
    var n,
      e = ba,
      r = _a,
      i = ma,
      o = !0,
      a = $t("start", "brush", "end"),
      u = 6;
    function c(n) {
      var e = n.property("__brush", g).selectAll(".overlay").data([va("overlay")]);
      e.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", ha.overlay).merge(e).each(function () {
        var t = xa(this).extent;
        Zn(this).attr("x", t[0][0]).attr("y", t[0][1]).attr("width", t[1][0] - t[0][0]).attr("height", t[1][1] - t[0][1]);
      }), n.selectAll(".selection").data([va("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", ha.selection).attr("fill", "#777").attr("fill-opacity", .3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
      var r = n.selectAll(".handle").data(t.handles, function (t) {
        return t.type;
      });
      r.exit().remove(), r.enter().append("rect").attr("class", function (t) {
        return "handle handle--" + t.type;
      }).attr("cursor", function (t) {
        return ha[t.type];
      }), n.each(f).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", h).filter(i).on("touchstart.brush", h).on("touchmove.brush", d).on("touchend.brush touchcancel.brush", p).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function f() {
      var t = Zn(this),
        n = xa(this).selection;
      n ? (t.selectAll(".selection").style("display", null).attr("x", n[0][0]).attr("y", n[0][1]).attr("width", n[1][0] - n[0][0]).attr("height", n[1][1] - n[0][1]), t.selectAll(".handle").style("display", null).attr("x", function (t) {
        return "e" === t.type[t.type.length - 1] ? n[1][0] - u / 2 : n[0][0] - u / 2;
      }).attr("y", function (t) {
        return "s" === t.type[0] ? n[1][1] - u / 2 : n[0][1] - u / 2;
      }).attr("width", function (t) {
        return "n" === t.type || "s" === t.type ? n[1][0] - n[0][0] + u : u;
      }).attr("height", function (t) {
        return "e" === t.type || "w" === t.type ? n[1][1] - n[0][1] + u : u;
      })) : t.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
    function s(t, n, e) {
      var r = t.__brush.emitter;
      return !r || e && r.clean ? new l(t, n, e) : r;
    }
    function l(t, n, e) {
      this.that = t, this.args = n, this.state = t.__brush, this.active = 0, this.clean = e;
    }
    function h(e) {
      if ((!n || e.touches) && r.apply(this, arguments)) {
        var i,
          a,
          u,
          c,
          l,
          h,
          d,
          p,
          g,
          y,
          v,
          _ = this,
          b = e.target.__data__.type,
          m = "selection" === (o && e.metaKey ? b = "overlay" : b) ? ta : o && e.altKey ? ra : ea,
          x = t === sa ? null : ga[b],
          w = t === fa ? null : ya[b],
          M = xa(_),
          T = M.extent,
          A = M.selection,
          S = T[0][0],
          E = T[0][1],
          N = T[1][0],
          k = T[1][1],
          C = 0,
          P = 0,
          z = x && w && o && e.shiftKey,
          $ = Array.from(e.touches || [e], t => {
            const n = t.identifier;
            return (t = ne(t, _)).point0 = t.slice(), t.identifier = n, t;
          });
        Gi(_);
        var D = s(_, arguments, !0).beforestart();
        if ("overlay" === b) {
          A && (g = !0);
          const n = [$[0], $[1] || $[0]];
          M.selection = A = [[i = t === sa ? S : aa(n[0][0], n[1][0]), u = t === fa ? E : aa(n[0][1], n[1][1])], [l = t === sa ? N : oa(n[0][0], n[1][0]), d = t === fa ? k : oa(n[0][1], n[1][1])]], $.length > 1 && I(e);
        } else i = A[0][0], u = A[0][1], l = A[1][0], d = A[1][1];
        a = i, c = u, h = l, p = d;
        var R = Zn(_).attr("pointer-events", "none"),
          F = R.selectAll(".overlay").attr("cursor", ha[b]);
        if (e.touches) D.moved = U, D.ended = O;else {
          var q = Zn(e.view).on("mousemove.brush", U, !0).on("mouseup.brush", O, !0);
          o && q.on("keydown.brush", function (t) {
            switch (t.keyCode) {
              case 16:
                z = x && w;
                break;
              case 18:
                m === ea && (x && (l = h - C * x, i = a + C * x), w && (d = p - P * w, u = c + P * w), m = ra, I(t));
                break;
              case 32:
                m !== ea && m !== ra || (x < 0 ? l = h - C : x > 0 && (i = a - C), w < 0 ? d = p - P : w > 0 && (u = c - P), m = na, F.attr("cursor", ha.selection), I(t));
                break;
              default:
                return;
            }
            Jo(t);
          }, !0).on("keyup.brush", function (t) {
            switch (t.keyCode) {
              case 16:
                z && (y = v = z = !1, I(t));
                break;
              case 18:
                m === ra && (x < 0 ? l = h : x > 0 && (i = a), w < 0 ? d = p : w > 0 && (u = c), m = ea, I(t));
                break;
              case 32:
                m === na && (t.altKey ? (x && (l = h - C * x, i = a + C * x), w && (d = p - P * w, u = c + P * w), m = ra) : (x < 0 ? l = h : x > 0 && (i = a), w < 0 ? d = p : w > 0 && (u = c), m = ea), F.attr("cursor", ha[b]), I(t));
                break;
              default:
                return;
            }
            Jo(t);
          }, !0), ae(e.view);
        }
        f.call(_), D.start(e, m.name);
      }
      function U(t) {
        for (const n of t.changedTouches || [t]) for (const t of $) t.identifier === n.identifier && (t.cur = ne(n, _));
        if (z && !y && !v && 1 === $.length) {
          const t = $[0];
          ia(t.cur[0] - t[0]) > ia(t.cur[1] - t[1]) ? v = !0 : y = !0;
        }
        for (const t of $) t.cur && (t[0] = t.cur[0], t[1] = t.cur[1]);
        g = !0, Jo(t), I(t);
      }
      function I(t) {
        const n = $[0],
          e = n.point0;
        var r;
        switch (C = n[0] - e[0], P = n[1] - e[1], m) {
          case na:
          case ta:
            x && (C = oa(S - i, aa(N - l, C)), a = i + C, h = l + C), w && (P = oa(E - u, aa(k - d, P)), c = u + P, p = d + P);
            break;
          case ea:
            $[1] ? (x && (a = oa(S, aa(N, $[0][0])), h = oa(S, aa(N, $[1][0])), x = 1), w && (c = oa(E, aa(k, $[0][1])), p = oa(E, aa(k, $[1][1])), w = 1)) : (x < 0 ? (C = oa(S - i, aa(N - i, C)), a = i + C, h = l) : x > 0 && (C = oa(S - l, aa(N - l, C)), a = i, h = l + C), w < 0 ? (P = oa(E - u, aa(k - u, P)), c = u + P, p = d) : w > 0 && (P = oa(E - d, aa(k - d, P)), c = u, p = d + P));
            break;
          case ra:
            x && (a = oa(S, aa(N, i - C * x)), h = oa(S, aa(N, l + C * x))), w && (c = oa(E, aa(k, u - P * w)), p = oa(E, aa(k, d + P * w)));
        }
        h < a && (x *= -1, r = i, i = l, l = r, r = a, a = h, h = r, b in da && F.attr("cursor", ha[b = da[b]])), p < c && (w *= -1, r = u, u = d, d = r, r = c, c = p, p = r, b in pa && F.attr("cursor", ha[b = pa[b]])), M.selection && (A = M.selection), y && (a = A[0][0], h = A[1][0]), v && (c = A[0][1], p = A[1][1]), A[0][0] === a && A[0][1] === c && A[1][0] === h && A[1][1] === p || (M.selection = [[a, c], [h, p]], f.call(_), D.brush(t, m.name));
      }
      function O(t) {
        if (function (t) {
          t.stopImmediatePropagation();
        }(t), t.touches) {
          if (t.touches.length) return;
          n && clearTimeout(n), n = setTimeout(function () {
            n = null;
          }, 500);
        } else ue(t.view, g), q.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
        R.attr("pointer-events", "all"), F.attr("cursor", ha.overlay), M.selection && (A = M.selection), function (t) {
          return t[0][0] === t[1][0] || t[0][1] === t[1][1];
        }(A) && (M.selection = null, f.call(_)), D.end(t, m.name);
      }
    }
    function d(t) {
      s(this, arguments).moved(t);
    }
    function p(t) {
      s(this, arguments).ended(t);
    }
    function g() {
      var n = this.__brush || {
        selection: null
      };
      return n.extent = ca(e.apply(this, arguments)), n.dim = t, n;
    }
    return c.move = function (n, e, r) {
      n.tween ? n.on("start.brush", function (t) {
        s(this, arguments).beforestart().start(t);
      }).on("interrupt.brush end.brush", function (t) {
        s(this, arguments).end(t);
      }).tween("brush", function () {
        var n = this,
          r = n.__brush,
          i = s(n, arguments),
          o = r.selection,
          a = t.input("function" == typeof e ? e.apply(this, arguments) : e, r.extent),
          u = Gr(o, a);
        function c(t) {
          r.selection = 1 === t && null === a ? null : u(t), f.call(n), i.brush();
        }
        return null !== o && null !== a ? c : c(1);
      }) : n.each(function () {
        var n = this,
          i = arguments,
          o = n.__brush,
          a = t.input("function" == typeof e ? e.apply(n, i) : e, o.extent),
          u = s(n, i).beforestart();
        Gi(n), o.selection = null === a ? null : a, f.call(n), u.start(r).brush(r).end(r);
      });
    }, c.clear = function (t, n) {
      c.move(t, null, n);
    }, l.prototype = {
      beforestart: function () {
        return 1 == ++this.active && (this.state.emitter = this, this.starting = !0), this;
      },
      start: function (t, n) {
        return this.starting ? (this.starting = !1, this.emit("start", t, n)) : this.emit("brush", t), this;
      },
      brush: function (t, n) {
        return this.emit("brush", t, n), this;
      },
      end: function (t, n) {
        return 0 == --this.active && (delete this.state.emitter, this.emit("end", t, n)), this;
      },
      emit: function (n, e, r) {
        var i = Zn(this.that).datum();
        a.call(n, this.that, new Qo(n, {
          sourceEvent: e,
          target: c,
          selection: t.output(this.state.selection),
          mode: r,
          dispatch: a
        }), i);
      }
    }, c.extent = function (t) {
      return arguments.length ? (e = "function" == typeof t ? t : Ko(ca(t)), c) : e;
    }, c.filter = function (t) {
      return arguments.length ? (r = "function" == typeof t ? t : Ko(!!t), c) : r;
    }, c.touchable = function (t) {
      return arguments.length ? (i = "function" == typeof t ? t : Ko(!!t), c) : i;
    }, c.handleSize = function (t) {
      return arguments.length ? (u = +t, c) : u;
    }, c.keyModifiers = function (t) {
      return arguments.length ? (o = !!t, c) : o;
    }, c.on = function () {
      var t = a.on.apply(a, arguments);
      return t === a ? c : t;
    }, c;
  }
  var Ma = Math.abs,
    Ta = Math.cos,
    Aa = Math.sin,
    Sa = Math.PI,
    Ea = Sa / 2,
    Na = 2 * Sa,
    ka = Math.max,
    Ca = 1e-12;
  function Pa(t, n) {
    return Array.from({
      length: n - t
    }, (n, e) => t + e);
  }
  function za(t, n) {
    var e = 0,
      r = null,
      i = null,
      o = null;
    function a(a) {
      var u,
        c = a.length,
        f = new Array(c),
        s = Pa(0, c),
        l = new Array(c * c),
        h = new Array(c),
        d = 0;
      a = Float64Array.from({
        length: c * c
      }, n ? (t, n) => a[n % c][n / c | 0] : (t, n) => a[n / c | 0][n % c]);
      for (let n = 0; n < c; ++n) {
        let e = 0;
        for (let r = 0; r < c; ++r) e += a[n * c + r] + t * a[r * c + n];
        d += f[n] = e;
      }
      u = (d = ka(0, Na - e * c) / d) ? e : Na / c;
      {
        let n = 0;
        r && s.sort((t, n) => r(f[t], f[n]));
        for (const e of s) {
          const r = n;
          if (t) {
            const t = Pa(1 + ~c, c).filter(t => t < 0 ? a[~t * c + e] : a[e * c + t]);
            i && t.sort((t, n) => i(t < 0 ? -a[~t * c + e] : a[e * c + t], n < 0 ? -a[~n * c + e] : a[e * c + n]));
            for (const r of t) if (r < 0) {
              (l[~r * c + e] || (l[~r * c + e] = {
                source: null,
                target: null
              })).target = {
                index: e,
                startAngle: n,
                endAngle: n += a[~r * c + e] * d,
                value: a[~r * c + e]
              };
            } else {
              (l[e * c + r] || (l[e * c + r] = {
                source: null,
                target: null
              })).source = {
                index: e,
                startAngle: n,
                endAngle: n += a[e * c + r] * d,
                value: a[e * c + r]
              };
            }
            h[e] = {
              index: e,
              startAngle: r,
              endAngle: n,
              value: f[e]
            };
          } else {
            const t = Pa(0, c).filter(t => a[e * c + t] || a[t * c + e]);
            i && t.sort((t, n) => i(a[e * c + t], a[e * c + n]));
            for (const r of t) {
              let t;
              if (e < r ? (t = l[e * c + r] || (l[e * c + r] = {
                source: null,
                target: null
              }), t.source = {
                index: e,
                startAngle: n,
                endAngle: n += a[e * c + r] * d,
                value: a[e * c + r]
              }) : (t = l[r * c + e] || (l[r * c + e] = {
                source: null,
                target: null
              }), t.target = {
                index: e,
                startAngle: n,
                endAngle: n += a[e * c + r] * d,
                value: a[e * c + r]
              }, e === r && (t.source = t.target)), t.source && t.target && t.source.value < t.target.value) {
                const n = t.source;
                t.source = t.target, t.target = n;
              }
            }
            h[e] = {
              index: e,
              startAngle: r,
              endAngle: n,
              value: f[e]
            };
          }
          n += u;
        }
      }
      return (l = Object.values(l)).groups = h, o ? l.sort(o) : l;
    }
    return a.padAngle = function (t) {
      return arguments.length ? (e = ka(0, t), a) : e;
    }, a.sortGroups = function (t) {
      return arguments.length ? (r = t, a) : r;
    }, a.sortSubgroups = function (t) {
      return arguments.length ? (i = t, a) : i;
    }, a.sortChords = function (t) {
      return arguments.length ? (null == t ? o = null : (n = t, o = function (t, e) {
        return n(t.source.value + t.target.value, e.source.value + e.target.value);
      })._ = t, a) : o && o._;
      var n;
    }, a;
  }
  const $a = Math.PI,
    Da = 2 * $a,
    Ra = 1e-6,
    Fa = Da - Ra;
  function qa(t) {
    this._ += t[0];
    for (let n = 1, e = t.length; n < e; ++n) this._ += arguments[n] + t[n];
  }
  let Ua = class {
    constructor(t) {
      this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = null == t ? qa : function (t) {
        let n = Math.floor(t);
        if (!(n >= 0)) throw new Error(`invalid digits: ${t}`);
        if (n > 15) return qa;
        const e = 10 ** n;
        return function (t) {
          this._ += t[0];
          for (let n = 1, r = t.length; n < r; ++n) this._ += Math.round(arguments[n] * e) / e + t[n];
        };
      }(t);
    }
    moveTo(t, n) {
      this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
    }
    closePath() {
      null !== this._x1 && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
    }
    lineTo(t, n) {
      this._append`L${this._x1 = +t},${this._y1 = +n}`;
    }
    quadraticCurveTo(t, n, e, r) {
      this._append`Q${+t},${+n},${this._x1 = +e},${this._y1 = +r}`;
    }
    bezierCurveTo(t, n, e, r, i, o) {
      this._append`C${+t},${+n},${+e},${+r},${this._x1 = +i},${this._y1 = +o}`;
    }
    arcTo(t, n, e, r, i) {
      if (t = +t, n = +n, e = +e, r = +r, (i = +i) < 0) throw new Error(`negative radius: ${i}`);
      let o = this._x1,
        a = this._y1,
        u = e - t,
        c = r - n,
        f = o - t,
        s = a - n,
        l = f * f + s * s;
      if (null === this._x1) this._append`M${this._x1 = t},${this._y1 = n}`;else if (l > Ra) {
        if (Math.abs(s * u - c * f) > Ra && i) {
          let h = e - o,
            d = r - a,
            p = u * u + c * c,
            g = h * h + d * d,
            y = Math.sqrt(p),
            v = Math.sqrt(l),
            _ = i * Math.tan(($a - Math.acos((p + l - g) / (2 * y * v))) / 2),
            b = _ / v,
            m = _ / y;
          Math.abs(b - 1) > Ra && this._append`L${t + b * f},${n + b * s}`, this._append`A${i},${i},0,0,${+(s * h > f * d)},${this._x1 = t + m * u},${this._y1 = n + m * c}`;
        } else this._append`L${this._x1 = t},${this._y1 = n}`;
      } else ;
    }
    arc(t, n, e, r, i, o) {
      if (t = +t, n = +n, o = !!o, (e = +e) < 0) throw new Error(`negative radius: ${e}`);
      let a = e * Math.cos(r),
        u = e * Math.sin(r),
        c = t + a,
        f = n + u,
        s = 1 ^ o,
        l = o ? r - i : i - r;
      null === this._x1 ? this._append`M${c},${f}` : (Math.abs(this._x1 - c) > Ra || Math.abs(this._y1 - f) > Ra) && this._append`L${c},${f}`, e && (l < 0 && (l = l % Da + Da), l > Fa ? this._append`A${e},${e},0,1,${s},${t - a},${n - u}A${e},${e},0,1,${s},${this._x1 = c},${this._y1 = f}` : l > Ra && this._append`A${e},${e},0,${+(l >= $a)},${s},${this._x1 = t + e * Math.cos(i)},${this._y1 = n + e * Math.sin(i)}`);
    }
    rect(t, n, e, r) {
      this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${e = +e}v${+r}h${-e}Z`;
    }
    toString() {
      return this._;
    }
  };
  function Ia() {
    return new Ua();
  }
  Ia.prototype = Ua.prototype;
  var Oa = Array.prototype.slice;
  function Ba(t) {
    return function () {
      return t;
    };
  }
  function Ya(t) {
    return t.source;
  }
  function La(t) {
    return t.target;
  }
  function ja(t) {
    return t.radius;
  }
  function Ha(t) {
    return t.startAngle;
  }
  function Xa(t) {
    return t.endAngle;
  }
  function Ga() {
    return 0;
  }
  function Va() {
    return 10;
  }
  function Wa(t) {
    var n = Ya,
      e = La,
      r = ja,
      i = ja,
      o = Ha,
      a = Xa,
      u = Ga,
      c = null;
    function f() {
      var f,
        s = n.apply(this, arguments),
        l = e.apply(this, arguments),
        h = u.apply(this, arguments) / 2,
        d = Oa.call(arguments),
        p = +r.apply(this, (d[0] = s, d)),
        g = o.apply(this, d) - Ea,
        y = a.apply(this, d) - Ea,
        v = +i.apply(this, (d[0] = l, d)),
        _ = o.apply(this, d) - Ea,
        b = a.apply(this, d) - Ea;
      if (c || (c = f = Ia()), h > Ca && (Ma(y - g) > 2 * h + Ca ? y > g ? (g += h, y -= h) : (g -= h, y += h) : g = y = (g + y) / 2, Ma(b - _) > 2 * h + Ca ? b > _ ? (_ += h, b -= h) : (_ -= h, b += h) : _ = b = (_ + b) / 2), c.moveTo(p * Ta(g), p * Aa(g)), c.arc(0, 0, p, g, y), g !== _ || y !== b) if (t) {
        var m = v - +t.apply(this, arguments),
          x = (_ + b) / 2;
        c.quadraticCurveTo(0, 0, m * Ta(_), m * Aa(_)), c.lineTo(v * Ta(x), v * Aa(x)), c.lineTo(m * Ta(b), m * Aa(b));
      } else c.quadraticCurveTo(0, 0, v * Ta(_), v * Aa(_)), c.arc(0, 0, v, _, b);
      if (c.quadraticCurveTo(0, 0, p * Ta(g), p * Aa(g)), c.closePath(), f) return c = null, f + "" || null;
    }
    return t && (f.headRadius = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : Ba(+n), f) : t;
    }), f.radius = function (t) {
      return arguments.length ? (r = i = "function" == typeof t ? t : Ba(+t), f) : r;
    }, f.sourceRadius = function (t) {
      return arguments.length ? (r = "function" == typeof t ? t : Ba(+t), f) : r;
    }, f.targetRadius = function (t) {
      return arguments.length ? (i = "function" == typeof t ? t : Ba(+t), f) : i;
    }, f.startAngle = function (t) {
      return arguments.length ? (o = "function" == typeof t ? t : Ba(+t), f) : o;
    }, f.endAngle = function (t) {
      return arguments.length ? (a = "function" == typeof t ? t : Ba(+t), f) : a;
    }, f.padAngle = function (t) {
      return arguments.length ? (u = "function" == typeof t ? t : Ba(+t), f) : u;
    }, f.source = function (t) {
      return arguments.length ? (n = t, f) : n;
    }, f.target = function (t) {
      return arguments.length ? (e = t, f) : e;
    }, f.context = function (t) {
      return arguments.length ? (c = null == t ? null : t, f) : c;
    }, f;
  }
  var Za = Array.prototype.slice;
  function Ka(t, n) {
    return t - n;
  }
  var Qa = t => () => t;
  function Ja(t, n) {
    for (var e, r = -1, i = n.length; ++r < i;) if (e = tu(t, n[r])) return e;
    return 0;
  }
  function tu(t, n) {
    for (var e = n[0], r = n[1], i = -1, o = 0, a = t.length, u = a - 1; o < a; u = o++) {
      var c = t[o],
        f = c[0],
        s = c[1],
        l = t[u],
        h = l[0],
        d = l[1];
      if (nu(c, l, n)) return 0;
      s > r != d > r && e < (h - f) * (r - s) / (d - s) + f && (i = -i);
    }
    return i;
  }
  function nu(t, n, e) {
    var r, i, o, a;
    return function (t, n, e) {
      return (n[0] - t[0]) * (e[1] - t[1]) == (e[0] - t[0]) * (n[1] - t[1]);
    }(t, n, e) && (i = t[r = +(t[0] === n[0])], o = e[r], a = n[r], i <= o && o <= a || a <= o && o <= i);
  }
  function eu() {}
  var ru = [[], [[[1, 1.5], [.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [.5, 1]]], [[[1, .5], [1.5, 1]]], [[[1, 1.5], [.5, 1]], [[1, .5], [1.5, 1]]], [[[1, .5], [1, 1.5]]], [[[1, .5], [.5, 1]]], [[[.5, 1], [1, .5]]], [[[1, 1.5], [1, .5]]], [[[.5, 1], [1, .5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, .5]]], [[[.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[.5, 1], [1, 1.5]]], []];
  function iu() {
    var t = 1,
      n = 1,
      e = K,
      r = u;
    function i(t) {
      var n = e(t);
      if (Array.isArray(n)) n = n.slice().sort(Ka);else {
        const e = M(t, ou);
        for (n = G(...Z(e[0], e[1], n), n); n[n.length - 1] >= e[1];) n.pop();
        for (; n[1] < e[0];) n.shift();
      }
      return n.map(n => o(t, n));
    }
    function o(e, i) {
      const o = null == i ? NaN : +i;
      if (isNaN(o)) throw new Error(`invalid value: ${i}`);
      var u = [],
        c = [];
      return function (e, r, i) {
        var o,
          u,
          c,
          f,
          s,
          l,
          h = new Array(),
          d = new Array();
        o = u = -1, f = au(e[0], r), ru[f << 1].forEach(p);
        for (; ++o < t - 1;) c = f, f = au(e[o + 1], r), ru[c | f << 1].forEach(p);
        ru[f << 0].forEach(p);
        for (; ++u < n - 1;) {
          for (o = -1, f = au(e[u * t + t], r), s = au(e[u * t], r), ru[f << 1 | s << 2].forEach(p); ++o < t - 1;) c = f, f = au(e[u * t + t + o + 1], r), l = s, s = au(e[u * t + o + 1], r), ru[c | f << 1 | s << 2 | l << 3].forEach(p);
          ru[f | s << 3].forEach(p);
        }
        o = -1, s = e[u * t] >= r, ru[s << 2].forEach(p);
        for (; ++o < t - 1;) l = s, s = au(e[u * t + o + 1], r), ru[s << 2 | l << 3].forEach(p);
        function p(t) {
          var n,
            e,
            r = [t[0][0] + o, t[0][1] + u],
            c = [t[1][0] + o, t[1][1] + u],
            f = a(r),
            s = a(c);
          (n = d[f]) ? (e = h[s]) ? (delete d[n.end], delete h[e.start], n === e ? (n.ring.push(c), i(n.ring)) : h[n.start] = d[e.end] = {
            start: n.start,
            end: e.end,
            ring: n.ring.concat(e.ring)
          }) : (delete d[n.end], n.ring.push(c), d[n.end = s] = n) : (n = h[s]) ? (e = d[f]) ? (delete h[n.start], delete d[e.end], n === e ? (n.ring.push(c), i(n.ring)) : h[e.start] = d[n.end] = {
            start: e.start,
            end: n.end,
            ring: e.ring.concat(n.ring)
          }) : (delete h[n.start], n.ring.unshift(r), h[n.start = f] = n) : h[f] = d[s] = {
            start: f,
            end: s,
            ring: [r, c]
          };
        }
        ru[s << 3].forEach(p);
      }(e, o, function (t) {
        r(t, e, o), function (t) {
          for (var n = 0, e = t.length, r = t[e - 1][1] * t[0][0] - t[e - 1][0] * t[0][1]; ++n < e;) r += t[n - 1][1] * t[n][0] - t[n - 1][0] * t[n][1];
          return r;
        }(t) > 0 ? u.push([t]) : c.push(t);
      }), c.forEach(function (t) {
        for (var n, e = 0, r = u.length; e < r; ++e) if (-1 !== Ja((n = u[e])[0], t)) return void n.push(t);
      }), {
        type: "MultiPolygon",
        value: i,
        coordinates: u
      };
    }
    function a(n) {
      return 2 * n[0] + n[1] * (t + 1) * 4;
    }
    function u(e, r, i) {
      e.forEach(function (e) {
        var o = e[0],
          a = e[1],
          u = 0 | o,
          c = 0 | a,
          f = uu(r[c * t + u]);
        o > 0 && o < t && u === o && (e[0] = cu(o, uu(r[c * t + u - 1]), f, i)), a > 0 && a < n && c === a && (e[1] = cu(a, uu(r[(c - 1) * t + u]), f, i));
      });
    }
    return i.contour = o, i.size = function (e) {
      if (!arguments.length) return [t, n];
      var r = Math.floor(e[0]),
        o = Math.floor(e[1]);
      if (!(r >= 0 && o >= 0)) throw new Error("invalid size");
      return t = r, n = o, i;
    }, i.thresholds = function (t) {
      return arguments.length ? (e = "function" == typeof t ? t : Array.isArray(t) ? Qa(Za.call(t)) : Qa(t), i) : e;
    }, i.smooth = function (t) {
      return arguments.length ? (r = t ? u : eu, i) : r === u;
    }, i;
  }
  function ou(t) {
    return isFinite(t) ? t : NaN;
  }
  function au(t, n) {
    return null != t && +t >= n;
  }
  function uu(t) {
    return null == t || isNaN(t = +t) ? -1 / 0 : t;
  }
  function cu(t, n, e, r) {
    const i = r - n,
      o = e - n,
      a = isFinite(i) || isFinite(o) ? i / o : Math.sign(i) / Math.sign(o);
    return isNaN(a) ? t : t + a - .5;
  }
  function fu(t) {
    return t[0];
  }
  function su(t) {
    return t[1];
  }
  function lu() {
    return 1;
  }
  const hu = 134217729,
    du = 33306690738754706e-32;
  function pu(t, n, e, r, i) {
    let o,
      a,
      u,
      c,
      f = n[0],
      s = r[0],
      l = 0,
      h = 0;
    s > f == s > -f ? (o = f, f = n[++l]) : (o = s, s = r[++h]);
    let d = 0;
    if (l < t && h < e) for (s > f == s > -f ? (a = f + o, u = o - (a - f), f = n[++l]) : (a = s + o, u = o - (a - s), s = r[++h]), o = a, 0 !== u && (i[d++] = u); l < t && h < e;) s > f == s > -f ? (a = o + f, c = a - o, u = o - (a - c) + (f - c), f = n[++l]) : (a = o + s, c = a - o, u = o - (a - c) + (s - c), s = r[++h]), o = a, 0 !== u && (i[d++] = u);
    for (; l < t;) a = o + f, c = a - o, u = o - (a - c) + (f - c), f = n[++l], o = a, 0 !== u && (i[d++] = u);
    for (; h < e;) a = o + s, c = a - o, u = o - (a - c) + (s - c), s = r[++h], o = a, 0 !== u && (i[d++] = u);
    return 0 === o && 0 !== d || (i[d++] = o), d;
  }
  function gu(t) {
    return new Float64Array(t);
  }
  const yu = 22204460492503146e-32,
    vu = 11093356479670487e-47,
    _u = gu(4),
    bu = gu(8),
    mu = gu(12),
    xu = gu(16),
    wu = gu(4);
  function Mu(t, n, e, r, i, o) {
    const a = (n - o) * (e - i),
      u = (t - i) * (r - o),
      c = a - u,
      f = Math.abs(a + u);
    return Math.abs(c) >= 33306690738754716e-32 * f ? c : -function (t, n, e, r, i, o, a) {
      let u, c, f, s, l, h, d, p, g, y, v, _, b, m, x, w, M, T;
      const A = t - i,
        S = e - i,
        E = n - o,
        N = r - o;
      m = A * N, h = hu * A, d = h - (h - A), p = A - d, h = hu * N, g = h - (h - N), y = N - g, x = p * y - (m - d * g - p * g - d * y), w = E * S, h = hu * E, d = h - (h - E), p = E - d, h = hu * S, g = h - (h - S), y = S - g, M = p * y - (w - d * g - p * g - d * y), v = x - M, l = x - v, _u[0] = x - (v + l) + (l - M), _ = m + v, l = _ - m, b = m - (_ - l) + (v - l), v = b - w, l = b - v, _u[1] = b - (v + l) + (l - w), T = _ + v, l = T - _, _u[2] = _ - (T - l) + (v - l), _u[3] = T;
      let k = function (t, n) {
          let e = n[0];
          for (let r = 1; r < t; r++) e += n[r];
          return e;
        }(4, _u),
        C = yu * a;
      if (k >= C || -k >= C) return k;
      if (l = t - A, u = t - (A + l) + (l - i), l = e - S, f = e - (S + l) + (l - i), l = n - E, c = n - (E + l) + (l - o), l = r - N, s = r - (N + l) + (l - o), 0 === u && 0 === c && 0 === f && 0 === s) return k;
      if (C = vu * a + du * Math.abs(k), k += A * s + N * u - (E * f + S * c), k >= C || -k >= C) return k;
      m = u * N, h = hu * u, d = h - (h - u), p = u - d, h = hu * N, g = h - (h - N), y = N - g, x = p * y - (m - d * g - p * g - d * y), w = c * S, h = hu * c, d = h - (h - c), p = c - d, h = hu * S, g = h - (h - S), y = S - g, M = p * y - (w - d * g - p * g - d * y), v = x - M, l = x - v, wu[0] = x - (v + l) + (l - M), _ = m + v, l = _ - m, b = m - (_ - l) + (v - l), v = b - w, l = b - v, wu[1] = b - (v + l) + (l - w), T = _ + v, l = T - _, wu[2] = _ - (T - l) + (v - l), wu[3] = T;
      const P = pu(4, _u, 4, wu, bu);
      m = A * s, h = hu * A, d = h - (h - A), p = A - d, h = hu * s, g = h - (h - s), y = s - g, x = p * y - (m - d * g - p * g - d * y), w = E * f, h = hu * E, d = h - (h - E), p = E - d, h = hu * f, g = h - (h - f), y = f - g, M = p * y - (w - d * g - p * g - d * y), v = x - M, l = x - v, wu[0] = x - (v + l) + (l - M), _ = m + v, l = _ - m, b = m - (_ - l) + (v - l), v = b - w, l = b - v, wu[1] = b - (v + l) + (l - w), T = _ + v, l = T - _, wu[2] = _ - (T - l) + (v - l), wu[3] = T;
      const z = pu(P, bu, 4, wu, mu);
      m = u * s, h = hu * u, d = h - (h - u), p = u - d, h = hu * s, g = h - (h - s), y = s - g, x = p * y - (m - d * g - p * g - d * y), w = c * f, h = hu * c, d = h - (h - c), p = c - d, h = hu * f, g = h - (h - f), y = f - g, M = p * y - (w - d * g - p * g - d * y), v = x - M, l = x - v, wu[0] = x - (v + l) + (l - M), _ = m + v, l = _ - m, b = m - (_ - l) + (v - l), v = b - w, l = b - v, wu[1] = b - (v + l) + (l - w), T = _ + v, l = T - _, wu[2] = _ - (T - l) + (v - l), wu[3] = T;
      const $ = pu(z, mu, 4, wu, xu);
      return xu[$ - 1];
    }(t, n, e, r, i, o, f);
  }
  const Tu = Math.pow(2, -52),
    Au = new Uint32Array(512);
  class Su {
    static from(t, n = zu, e = $u) {
      const r = t.length,
        i = new Float64Array(2 * r);
      for (let o = 0; o < r; o++) {
        const r = t[o];
        i[2 * o] = n(r), i[2 * o + 1] = e(r);
      }
      return new Su(i);
    }
    constructor(t) {
      const n = t.length >> 1;
      if (n > 0 && "number" != typeof t[0]) throw new Error("Expected coords to contain numbers.");
      this.coords = t;
      const e = Math.max(2 * n - 5, 0);
      this._triangles = new Uint32Array(3 * e), this._halfedges = new Int32Array(3 * e), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize).fill(-1), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update();
    }
    update() {
      const {
          coords: t,
          _hullPrev: n,
          _hullNext: e,
          _hullTri: r,
          _hullHash: i
        } = this,
        o = t.length >> 1;
      let a = 1 / 0,
        u = 1 / 0,
        c = -1 / 0,
        f = -1 / 0;
      for (let n = 0; n < o; n++) {
        const e = t[2 * n],
          r = t[2 * n + 1];
        e < a && (a = e), r < u && (u = r), e > c && (c = e), r > f && (f = r), this._ids[n] = n;
      }
      const s = (a + c) / 2,
        l = (u + f) / 2;
      let h,
        d,
        p,
        g = 1 / 0;
      for (let n = 0; n < o; n++) {
        const e = Eu(s, l, t[2 * n], t[2 * n + 1]);
        e < g && (h = n, g = e);
      }
      const y = t[2 * h],
        v = t[2 * h + 1];
      g = 1 / 0;
      for (let n = 0; n < o; n++) {
        if (n === h) continue;
        const e = Eu(y, v, t[2 * n], t[2 * n + 1]);
        e < g && e > 0 && (d = n, g = e);
      }
      let _ = t[2 * d],
        b = t[2 * d + 1],
        m = 1 / 0;
      for (let n = 0; n < o; n++) {
        if (n === h || n === d) continue;
        const e = ku(y, v, _, b, t[2 * n], t[2 * n + 1]);
        e < m && (p = n, m = e);
      }
      let x = t[2 * p],
        w = t[2 * p + 1];
      if (m === 1 / 0) {
        for (let n = 0; n < o; n++) this._dists[n] = t[2 * n] - t[0] || t[2 * n + 1] - t[1];
        Cu(this._ids, this._dists, 0, o - 1);
        const n = new Uint32Array(o);
        let e = 0;
        for (let t = 0, r = -1 / 0; t < o; t++) {
          const i = this._ids[t];
          this._dists[i] > r && (n[e++] = i, r = this._dists[i]);
        }
        return this.hull = n.subarray(0, e), this.triangles = new Uint32Array(0), void (this.halfedges = new Uint32Array(0));
      }
      if (Mu(y, v, _, b, x, w) < 0) {
        const t = d,
          n = _,
          e = b;
        d = p, _ = x, b = w, p = t, x = n, w = e;
      }
      const M = function (t, n, e, r, i, o) {
        const a = e - t,
          u = r - n,
          c = i - t,
          f = o - n,
          s = a * a + u * u,
          l = c * c + f * f,
          h = .5 / (a * f - u * c),
          d = t + (f * s - u * l) * h,
          p = n + (a * l - c * s) * h;
        return {
          x: d,
          y: p
        };
      }(y, v, _, b, x, w);
      this._cx = M.x, this._cy = M.y;
      for (let n = 0; n < o; n++) this._dists[n] = Eu(t[2 * n], t[2 * n + 1], M.x, M.y);
      Cu(this._ids, this._dists, 0, o - 1), this._hullStart = h;
      let T = 3;
      e[h] = n[p] = d, e[d] = n[h] = p, e[p] = n[d] = h, r[h] = 0, r[d] = 1, r[p] = 2, i.fill(-1), i[this._hashKey(y, v)] = h, i[this._hashKey(_, b)] = d, i[this._hashKey(x, w)] = p, this.trianglesLen = 0, this._addTriangle(h, d, p, -1, -1, -1);
      for (let o, a, u = 0; u < this._ids.length; u++) {
        const c = this._ids[u],
          f = t[2 * c],
          s = t[2 * c + 1];
        if (u > 0 && Math.abs(f - o) <= Tu && Math.abs(s - a) <= Tu) continue;
        if (o = f, a = s, c === h || c === d || c === p) continue;
        let l = 0;
        for (let t = 0, n = this._hashKey(f, s); t < this._hashSize && (l = i[(n + t) % this._hashSize], -1 === l || l === e[l]); t++);
        l = n[l];
        let g,
          y = l;
        for (; g = e[y], Mu(f, s, t[2 * y], t[2 * y + 1], t[2 * g], t[2 * g + 1]) >= 0;) if (y = g, y === l) {
          y = -1;
          break;
        }
        if (-1 === y) continue;
        let v = this._addTriangle(y, c, e[y], -1, -1, r[y]);
        r[c] = this._legalize(v + 2), r[y] = v, T++;
        let _ = e[y];
        for (; g = e[_], Mu(f, s, t[2 * _], t[2 * _ + 1], t[2 * g], t[2 * g + 1]) < 0;) v = this._addTriangle(_, c, g, r[c], -1, r[_]), r[c] = this._legalize(v + 2), e[_] = _, T--, _ = g;
        if (y === l) for (; g = n[y], Mu(f, s, t[2 * g], t[2 * g + 1], t[2 * y], t[2 * y + 1]) < 0;) v = this._addTriangle(g, c, y, -1, r[y], r[g]), this._legalize(v + 2), r[g] = v, e[y] = y, T--, y = g;
        this._hullStart = n[c] = y, e[y] = n[_] = c, e[c] = _, i[this._hashKey(f, s)] = c, i[this._hashKey(t[2 * y], t[2 * y + 1])] = y;
      }
      this.hull = new Uint32Array(T);
      for (let t = 0, n = this._hullStart; t < T; t++) this.hull[t] = n, n = e[n];
      this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }
    _hashKey(t, n) {
      return Math.floor(function (t, n) {
        const e = t / (Math.abs(t) + Math.abs(n));
        return (n > 0 ? 3 - e : 1 + e) / 4;
      }(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize;
    }
    _legalize(t) {
      const {
        _triangles: n,
        _halfedges: e,
        coords: r
      } = this;
      let i = 0,
        o = 0;
      for (;;) {
        const a = e[t],
          u = t - t % 3;
        if (o = u + (t + 2) % 3, -1 === a) {
          if (0 === i) break;
          t = Au[--i];
          continue;
        }
        const c = a - a % 3,
          f = u + (t + 1) % 3,
          s = c + (a + 2) % 3,
          l = n[o],
          h = n[t],
          d = n[f],
          p = n[s];
        if (Nu(r[2 * l], r[2 * l + 1], r[2 * h], r[2 * h + 1], r[2 * d], r[2 * d + 1], r[2 * p], r[2 * p + 1])) {
          n[t] = p, n[a] = l;
          const r = e[s];
          if (-1 === r) {
            let n = this._hullStart;
            do {
              if (this._hullTri[n] === s) {
                this._hullTri[n] = t;
                break;
              }
              n = this._hullPrev[n];
            } while (n !== this._hullStart);
          }
          this._link(t, r), this._link(a, e[o]), this._link(o, s);
          const u = c + (a + 1) % 3;
          i < Au.length && (Au[i++] = u);
        } else {
          if (0 === i) break;
          t = Au[--i];
        }
      }
      return o;
    }
    _link(t, n) {
      this._halfedges[t] = n, -1 !== n && (this._halfedges[n] = t);
    }
    _addTriangle(t, n, e, r, i, o) {
      const a = this.trianglesLen;
      return this._triangles[a] = t, this._triangles[a + 1] = n, this._triangles[a + 2] = e, this._link(a, r), this._link(a + 1, i), this._link(a + 2, o), this.trianglesLen += 3, a;
    }
  }
  function Eu(t, n, e, r) {
    const i = t - e,
      o = n - r;
    return i * i + o * o;
  }
  function Nu(t, n, e, r, i, o, a, u) {
    const c = t - a,
      f = n - u,
      s = e - a,
      l = r - u,
      h = i - a,
      d = o - u,
      p = s * s + l * l,
      g = h * h + d * d;
    return c * (l * g - p * d) - f * (s * g - p * h) + (c * c + f * f) * (s * d - l * h) < 0;
  }
  function ku(t, n, e, r, i, o) {
    const a = e - t,
      u = r - n,
      c = i - t,
      f = o - n,
      s = a * a + u * u,
      l = c * c + f * f,
      h = .5 / (a * f - u * c),
      d = (f * s - u * l) * h,
      p = (a * l - c * s) * h;
    return d * d + p * p;
  }
  function Cu(t, n, e, r) {
    if (r - e <= 20) for (let i = e + 1; i <= r; i++) {
      const r = t[i],
        o = n[r];
      let a = i - 1;
      for (; a >= e && n[t[a]] > o;) t[a + 1] = t[a--];
      t[a + 1] = r;
    } else {
      let i = e + 1,
        o = r;
      Pu(t, e + r >> 1, i), n[t[e]] > n[t[r]] && Pu(t, e, r), n[t[i]] > n[t[r]] && Pu(t, i, r), n[t[e]] > n[t[i]] && Pu(t, e, i);
      const a = t[i],
        u = n[a];
      for (;;) {
        do {
          i++;
        } while (n[t[i]] < u);
        do {
          o--;
        } while (n[t[o]] > u);
        if (o < i) break;
        Pu(t, i, o);
      }
      t[e + 1] = t[o], t[o] = a, r - i + 1 >= o - e ? (Cu(t, n, i, r), Cu(t, n, e, o - 1)) : (Cu(t, n, e, o - 1), Cu(t, n, i, r));
    }
  }
  function Pu(t, n, e) {
    const r = t[n];
    t[n] = t[e], t[e] = r;
  }
  function zu(t) {
    return t[0];
  }
  function $u(t) {
    return t[1];
  }
  const Du = 1e-6;
  class Ru {
    constructor() {
      this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "";
    }
    moveTo(t, n) {
      this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
    }
    closePath() {
      null !== this._x1 && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
    }
    lineTo(t, n) {
      this._ += `L${this._x1 = +t},${this._y1 = +n}`;
    }
    arc(t, n, e) {
      const r = (t = +t) + (e = +e),
        i = n = +n;
      if (e < 0) throw new Error("negative radius");
      null === this._x1 ? this._ += `M${r},${i}` : (Math.abs(this._x1 - r) > Du || Math.abs(this._y1 - i) > Du) && (this._ += "L" + r + "," + i), e && (this._ += `A${e},${e},0,1,1,${t - e},${n}A${e},${e},0,1,1,${this._x1 = r},${this._y1 = i}`);
    }
    rect(t, n, e, r) {
      this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${+e}v${+r}h${-e}Z`;
    }
    value() {
      return this._ || null;
    }
  }
  class Fu {
    constructor() {
      this._ = [];
    }
    moveTo(t, n) {
      this._.push([t, n]);
    }
    closePath() {
      this._.push(this._[0].slice());
    }
    lineTo(t, n) {
      this._.push([t, n]);
    }
    value() {
      return this._.length ? this._ : null;
    }
  }
  class qu {
    constructor(t, [n, e, r, i] = [0, 0, 960, 500]) {
      if (!((r = +r) >= (n = +n) && (i = +i) >= (e = +e))) throw new Error("invalid bounds");
      this.delaunay = t, this._circumcenters = new Float64Array(2 * t.points.length), this.vectors = new Float64Array(2 * t.points.length), this.xmax = r, this.xmin = n, this.ymax = i, this.ymin = e, this._init();
    }
    update() {
      return this.delaunay.update(), this._init(), this;
    }
    _init() {
      const {
        delaunay: {
          points: t,
          hull: n,
          triangles: e
        },
        vectors: r
      } = this;
      let i, o;
      const a = this.circumcenters = this._circumcenters.subarray(0, e.length / 3 * 2);
      for (let r, u, c = 0, f = 0, s = e.length; c < s; c += 3, f += 2) {
        const s = 2 * e[c],
          l = 2 * e[c + 1],
          h = 2 * e[c + 2],
          d = t[s],
          p = t[s + 1],
          g = t[l],
          y = t[l + 1],
          v = t[h],
          _ = t[h + 1],
          b = g - d,
          m = y - p,
          x = v - d,
          w = _ - p,
          M = 2 * (b * w - m * x);
        if (Math.abs(M) < 1e-9) {
          if (void 0 === i) {
            i = o = 0;
            for (const e of n) i += t[2 * e], o += t[2 * e + 1];
            i /= n.length, o /= n.length;
          }
          const e = 1e9 * Math.sign((i - d) * w - (o - p) * x);
          r = (d + v) / 2 - e * w, u = (p + _) / 2 + e * x;
        } else {
          const t = 1 / M,
            n = b * b + m * m,
            e = x * x + w * w;
          r = d + (w * n - m * e) * t, u = p + (b * e - x * n) * t;
        }
        a[f] = r, a[f + 1] = u;
      }
      let u,
        c,
        f,
        s = n[n.length - 1],
        l = 4 * s,
        h = t[2 * s],
        d = t[2 * s + 1];
      r.fill(0);
      for (let e = 0; e < n.length; ++e) s = n[e], u = l, c = h, f = d, l = 4 * s, h = t[2 * s], d = t[2 * s + 1], r[u + 2] = r[l] = f - d, r[u + 3] = r[l + 1] = h - c;
    }
    render(t) {
      const n = null == t ? t = new Ru() : void 0,
        {
          delaunay: {
            halfedges: e,
            inedges: r,
            hull: i
          },
          circumcenters: o,
          vectors: a
        } = this;
      if (i.length <= 1) return null;
      for (let n = 0, r = e.length; n < r; ++n) {
        const r = e[n];
        if (r < n) continue;
        const i = 2 * Math.floor(n / 3),
          a = 2 * Math.floor(r / 3),
          u = o[i],
          c = o[i + 1],
          f = o[a],
          s = o[a + 1];
        this._renderSegment(u, c, f, s, t);
      }
      let u,
        c = i[i.length - 1];
      for (let n = 0; n < i.length; ++n) {
        u = c, c = i[n];
        const e = 2 * Math.floor(r[c] / 3),
          f = o[e],
          s = o[e + 1],
          l = 4 * u,
          h = this._project(f, s, a[l + 2], a[l + 3]);
        h && this._renderSegment(f, s, h[0], h[1], t);
      }
      return n && n.value();
    }
    renderBounds(t) {
      const n = null == t ? t = new Ru() : void 0;
      return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value();
    }
    renderCell(t, n) {
      const e = null == n ? n = new Ru() : void 0,
        r = this._clip(t);
      if (null === r || !r.length) return;
      n.moveTo(r[0], r[1]);
      let i = r.length;
      for (; r[0] === r[i - 2] && r[1] === r[i - 1] && i > 1;) i -= 2;
      for (let t = 2; t < i; t += 2) r[t] === r[t - 2] && r[t + 1] === r[t - 1] || n.lineTo(r[t], r[t + 1]);
      return n.closePath(), e && e.value();
    }
    *cellPolygons() {
      const {
        delaunay: {
          points: t
        }
      } = this;
      for (let n = 0, e = t.length / 2; n < e; ++n) {
        const t = this.cellPolygon(n);
        t && (t.index = n, yield t);
      }
    }
    cellPolygon(t) {
      const n = new Fu();
      return this.renderCell(t, n), n.value();
    }
    _renderSegment(t, n, e, r, i) {
      let o;
      const a = this._regioncode(t, n),
        u = this._regioncode(e, r);
      0 === a && 0 === u ? (i.moveTo(t, n), i.lineTo(e, r)) : (o = this._clipSegment(t, n, e, r, a, u)) && (i.moveTo(o[0], o[1]), i.lineTo(o[2], o[3]));
    }
    contains(t, n, e) {
      return (n = +n) == n && (e = +e) == e && this.delaunay._step(t, n, e) === t;
    }
    *neighbors(t) {
      const n = this._clip(t);
      if (n) for (const e of this.delaunay.neighbors(t)) {
        const t = this._clip(e);
        if (t) t: for (let r = 0, i = n.length; r < i; r += 2) for (let o = 0, a = t.length; o < a; o += 2) if (n[r] === t[o] && n[r + 1] === t[o + 1] && n[(r + 2) % i] === t[(o + a - 2) % a] && n[(r + 3) % i] === t[(o + a - 1) % a]) {
          yield e;
          break t;
        }
      }
    }
    _cell(t) {
      const {
          circumcenters: n,
          delaunay: {
            inedges: e,
            halfedges: r,
            triangles: i
          }
        } = this,
        o = e[t];
      if (-1 === o) return null;
      const a = [];
      let u = o;
      do {
        const e = Math.floor(u / 3);
        if (a.push(n[2 * e], n[2 * e + 1]), u = u % 3 == 2 ? u - 2 : u + 1, i[u] !== t) break;
        u = r[u];
      } while (u !== o && -1 !== u);
      return a;
    }
    _clip(t) {
      if (0 === t && 1 === this.delaunay.hull.length) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
      const n = this._cell(t);
      if (null === n) return null;
      const {
          vectors: e
        } = this,
        r = 4 * t;
      return this._simplify(e[r] || e[r + 1] ? this._clipInfinite(t, n, e[r], e[r + 1], e[r + 2], e[r + 3]) : this._clipFinite(t, n));
    }
    _clipFinite(t, n) {
      const e = n.length;
      let r,
        i,
        o,
        a,
        u = null,
        c = n[e - 2],
        f = n[e - 1],
        s = this._regioncode(c, f),
        l = 0;
      for (let h = 0; h < e; h += 2) if (r = c, i = f, c = n[h], f = n[h + 1], o = s, s = this._regioncode(c, f), 0 === o && 0 === s) a = l, l = 0, u ? u.push(c, f) : u = [c, f];else {
        let n, e, h, d, p;
        if (0 === o) {
          if (null === (n = this._clipSegment(r, i, c, f, o, s))) continue;
          [e, h, d, p] = n;
        } else {
          if (null === (n = this._clipSegment(c, f, r, i, s, o))) continue;
          [d, p, e, h] = n, a = l, l = this._edgecode(e, h), a && l && this._edge(t, a, l, u, u.length), u ? u.push(e, h) : u = [e, h];
        }
        a = l, l = this._edgecode(d, p), a && l && this._edge(t, a, l, u, u.length), u ? u.push(d, p) : u = [d, p];
      }
      if (u) a = l, l = this._edgecode(u[0], u[1]), a && l && this._edge(t, a, l, u, u.length);else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
      return u;
    }
    _clipSegment(t, n, e, r, i, o) {
      const a = i < o;
      for (a && ([t, n, e, r, i, o] = [e, r, t, n, o, i]);;) {
        if (0 === i && 0 === o) return a ? [e, r, t, n] : [t, n, e, r];
        if (i & o) return null;
        let u,
          c,
          f = i || o;
        8 & f ? (u = t + (e - t) * (this.ymax - n) / (r - n), c = this.ymax) : 4 & f ? (u = t + (e - t) * (this.ymin - n) / (r - n), c = this.ymin) : 2 & f ? (c = n + (r - n) * (this.xmax - t) / (e - t), u = this.xmax) : (c = n + (r - n) * (this.xmin - t) / (e - t), u = this.xmin), i ? (t = u, n = c, i = this._regioncode(t, n)) : (e = u, r = c, o = this._regioncode(e, r));
      }
    }
    _clipInfinite(t, n, e, r, i, o) {
      let a,
        u = Array.from(n);
      if ((a = this._project(u[0], u[1], e, r)) && u.unshift(a[0], a[1]), (a = this._project(u[u.length - 2], u[u.length - 1], i, o)) && u.push(a[0], a[1]), u = this._clipFinite(t, u)) for (let n, e = 0, r = u.length, i = this._edgecode(u[r - 2], u[r - 1]); e < r; e += 2) n = i, i = this._edgecode(u[e], u[e + 1]), n && i && (e = this._edge(t, n, i, u, e), r = u.length);else this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (u = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
      return u;
    }
    _edge(t, n, e, r, i) {
      for (; n !== e;) {
        let e, o;
        switch (n) {
          case 5:
            n = 4;
            continue;
          case 4:
            n = 6, e = this.xmax, o = this.ymin;
            break;
          case 6:
            n = 2;
            continue;
          case 2:
            n = 10, e = this.xmax, o = this.ymax;
            break;
          case 10:
            n = 8;
            continue;
          case 8:
            n = 9, e = this.xmin, o = this.ymax;
            break;
          case 9:
            n = 1;
            continue;
          case 1:
            n = 5, e = this.xmin, o = this.ymin;
        }
        r[i] === e && r[i + 1] === o || !this.contains(t, e, o) || (r.splice(i, 0, e, o), i += 2);
      }
      return i;
    }
    _project(t, n, e, r) {
      let i,
        o,
        a,
        u = 1 / 0;
      if (r < 0) {
        if (n <= this.ymin) return null;
        (i = (this.ymin - n) / r) < u && (a = this.ymin, o = t + (u = i) * e);
      } else if (r > 0) {
        if (n >= this.ymax) return null;
        (i = (this.ymax - n) / r) < u && (a = this.ymax, o = t + (u = i) * e);
      }
      if (e > 0) {
        if (t >= this.xmax) return null;
        (i = (this.xmax - t) / e) < u && (o = this.xmax, a = n + (u = i) * r);
      } else if (e < 0) {
        if (t <= this.xmin) return null;
        (i = (this.xmin - t) / e) < u && (o = this.xmin, a = n + (u = i) * r);
      }
      return [o, a];
    }
    _edgecode(t, n) {
      return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0);
    }
    _regioncode(t, n) {
      return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0);
    }
    _simplify(t) {
      if (t && t.length > 4) {
        for (let n = 0; n < t.length; n += 2) {
          const e = (n + 2) % t.length,
            r = (n + 4) % t.length;
          (t[n] === t[e] && t[e] === t[r] || t[n + 1] === t[e + 1] && t[e + 1] === t[r + 1]) && (t.splice(e, 2), n -= 2);
        }
        t.length || (t = null);
      }
      return t;
    }
  }
  const Uu = 2 * Math.PI,
    Iu = Math.pow;
  function Ou(t) {
    return t[0];
  }
  function Bu(t) {
    return t[1];
  }
  function Yu(t, n, e) {
    return [t + Math.sin(t + n) * e, n + Math.cos(t - n) * e];
  }
  class Lu {
    static from(t, n = Ou, e = Bu, r) {
      return new Lu("length" in t ? function (t, n, e, r) {
        const i = t.length,
          o = new Float64Array(2 * i);
        for (let a = 0; a < i; ++a) {
          const i = t[a];
          o[2 * a] = n.call(r, i, a, t), o[2 * a + 1] = e.call(r, i, a, t);
        }
        return o;
      }(t, n, e, r) : Float64Array.from(function* (t, n, e, r) {
        let i = 0;
        for (const o of t) yield n.call(r, o, i, t), yield e.call(r, o, i, t), ++i;
      }(t, n, e, r)));
    }
    constructor(t) {
      this._delaunator = new Su(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init();
    }
    update() {
      return this._delaunator.update(), this._init(), this;
    }
    _init() {
      const t = this._delaunator,
        n = this.points;
      if (t.hull && t.hull.length > 2 && function (t) {
        const {
          triangles: n,
          coords: e
        } = t;
        for (let t = 0; t < n.length; t += 3) {
          const r = 2 * n[t],
            i = 2 * n[t + 1],
            o = 2 * n[t + 2];
          if ((e[o] - e[r]) * (e[i + 1] - e[r + 1]) - (e[i] - e[r]) * (e[o + 1] - e[r + 1]) > 1e-10) return !1;
        }
        return !0;
      }(t)) {
        this.collinear = Int32Array.from({
          length: n.length / 2
        }, (t, n) => n).sort((t, e) => n[2 * t] - n[2 * e] || n[2 * t + 1] - n[2 * e + 1]);
        const t = this.collinear[0],
          e = this.collinear[this.collinear.length - 1],
          r = [n[2 * t], n[2 * t + 1], n[2 * e], n[2 * e + 1]],
          i = 1e-8 * Math.hypot(r[3] - r[1], r[2] - r[0]);
        for (let t = 0, e = n.length / 2; t < e; ++t) {
          const e = Yu(n[2 * t], n[2 * t + 1], i);
          n[2 * t] = e[0], n[2 * t + 1] = e[1];
        }
        this._delaunator = new Su(n);
      } else delete this.collinear;
      const e = this.halfedges = this._delaunator.halfedges,
        r = this.hull = this._delaunator.hull,
        i = this.triangles = this._delaunator.triangles,
        o = this.inedges.fill(-1),
        a = this._hullIndex.fill(-1);
      for (let t = 0, n = e.length; t < n; ++t) {
        const n = i[t % 3 == 2 ? t - 2 : t + 1];
        -1 !== e[t] && -1 !== o[n] || (o[n] = t);
      }
      for (let t = 0, n = r.length; t < n; ++t) a[r[t]] = t;
      r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], o[r[0]] = 1, 2 === r.length && (o[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1]));
    }
    voronoi(t) {
      return new qu(this, t);
    }
    *neighbors(t) {
      const {
        inedges: n,
        hull: e,
        _hullIndex: r,
        halfedges: i,
        triangles: o,
        collinear: a
      } = this;
      if (a) {
        const n = a.indexOf(t);
        return n > 0 && (yield a[n - 1]), void (n < a.length - 1 && (yield a[n + 1]));
      }
      const u = n[t];
      if (-1 === u) return;
      let c = u,
        f = -1;
      do {
        if (yield f = o[c], c = c % 3 == 2 ? c - 2 : c + 1, o[c] !== t) return;
        if (c = i[c], -1 === c) {
          const n = e[(r[t] + 1) % e.length];
          return void (n !== f && (yield n));
        }
      } while (c !== u);
    }
    find(t, n, e = 0) {
      if ((t = +t) != t || (n = +n) != n) return -1;
      const r = e;
      let i;
      for (; (i = this._step(e, t, n)) >= 0 && i !== e && i !== r;) e = i;
      return i;
    }
    _step(t, n, e) {
      const {
        inedges: r,
        hull: i,
        _hullIndex: o,
        halfedges: a,
        triangles: u,
        points: c
      } = this;
      if (-1 === r[t] || !c.length) return (t + 1) % (c.length >> 1);
      let f = t,
        s = Iu(n - c[2 * t], 2) + Iu(e - c[2 * t + 1], 2);
      const l = r[t];
      let h = l;
      do {
        let r = u[h];
        const l = Iu(n - c[2 * r], 2) + Iu(e - c[2 * r + 1], 2);
        if (l < s && (s = l, f = r), h = h % 3 == 2 ? h - 2 : h + 1, u[h] !== t) break;
        if (h = a[h], -1 === h) {
          if (h = i[(o[t] + 1) % i.length], h !== r && Iu(n - c[2 * h], 2) + Iu(e - c[2 * h + 1], 2) < s) return h;
          break;
        }
      } while (h !== l);
      return f;
    }
    render(t) {
      const n = null == t ? t = new Ru() : void 0,
        {
          points: e,
          halfedges: r,
          triangles: i
        } = this;
      for (let n = 0, o = r.length; n < o; ++n) {
        const o = r[n];
        if (o < n) continue;
        const a = 2 * i[n],
          u = 2 * i[o];
        t.moveTo(e[a], e[a + 1]), t.lineTo(e[u], e[u + 1]);
      }
      return this.renderHull(t), n && n.value();
    }
    renderPoints(t, n) {
      void 0 !== n || t && "function" == typeof t.moveTo || (n = t, t = null), n = null == n ? 2 : +n;
      const e = null == t ? t = new Ru() : void 0,
        {
          points: r
        } = this;
      for (let e = 0, i = r.length; e < i; e += 2) {
        const i = r[e],
          o = r[e + 1];
        t.moveTo(i + n, o), t.arc(i, o, n, 0, Uu);
      }
      return e && e.value();
    }
    renderHull(t) {
      const n = null == t ? t = new Ru() : void 0,
        {
          hull: e,
          points: r
        } = this,
        i = 2 * e[0],
        o = e.length;
      t.moveTo(r[i], r[i + 1]);
      for (let n = 1; n < o; ++n) {
        const i = 2 * e[n];
        t.lineTo(r[i], r[i + 1]);
      }
      return t.closePath(), n && n.value();
    }
    hullPolygon() {
      const t = new Fu();
      return this.renderHull(t), t.value();
    }
    renderTriangle(t, n) {
      const e = null == n ? n = new Ru() : void 0,
        {
          points: r,
          triangles: i
        } = this,
        o = 2 * i[t *= 3],
        a = 2 * i[t + 1],
        u = 2 * i[t + 2];
      return n.moveTo(r[o], r[o + 1]), n.lineTo(r[a], r[a + 1]), n.lineTo(r[u], r[u + 1]), n.closePath(), e && e.value();
    }
    *trianglePolygons() {
      const {
        triangles: t
      } = this;
      for (let n = 0, e = t.length / 3; n < e; ++n) yield this.trianglePolygon(n);
    }
    trianglePolygon(t) {
      const n = new Fu();
      return this.renderTriangle(t, n), n.value();
    }
  }
  var ju = {},
    Hu = {},
    Xu = 34,
    Gu = 10,
    Vu = 13;
  function Wu(t) {
    return new Function("d", "return {" + t.map(function (t, n) {
      return JSON.stringify(t) + ": d[" + n + '] || ""';
    }).join(",") + "}");
  }
  function Zu(t) {
    var n = Object.create(null),
      e = [];
    return t.forEach(function (t) {
      for (var r in t) r in n || e.push(n[r] = r);
    }), e;
  }
  function Ku(t, n) {
    var e = t + "",
      r = e.length;
    return r < n ? new Array(n - r + 1).join(0) + e : e;
  }
  function Qu(t) {
    var n,
      e = t.getUTCHours(),
      r = t.getUTCMinutes(),
      i = t.getUTCSeconds(),
      o = t.getUTCMilliseconds();
    return isNaN(t) ? "Invalid Date" : ((n = t.getUTCFullYear()) < 0 ? "-" + Ku(-n, 6) : n > 9999 ? "+" + Ku(n, 6) : Ku(n, 4)) + "-" + Ku(t.getUTCMonth() + 1, 2) + "-" + Ku(t.getUTCDate(), 2) + (o ? "T" + Ku(e, 2) + ":" + Ku(r, 2) + ":" + Ku(i, 2) + "." + Ku(o, 3) + "Z" : i ? "T" + Ku(e, 2) + ":" + Ku(r, 2) + ":" + Ku(i, 2) + "Z" : r || e ? "T" + Ku(e, 2) + ":" + Ku(r, 2) + "Z" : "");
  }
  function Ju(t) {
    var n = new RegExp('["' + t + "\n\r]"),
      e = t.charCodeAt(0);
    function r(t, n) {
      var r,
        i = [],
        o = t.length,
        a = 0,
        u = 0,
        c = o <= 0,
        f = !1;
      function s() {
        if (c) return Hu;
        if (f) return f = !1, ju;
        var n,
          r,
          i = a;
        if (t.charCodeAt(i) === Xu) {
          for (; a++ < o && t.charCodeAt(a) !== Xu || t.charCodeAt(++a) === Xu;);
          return (n = a) >= o ? c = !0 : (r = t.charCodeAt(a++)) === Gu ? f = !0 : r === Vu && (f = !0, t.charCodeAt(a) === Gu && ++a), t.slice(i + 1, n - 1).replace(/""/g, '"');
        }
        for (; a < o;) {
          if ((r = t.charCodeAt(n = a++)) === Gu) f = !0;else if (r === Vu) f = !0, t.charCodeAt(a) === Gu && ++a;else if (r !== e) continue;
          return t.slice(i, n);
        }
        return c = !0, t.slice(i, o);
      }
      for (t.charCodeAt(o - 1) === Gu && --o, t.charCodeAt(o - 1) === Vu && --o; (r = s()) !== Hu;) {
        for (var l = []; r !== ju && r !== Hu;) l.push(r), r = s();
        n && null == (l = n(l, u++)) || i.push(l);
      }
      return i;
    }
    function i(n, e) {
      return n.map(function (n) {
        return e.map(function (t) {
          return a(n[t]);
        }).join(t);
      });
    }
    function o(n) {
      return n.map(a).join(t);
    }
    function a(t) {
      return null == t ? "" : t instanceof Date ? Qu(t) : n.test(t += "") ? '"' + t.replace(/"/g, '""') + '"' : t;
    }
    return {
      parse: function (t, n) {
        var e,
          i,
          o = r(t, function (t, r) {
            if (e) return e(t, r - 1);
            i = t, e = n ? function (t, n) {
              var e = Wu(t);
              return function (r, i) {
                return n(e(r), i, t);
              };
            }(t, n) : Wu(t);
          });
        return o.columns = i || [], o;
      },
      parseRows: r,
      format: function (n, e) {
        return null == e && (e = Zu(n)), [e.map(a).join(t)].concat(i(n, e)).join("\n");
      },
      formatBody: function (t, n) {
        return null == n && (n = Zu(t)), i(t, n).join("\n");
      },
      formatRows: function (t) {
        return t.map(o).join("\n");
      },
      formatRow: o,
      formatValue: a
    };
  }
  var tc = Ju(","),
    nc = tc.parse,
    ec = tc.parseRows,
    rc = tc.format,
    ic = tc.formatBody,
    oc = tc.formatRows,
    ac = tc.formatRow,
    uc = tc.formatValue,
    cc = Ju("\t"),
    fc = cc.parse,
    sc = cc.parseRows,
    lc = cc.format,
    hc = cc.formatBody,
    dc = cc.formatRows,
    pc = cc.formatRow,
    gc = cc.formatValue;
  const yc = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();
  function vc(t) {
    if (!t.ok) throw new Error(t.status + " " + t.statusText);
    return t.blob();
  }
  function _c(t) {
    if (!t.ok) throw new Error(t.status + " " + t.statusText);
    return t.arrayBuffer();
  }
  function bc(t) {
    if (!t.ok) throw new Error(t.status + " " + t.statusText);
    return t.text();
  }
  function mc(t, n) {
    return fetch(t, n).then(bc);
  }
  function xc(t) {
    return function (n, e, r) {
      return 2 === arguments.length && "function" == typeof e && (r = e, e = void 0), mc(n, e).then(function (n) {
        return t(n, r);
      });
    };
  }
  var wc = xc(nc),
    Mc = xc(fc);
  function Tc(t) {
    if (!t.ok) throw new Error(t.status + " " + t.statusText);
    if (204 !== t.status && 205 !== t.status) return t.json();
  }
  function Ac(t) {
    return (n, e) => mc(n, e).then(n => new DOMParser().parseFromString(n, t));
  }
  var Sc = Ac("application/xml"),
    Ec = Ac("text/html"),
    Nc = Ac("image/svg+xml");
  function kc(t, n, e, r) {
    if (isNaN(n) || isNaN(e)) return t;
    var i,
      o,
      a,
      u,
      c,
      f,
      s,
      l,
      h,
      d = t._root,
      p = {
        data: r
      },
      g = t._x0,
      y = t._y0,
      v = t._x1,
      _ = t._y1;
    if (!d) return t._root = p, t;
    for (; d.length;) if ((f = n >= (o = (g + v) / 2)) ? g = o : v = o, (s = e >= (a = (y + _) / 2)) ? y = a : _ = a, i = d, !(d = d[l = s << 1 | f])) return i[l] = p, t;
    if (u = +t._x.call(null, d.data), c = +t._y.call(null, d.data), n === u && e === c) return p.next = d, i ? i[l] = p : t._root = p, t;
    do {
      i = i ? i[l] = new Array(4) : t._root = new Array(4), (f = n >= (o = (g + v) / 2)) ? g = o : v = o, (s = e >= (a = (y + _) / 2)) ? y = a : _ = a;
    } while ((l = s << 1 | f) == (h = (c >= a) << 1 | u >= o));
    return i[h] = d, i[l] = p, t;
  }
  function Cc(t, n, e, r, i) {
    this.node = t, this.x0 = n, this.y0 = e, this.x1 = r, this.y1 = i;
  }
  function Pc(t) {
    return t[0];
  }
  function zc(t) {
    return t[1];
  }
  function $c(t, n, e) {
    var r = new Dc(null == n ? Pc : n, null == e ? zc : e, NaN, NaN, NaN, NaN);
    return null == t ? r : r.addAll(t);
  }
  function Dc(t, n, e, r, i, o) {
    this._x = t, this._y = n, this._x0 = e, this._y0 = r, this._x1 = i, this._y1 = o, this._root = void 0;
  }
  function Rc(t) {
    for (var n = {
        data: t.data
      }, e = n; t = t.next;) e = e.next = {
      data: t.data
    };
    return n;
  }
  var Fc = $c.prototype = Dc.prototype;
  function qc(t) {
    return function () {
      return t;
    };
  }
  function Uc(t) {
    return 1e-6 * (t() - .5);
  }
  function Ic(t) {
    return t.x + t.vx;
  }
  function Oc(t) {
    return t.y + t.vy;
  }
  function Bc(t) {
    return t.index;
  }
  function Yc(t, n) {
    var e = t.get(n);
    if (!e) throw new Error("node not found: " + n);
    return e;
  }
  Fc.copy = function () {
    var t,
      n,
      e = new Dc(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      r = this._root;
    if (!r) return e;
    if (!r.length) return e._root = Rc(r), e;
    for (t = [{
      source: r,
      target: e._root = new Array(4)
    }]; r = t.pop();) for (var i = 0; i < 4; ++i) (n = r.source[i]) && (n.length ? t.push({
      source: n,
      target: r.target[i] = new Array(4)
    }) : r.target[i] = Rc(n));
    return e;
  }, Fc.add = function (t) {
    const n = +this._x.call(null, t),
      e = +this._y.call(null, t);
    return kc(this.cover(n, e), n, e, t);
  }, Fc.addAll = function (t) {
    var n,
      e,
      r,
      i,
      o = t.length,
      a = new Array(o),
      u = new Array(o),
      c = 1 / 0,
      f = 1 / 0,
      s = -1 / 0,
      l = -1 / 0;
    for (e = 0; e < o; ++e) isNaN(r = +this._x.call(null, n = t[e])) || isNaN(i = +this._y.call(null, n)) || (a[e] = r, u[e] = i, r < c && (c = r), r > s && (s = r), i < f && (f = i), i > l && (l = i));
    if (c > s || f > l) return this;
    for (this.cover(c, f).cover(s, l), e = 0; e < o; ++e) kc(this, a[e], u[e], t[e]);
    return this;
  }, Fc.cover = function (t, n) {
    if (isNaN(t = +t) || isNaN(n = +n)) return this;
    var e = this._x0,
      r = this._y0,
      i = this._x1,
      o = this._y1;
    if (isNaN(e)) i = (e = Math.floor(t)) + 1, o = (r = Math.floor(n)) + 1;else {
      for (var a, u, c = i - e || 1, f = this._root; e > t || t >= i || r > n || n >= o;) switch (u = (n < r) << 1 | t < e, (a = new Array(4))[u] = f, f = a, c *= 2, u) {
        case 0:
          i = e + c, o = r + c;
          break;
        case 1:
          e = i - c, o = r + c;
          break;
        case 2:
          i = e + c, r = o - c;
          break;
        case 3:
          e = i - c, r = o - c;
      }
      this._root && this._root.length && (this._root = f);
    }
    return this._x0 = e, this._y0 = r, this._x1 = i, this._y1 = o, this;
  }, Fc.data = function () {
    var t = [];
    return this.visit(function (n) {
      if (!n.length) do {
        t.push(n.data);
      } while (n = n.next);
    }), t;
  }, Fc.extent = function (t) {
    return arguments.length ? this.cover(+t[0][0], +t[0][1]).cover(+t[1][0], +t[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
  }, Fc.find = function (t, n, e) {
    var r,
      i,
      o,
      a,
      u,
      c,
      f,
      s = this._x0,
      l = this._y0,
      h = this._x1,
      d = this._y1,
      p = [],
      g = this._root;
    for (g && p.push(new Cc(g, s, l, h, d)), null == e ? e = 1 / 0 : (s = t - e, l = n - e, h = t + e, d = n + e, e *= e); c = p.pop();) if (!(!(g = c.node) || (i = c.x0) > h || (o = c.y0) > d || (a = c.x1) < s || (u = c.y1) < l)) if (g.length) {
      var y = (i + a) / 2,
        v = (o + u) / 2;
      p.push(new Cc(g[3], y, v, a, u), new Cc(g[2], i, v, y, u), new Cc(g[1], y, o, a, v), new Cc(g[0], i, o, y, v)), (f = (n >= v) << 1 | t >= y) && (c = p[p.length - 1], p[p.length - 1] = p[p.length - 1 - f], p[p.length - 1 - f] = c);
    } else {
      var _ = t - +this._x.call(null, g.data),
        b = n - +this._y.call(null, g.data),
        m = _ * _ + b * b;
      if (m < e) {
        var x = Math.sqrt(e = m);
        s = t - x, l = n - x, h = t + x, d = n + x, r = g.data;
      }
    }
    return r;
  }, Fc.remove = function (t) {
    if (isNaN(o = +this._x.call(null, t)) || isNaN(a = +this._y.call(null, t))) return this;
    var n,
      e,
      r,
      i,
      o,
      a,
      u,
      c,
      f,
      s,
      l,
      h,
      d = this._root,
      p = this._x0,
      g = this._y0,
      y = this._x1,
      v = this._y1;
    if (!d) return this;
    if (d.length) for (;;) {
      if ((f = o >= (u = (p + y) / 2)) ? p = u : y = u, (s = a >= (c = (g + v) / 2)) ? g = c : v = c, n = d, !(d = d[l = s << 1 | f])) return this;
      if (!d.length) break;
      (n[l + 1 & 3] || n[l + 2 & 3] || n[l + 3 & 3]) && (e = n, h = l);
    }
    for (; d.data !== t;) if (r = d, !(d = d.next)) return this;
    return (i = d.next) && delete d.next, r ? (i ? r.next = i : delete r.next, this) : n ? (i ? n[l] = i : delete n[l], (d = n[0] || n[1] || n[2] || n[3]) && d === (n[3] || n[2] || n[1] || n[0]) && !d.length && (e ? e[h] = d : this._root = d), this) : (this._root = i, this);
  }, Fc.removeAll = function (t) {
    for (var n = 0, e = t.length; n < e; ++n) this.remove(t[n]);
    return this;
  }, Fc.root = function () {
    return this._root;
  }, Fc.size = function () {
    var t = 0;
    return this.visit(function (n) {
      if (!n.length) do {
        ++t;
      } while (n = n.next);
    }), t;
  }, Fc.visit = function (t) {
    var n,
      e,
      r,
      i,
      o,
      a,
      u = [],
      c = this._root;
    for (c && u.push(new Cc(c, this._x0, this._y0, this._x1, this._y1)); n = u.pop();) if (!t(c = n.node, r = n.x0, i = n.y0, o = n.x1, a = n.y1) && c.length) {
      var f = (r + o) / 2,
        s = (i + a) / 2;
      (e = c[3]) && u.push(new Cc(e, f, s, o, a)), (e = c[2]) && u.push(new Cc(e, r, s, f, a)), (e = c[1]) && u.push(new Cc(e, f, i, o, s)), (e = c[0]) && u.push(new Cc(e, r, i, f, s));
    }
    return this;
  }, Fc.visitAfter = function (t) {
    var n,
      e = [],
      r = [];
    for (this._root && e.push(new Cc(this._root, this._x0, this._y0, this._x1, this._y1)); n = e.pop();) {
      var i = n.node;
      if (i.length) {
        var o,
          a = n.x0,
          u = n.y0,
          c = n.x1,
          f = n.y1,
          s = (a + c) / 2,
          l = (u + f) / 2;
        (o = i[0]) && e.push(new Cc(o, a, u, s, l)), (o = i[1]) && e.push(new Cc(o, s, u, c, l)), (o = i[2]) && e.push(new Cc(o, a, l, s, f)), (o = i[3]) && e.push(new Cc(o, s, l, c, f));
      }
      r.push(n);
    }
    for (; n = r.pop();) t(n.node, n.x0, n.y0, n.x1, n.y1);
    return this;
  }, Fc.x = function (t) {
    return arguments.length ? (this._x = t, this) : this._x;
  }, Fc.y = function (t) {
    return arguments.length ? (this._y = t, this) : this._y;
  };
  const Lc = 1664525,
    jc = 1013904223,
    Hc = 4294967296;
  function Xc(t) {
    return t.x;
  }
  function Gc(t) {
    return t.y;
  }
  var Vc = Math.PI * (3 - Math.sqrt(5));
  function Wc(t, n) {
    if ((e = (t = n ? t.toExponential(n - 1) : t.toExponential()).indexOf("e")) < 0) return null;
    var e,
      r = t.slice(0, e);
    return [r.length > 1 ? r[0] + r.slice(2) : r, +t.slice(e + 1)];
  }
  function Zc(t) {
    return (t = Wc(Math.abs(t))) ? t[1] : NaN;
  }
  var Kc,
    Qc = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function Jc(t) {
    if (!(n = Qc.exec(t))) throw new Error("invalid format: " + t);
    var n;
    return new tf({
      fill: n[1],
      align: n[2],
      sign: n[3],
      symbol: n[4],
      zero: n[5],
      width: n[6],
      comma: n[7],
      precision: n[8] && n[8].slice(1),
      trim: n[9],
      type: n[10]
    });
  }
  function tf(t) {
    this.fill = void 0 === t.fill ? " " : t.fill + "", this.align = void 0 === t.align ? ">" : t.align + "", this.sign = void 0 === t.sign ? "-" : t.sign + "", this.symbol = void 0 === t.symbol ? "" : t.symbol + "", this.zero = !!t.zero, this.width = void 0 === t.width ? void 0 : +t.width, this.comma = !!t.comma, this.precision = void 0 === t.precision ? void 0 : +t.precision, this.trim = !!t.trim, this.type = void 0 === t.type ? "" : t.type + "";
  }
  function nf(t, n) {
    var e = Wc(t, n);
    if (!e) return t + "";
    var r = e[0],
      i = e[1];
    return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0");
  }
  Jc.prototype = tf.prototype, tf.prototype.toString = function () {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (void 0 === this.width ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (void 0 === this.precision ? "" : "." + Math.max(0, 0 | this.precision)) + (this.trim ? "~" : "") + this.type;
  };
  var ef = {
    "%": (t, n) => (100 * t).toFixed(n),
    b: t => Math.round(t).toString(2),
    c: t => t + "",
    d: function (t) {
      return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10);
    },
    e: (t, n) => t.toExponential(n),
    f: (t, n) => t.toFixed(n),
    g: (t, n) => t.toPrecision(n),
    o: t => Math.round(t).toString(8),
    p: (t, n) => nf(100 * t, n),
    r: nf,
    s: function (t, n) {
      var e = Wc(t, n);
      if (!e) return t + "";
      var r = e[0],
        i = e[1],
        o = i - (Kc = 3 * Math.max(-8, Math.min(8, Math.floor(i / 3)))) + 1,
        a = r.length;
      return o === a ? r : o > a ? r + new Array(o - a + 1).join("0") : o > 0 ? r.slice(0, o) + "." + r.slice(o) : "0." + new Array(1 - o).join("0") + Wc(t, Math.max(0, n + o - 1))[0];
    },
    X: t => Math.round(t).toString(16).toUpperCase(),
    x: t => Math.round(t).toString(16)
  };
  function rf(t) {
    return t;
  }
  var of,
    af = Array.prototype.map,
    uf = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function cf(t) {
    var n,
      e,
      r = void 0 === t.grouping || void 0 === t.thousands ? rf : (n = af.call(t.grouping, Number), e = t.thousands + "", function (t, r) {
        for (var i = t.length, o = [], a = 0, u = n[0], c = 0; i > 0 && u > 0 && (c + u + 1 > r && (u = Math.max(1, r - c)), o.push(t.substring(i -= u, i + u)), !((c += u + 1) > r));) u = n[a = (a + 1) % n.length];
        return o.reverse().join(e);
      }),
      i = void 0 === t.currency ? "" : t.currency[0] + "",
      o = void 0 === t.currency ? "" : t.currency[1] + "",
      a = void 0 === t.decimal ? "." : t.decimal + "",
      u = void 0 === t.numerals ? rf : function (t) {
        return function (n) {
          return n.replace(/[0-9]/g, function (n) {
            return t[+n];
          });
        };
      }(af.call(t.numerals, String)),
      c = void 0 === t.percent ? "%" : t.percent + "",
      f = void 0 === t.minus ? "" : t.minus + "",
      s = void 0 === t.nan ? "NaN" : t.nan + "";
    function l(t) {
      var n = (t = Jc(t)).fill,
        e = t.align,
        l = t.sign,
        h = t.symbol,
        d = t.zero,
        p = t.width,
        g = t.comma,
        y = t.precision,
        v = t.trim,
        _ = t.type;
      "n" === _ ? (g = !0, _ = "g") : ef[_] || (void 0 === y && (y = 12), v = !0, _ = "g"), (d || "0" === n && "=" === e) && (d = !0, n = "0", e = "=");
      var b = "$" === h ? i : "#" === h && /[boxX]/.test(_) ? "0" + _.toLowerCase() : "",
        m = "$" === h ? o : /[%p]/.test(_) ? c : "",
        x = ef[_],
        w = /[defgprs%]/.test(_);
      function M(t) {
        var i,
          o,
          c,
          h = b,
          M = m;
        if ("c" === _) M = x(t) + M, t = "";else {
          var T = (t = +t) < 0 || 1 / t < 0;
          if (t = isNaN(t) ? s : x(Math.abs(t), y), v && (t = function (t) {
            t: for (var n, e = t.length, r = 1, i = -1; r < e; ++r) switch (t[r]) {
              case ".":
                i = n = r;
                break;
              case "0":
                0 === i && (i = r), n = r;
                break;
              default:
                if (!+t[r]) break t;
                i > 0 && (i = 0);
            }
            return i > 0 ? t.slice(0, i) + t.slice(n + 1) : t;
          }(t)), T && 0 == +t && "+" !== l && (T = !1), h = (T ? "(" === l ? l : f : "-" === l || "(" === l ? "" : l) + h, M = ("s" === _ ? uf[8 + Kc / 3] : "") + M + (T && "(" === l ? ")" : ""), w) for (i = -1, o = t.length; ++i < o;) if (48 > (c = t.charCodeAt(i)) || c > 57) {
            M = (46 === c ? a + t.slice(i + 1) : t.slice(i)) + M, t = t.slice(0, i);
            break;
          }
        }
        g && !d && (t = r(t, 1 / 0));
        var A = h.length + t.length + M.length,
          S = A < p ? new Array(p - A + 1).join(n) : "";
        switch (g && d && (t = r(S + t, S.length ? p - M.length : 1 / 0), S = ""), e) {
          case "<":
            t = h + t + M + S;
            break;
          case "=":
            t = h + S + t + M;
            break;
          case "^":
            t = S.slice(0, A = S.length >> 1) + h + t + M + S.slice(A);
            break;
          default:
            t = S + h + t + M;
        }
        return u(t);
      }
      return y = void 0 === y ? 6 : /[gprs]/.test(_) ? Math.max(1, Math.min(21, y)) : Math.max(0, Math.min(20, y)), M.toString = function () {
        return t + "";
      }, M;
    }
    return {
      format: l,
      formatPrefix: function (t, n) {
        var e = l(((t = Jc(t)).type = "f", t)),
          r = 3 * Math.max(-8, Math.min(8, Math.floor(Zc(n) / 3))),
          i = Math.pow(10, -r),
          o = uf[8 + r / 3];
        return function (t) {
          return e(i * t) + o;
        };
      }
    };
  }
  function ff(n) {
    return of = cf(n), t.format = of.format, t.formatPrefix = of.formatPrefix, of;
  }
  function sf(t) {
    return Math.max(0, -Zc(Math.abs(t)));
  }
  function lf(t, n) {
    return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(Zc(n) / 3))) - Zc(Math.abs(t)));
  }
  function hf(t, n) {
    return t = Math.abs(t), n = Math.abs(n) - t, Math.max(0, Zc(n) - Zc(t)) + 1;
  }
  t.format = void 0, t.formatPrefix = void 0, ff({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  var df = 1e-6,
    pf = 1e-12,
    gf = Math.PI,
    yf = gf / 2,
    vf = gf / 4,
    _f = 2 * gf,
    bf = 180 / gf,
    mf = gf / 180,
    xf = Math.abs,
    wf = Math.atan,
    Mf = Math.atan2,
    Tf = Math.cos,
    Af = Math.ceil,
    Sf = Math.exp,
    Ef = Math.hypot,
    Nf = Math.log,
    kf = Math.pow,
    Cf = Math.sin,
    Pf = Math.sign || function (t) {
      return t > 0 ? 1 : t < 0 ? -1 : 0;
    },
    zf = Math.sqrt,
    $f = Math.tan;
  function Df(t) {
    return t > 1 ? 0 : t < -1 ? gf : Math.acos(t);
  }
  function Rf(t) {
    return t > 1 ? yf : t < -1 ? -yf : Math.asin(t);
  }
  function Ff(t) {
    return (t = Cf(t / 2)) * t;
  }
  function qf() {}
  function Uf(t, n) {
    t && Of.hasOwnProperty(t.type) && Of[t.type](t, n);
  }
  var If = {
      Feature: function (t, n) {
        Uf(t.geometry, n);
      },
      FeatureCollection: function (t, n) {
        for (var e = t.features, r = -1, i = e.length; ++r < i;) Uf(e[r].geometry, n);
      }
    },
    Of = {
      Sphere: function (t, n) {
        n.sphere();
      },
      Point: function (t, n) {
        t = t.coordinates, n.point(t[0], t[1], t[2]);
      },
      MultiPoint: function (t, n) {
        for (var e = t.coordinates, r = -1, i = e.length; ++r < i;) t = e[r], n.point(t[0], t[1], t[2]);
      },
      LineString: function (t, n) {
        Bf(t.coordinates, n, 0);
      },
      MultiLineString: function (t, n) {
        for (var e = t.coordinates, r = -1, i = e.length; ++r < i;) Bf(e[r], n, 0);
      },
      Polygon: function (t, n) {
        Yf(t.coordinates, n);
      },
      MultiPolygon: function (t, n) {
        for (var e = t.coordinates, r = -1, i = e.length; ++r < i;) Yf(e[r], n);
      },
      GeometryCollection: function (t, n) {
        for (var e = t.geometries, r = -1, i = e.length; ++r < i;) Uf(e[r], n);
      }
    };
  function Bf(t, n, e) {
    var r,
      i = -1,
      o = t.length - e;
    for (n.lineStart(); ++i < o;) r = t[i], n.point(r[0], r[1], r[2]);
    n.lineEnd();
  }
  function Yf(t, n) {
    var e = -1,
      r = t.length;
    for (n.polygonStart(); ++e < r;) Bf(t[e], n, 1);
    n.polygonEnd();
  }
  function Lf(t, n) {
    t && If.hasOwnProperty(t.type) ? If[t.type](t, n) : Uf(t, n);
  }
  var jf,
    Hf,
    Xf,
    Gf,
    Vf,
    Wf,
    Zf,
    Kf,
    Qf,
    Jf,
    ts,
    ns,
    es,
    rs,
    is,
    os,
    as = new T(),
    us = new T(),
    cs = {
      point: qf,
      lineStart: qf,
      lineEnd: qf,
      polygonStart: function () {
        as = new T(), cs.lineStart = fs, cs.lineEnd = ss;
      },
      polygonEnd: function () {
        var t = +as;
        us.add(t < 0 ? _f + t : t), this.lineStart = this.lineEnd = this.point = qf;
      },
      sphere: function () {
        us.add(_f);
      }
    };
  function fs() {
    cs.point = ls;
  }
  function ss() {
    hs(jf, Hf);
  }
  function ls(t, n) {
    cs.point = hs, jf = t, Hf = n, Xf = t *= mf, Gf = Tf(n = (n *= mf) / 2 + vf), Vf = Cf(n);
  }
  function hs(t, n) {
    var e = (t *= mf) - Xf,
      r = e >= 0 ? 1 : -1,
      i = r * e,
      o = Tf(n = (n *= mf) / 2 + vf),
      a = Cf(n),
      u = Vf * a,
      c = Gf * o + u * Tf(i),
      f = u * r * Cf(i);
    as.add(Mf(f, c)), Xf = t, Gf = o, Vf = a;
  }
  function ds(t) {
    return [Mf(t[1], t[0]), Rf(t[2])];
  }
  function ps(t) {
    var n = t[0],
      e = t[1],
      r = Tf(e);
    return [r * Tf(n), r * Cf(n), Cf(e)];
  }
  function gs(t, n) {
    return t[0] * n[0] + t[1] * n[1] + t[2] * n[2];
  }
  function ys(t, n) {
    return [t[1] * n[2] - t[2] * n[1], t[2] * n[0] - t[0] * n[2], t[0] * n[1] - t[1] * n[0]];
  }
  function vs(t, n) {
    t[0] += n[0], t[1] += n[1], t[2] += n[2];
  }
  function _s(t, n) {
    return [t[0] * n, t[1] * n, t[2] * n];
  }
  function bs(t) {
    var n = zf(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
    t[0] /= n, t[1] /= n, t[2] /= n;
  }
  var ms,
    xs,
    ws,
    Ms,
    Ts,
    As,
    Ss,
    Es,
    Ns,
    ks,
    Cs,
    Ps,
    zs,
    $s,
    Ds,
    Rs,
    Fs = {
      point: qs,
      lineStart: Is,
      lineEnd: Os,
      polygonStart: function () {
        Fs.point = Bs, Fs.lineStart = Ys, Fs.lineEnd = Ls, rs = new T(), cs.polygonStart();
      },
      polygonEnd: function () {
        cs.polygonEnd(), Fs.point = qs, Fs.lineStart = Is, Fs.lineEnd = Os, as < 0 ? (Wf = -(Kf = 180), Zf = -(Qf = 90)) : rs > df ? Qf = 90 : rs < -df && (Zf = -90), os[0] = Wf, os[1] = Kf;
      },
      sphere: function () {
        Wf = -(Kf = 180), Zf = -(Qf = 90);
      }
    };
  function qs(t, n) {
    is.push(os = [Wf = t, Kf = t]), n < Zf && (Zf = n), n > Qf && (Qf = n);
  }
  function Us(t, n) {
    var e = ps([t * mf, n * mf]);
    if (es) {
      var r = ys(es, e),
        i = ys([r[1], -r[0], 0], r);
      bs(i), i = ds(i);
      var o,
        a = t - Jf,
        u = a > 0 ? 1 : -1,
        c = i[0] * bf * u,
        f = xf(a) > 180;
      f ^ (u * Jf < c && c < u * t) ? (o = i[1] * bf) > Qf && (Qf = o) : f ^ (u * Jf < (c = (c + 360) % 360 - 180) && c < u * t) ? (o = -i[1] * bf) < Zf && (Zf = o) : (n < Zf && (Zf = n), n > Qf && (Qf = n)), f ? t < Jf ? js(Wf, t) > js(Wf, Kf) && (Kf = t) : js(t, Kf) > js(Wf, Kf) && (Wf = t) : Kf >= Wf ? (t < Wf && (Wf = t), t > Kf && (Kf = t)) : t > Jf ? js(Wf, t) > js(Wf, Kf) && (Kf = t) : js(t, Kf) > js(Wf, Kf) && (Wf = t);
    } else is.push(os = [Wf = t, Kf = t]);
    n < Zf && (Zf = n), n > Qf && (Qf = n), es = e, Jf = t;
  }
  function Is() {
    Fs.point = Us;
  }
  function Os() {
    os[0] = Wf, os[1] = Kf, Fs.point = qs, es = null;
  }
  function Bs(t, n) {
    if (es) {
      var e = t - Jf;
      rs.add(xf(e) > 180 ? e + (e > 0 ? 360 : -360) : e);
    } else ts = t, ns = n;
    cs.point(t, n), Us(t, n);
  }
  function Ys() {
    cs.lineStart();
  }
  function Ls() {
    Bs(ts, ns), cs.lineEnd(), xf(rs) > df && (Wf = -(Kf = 180)), os[0] = Wf, os[1] = Kf, es = null;
  }
  function js(t, n) {
    return (n -= t) < 0 ? n + 360 : n;
  }
  function Hs(t, n) {
    return t[0] - n[0];
  }
  function Xs(t, n) {
    return t[0] <= t[1] ? t[0] <= n && n <= t[1] : n < t[0] || t[1] < n;
  }
  var Gs = {
    sphere: qf,
    point: Vs,
    lineStart: Zs,
    lineEnd: Js,
    polygonStart: function () {
      Gs.lineStart = tl, Gs.lineEnd = nl;
    },
    polygonEnd: function () {
      Gs.lineStart = Zs, Gs.lineEnd = Js;
    }
  };
  function Vs(t, n) {
    t *= mf;
    var e = Tf(n *= mf);
    Ws(e * Tf(t), e * Cf(t), Cf(n));
  }
  function Ws(t, n, e) {
    ++ms, ws += (t - ws) / ms, Ms += (n - Ms) / ms, Ts += (e - Ts) / ms;
  }
  function Zs() {
    Gs.point = Ks;
  }
  function Ks(t, n) {
    t *= mf;
    var e = Tf(n *= mf);
    $s = e * Tf(t), Ds = e * Cf(t), Rs = Cf(n), Gs.point = Qs, Ws($s, Ds, Rs);
  }
  function Qs(t, n) {
    t *= mf;
    var e = Tf(n *= mf),
      r = e * Tf(t),
      i = e * Cf(t),
      o = Cf(n),
      a = Mf(zf((a = Ds * o - Rs * i) * a + (a = Rs * r - $s * o) * a + (a = $s * i - Ds * r) * a), $s * r + Ds * i + Rs * o);
    xs += a, As += a * ($s + ($s = r)), Ss += a * (Ds + (Ds = i)), Es += a * (Rs + (Rs = o)), Ws($s, Ds, Rs);
  }
  function Js() {
    Gs.point = Vs;
  }
  function tl() {
    Gs.point = el;
  }
  function nl() {
    rl(Ps, zs), Gs.point = Vs;
  }
  function el(t, n) {
    Ps = t, zs = n, t *= mf, n *= mf, Gs.point = rl;
    var e = Tf(n);
    $s = e * Tf(t), Ds = e * Cf(t), Rs = Cf(n), Ws($s, Ds, Rs);
  }
  function rl(t, n) {
    t *= mf;
    var e = Tf(n *= mf),
      r = e * Tf(t),
      i = e * Cf(t),
      o = Cf(n),
      a = Ds * o - Rs * i,
      u = Rs * r - $s * o,
      c = $s * i - Ds * r,
      f = Ef(a, u, c),
      s = Rf(f),
      l = f && -s / f;
    Ns.add(l * a), ks.add(l * u), Cs.add(l * c), xs += s, As += s * ($s + ($s = r)), Ss += s * (Ds + (Ds = i)), Es += s * (Rs + (Rs = o)), Ws($s, Ds, Rs);
  }
  function il(t) {
    return function () {
      return t;
    };
  }
  function ol(t, n) {
    function e(e, r) {
      return e = t(e, r), n(e[0], e[1]);
    }
    return t.invert && n.invert && (e.invert = function (e, r) {
      return (e = n.invert(e, r)) && t.invert(e[0], e[1]);
    }), e;
  }
  function al(t, n) {
    return xf(t) > gf && (t -= Math.round(t / _f) * _f), [t, n];
  }
  function ul(t, n, e) {
    return (t %= _f) ? n || e ? ol(fl(t), sl(n, e)) : fl(t) : n || e ? sl(n, e) : al;
  }
  function cl(t) {
    return function (n, e) {
      return xf(n += t) > gf && (n -= Math.round(n / _f) * _f), [n, e];
    };
  }
  function fl(t) {
    var n = cl(t);
    return n.invert = cl(-t), n;
  }
  function sl(t, n) {
    var e = Tf(t),
      r = Cf(t),
      i = Tf(n),
      o = Cf(n);
    function a(t, n) {
      var a = Tf(n),
        u = Tf(t) * a,
        c = Cf(t) * a,
        f = Cf(n),
        s = f * e + u * r;
      return [Mf(c * i - s * o, u * e - f * r), Rf(s * i + c * o)];
    }
    return a.invert = function (t, n) {
      var a = Tf(n),
        u = Tf(t) * a,
        c = Cf(t) * a,
        f = Cf(n),
        s = f * i - c * o;
      return [Mf(c * i + f * o, u * e + s * r), Rf(s * e - u * r)];
    }, a;
  }
  function ll(t) {
    function n(n) {
      return (n = t(n[0] * mf, n[1] * mf))[0] *= bf, n[1] *= bf, n;
    }
    return t = ul(t[0] * mf, t[1] * mf, t.length > 2 ? t[2] * mf : 0), n.invert = function (n) {
      return (n = t.invert(n[0] * mf, n[1] * mf))[0] *= bf, n[1] *= bf, n;
    }, n;
  }
  function hl(t, n, e, r, i, o) {
    if (e) {
      var a = Tf(n),
        u = Cf(n),
        c = r * e;
      null == i ? (i = n + r * _f, o = n - c / 2) : (i = dl(a, i), o = dl(a, o), (r > 0 ? i < o : i > o) && (i += r * _f));
      for (var f, s = i; r > 0 ? s > o : s < o; s -= c) f = ds([a, -u * Tf(s), -u * Cf(s)]), t.point(f[0], f[1]);
    }
  }
  function dl(t, n) {
    (n = ps(n))[0] -= t, bs(n);
    var e = Df(-n[1]);
    return ((-n[2] < 0 ? -e : e) + _f - df) % _f;
  }
  function pl() {
    var t,
      n = [];
    return {
      point: function (n, e, r) {
        t.push([n, e, r]);
      },
      lineStart: function () {
        n.push(t = []);
      },
      lineEnd: qf,
      rejoin: function () {
        n.length > 1 && n.push(n.pop().concat(n.shift()));
      },
      result: function () {
        var e = n;
        return n = [], t = null, e;
      }
    };
  }
  function gl(t, n) {
    return xf(t[0] - n[0]) < df && xf(t[1] - n[1]) < df;
  }
  function yl(t, n, e, r) {
    this.x = t, this.z = n, this.o = e, this.e = r, this.v = !1, this.n = this.p = null;
  }
  function vl(t, n, e, r, i) {
    var o,
      a,
      u = [],
      c = [];
    if (t.forEach(function (t) {
      if (!((n = t.length - 1) <= 0)) {
        var n,
          e,
          r = t[0],
          a = t[n];
        if (gl(r, a)) {
          if (!r[2] && !a[2]) {
            for (i.lineStart(), o = 0; o < n; ++o) i.point((r = t[o])[0], r[1]);
            return void i.lineEnd();
          }
          a[0] += 2 * df;
        }
        u.push(e = new yl(r, t, null, !0)), c.push(e.o = new yl(r, null, e, !1)), u.push(e = new yl(a, t, null, !1)), c.push(e.o = new yl(a, null, e, !0));
      }
    }), u.length) {
      for (c.sort(n), _l(u), _l(c), o = 0, a = c.length; o < a; ++o) c[o].e = e = !e;
      for (var f, s, l = u[0];;) {
        for (var h = l, d = !0; h.v;) if ((h = h.n) === l) return;
        f = h.z, i.lineStart();
        do {
          if (h.v = h.o.v = !0, h.e) {
            if (d) for (o = 0, a = f.length; o < a; ++o) i.point((s = f[o])[0], s[1]);else r(h.x, h.n.x, 1, i);
            h = h.n;
          } else {
            if (d) for (f = h.p.z, o = f.length - 1; o >= 0; --o) i.point((s = f[o])[0], s[1]);else r(h.x, h.p.x, -1, i);
            h = h.p;
          }
          f = (h = h.o).z, d = !d;
        } while (!h.v);
        i.lineEnd();
      }
    }
  }
  function _l(t) {
    if (n = t.length) {
      for (var n, e, r = 0, i = t[0]; ++r < n;) i.n = e = t[r], e.p = i, i = e;
      i.n = e = t[0], e.p = i;
    }
  }
  function bl(t) {
    return xf(t[0]) <= gf ? t[0] : Pf(t[0]) * ((xf(t[0]) + gf) % _f - gf);
  }
  function ml(t, n) {
    var e = bl(n),
      r = n[1],
      i = Cf(r),
      o = [Cf(e), -Tf(e), 0],
      a = 0,
      u = 0,
      c = new T();
    1 === i ? r = yf + df : -1 === i && (r = -yf - df);
    for (var f = 0, s = t.length; f < s; ++f) if (h = (l = t[f]).length) for (var l, h, d = l[h - 1], p = bl(d), g = d[1] / 2 + vf, y = Cf(g), v = Tf(g), _ = 0; _ < h; ++_, p = m, y = w, v = M, d = b) {
      var b = l[_],
        m = bl(b),
        x = b[1] / 2 + vf,
        w = Cf(x),
        M = Tf(x),
        A = m - p,
        S = A >= 0 ? 1 : -1,
        E = S * A,
        N = E > gf,
        k = y * w;
      if (c.add(Mf(k * S * Cf(E), v * M + k * Tf(E))), a += N ? A + S * _f : A, N ^ p >= e ^ m >= e) {
        var C = ys(ps(d), ps(b));
        bs(C);
        var P = ys(o, C);
        bs(P);
        var z = (N ^ A >= 0 ? -1 : 1) * Rf(P[2]);
        (r > z || r === z && (C[0] || C[1])) && (u += N ^ A >= 0 ? 1 : -1);
      }
    }
    return (a < -df || a < df && c < -pf) ^ 1 & u;
  }
  function xl(t, n, e, r) {
    return function (i) {
      var o,
        a,
        u,
        c = n(i),
        f = pl(),
        s = n(f),
        l = !1,
        h = {
          point: d,
          lineStart: g,
          lineEnd: y,
          polygonStart: function () {
            h.point = v, h.lineStart = _, h.lineEnd = b, a = [], o = [];
          },
          polygonEnd: function () {
            h.point = d, h.lineStart = g, h.lineEnd = y, a = ft(a);
            var t = ml(o, r);
            a.length ? (l || (i.polygonStart(), l = !0), vl(a, Ml, t, e, i)) : t && (l || (i.polygonStart(), l = !0), i.lineStart(), e(null, null, 1, i), i.lineEnd()), l && (i.polygonEnd(), l = !1), a = o = null;
          },
          sphere: function () {
            i.polygonStart(), i.lineStart(), e(null, null, 1, i), i.lineEnd(), i.polygonEnd();
          }
        };
      function d(n, e) {
        t(n, e) && i.point(n, e);
      }
      function p(t, n) {
        c.point(t, n);
      }
      function g() {
        h.point = p, c.lineStart();
      }
      function y() {
        h.point = d, c.lineEnd();
      }
      function v(t, n) {
        u.push([t, n]), s.point(t, n);
      }
      function _() {
        s.lineStart(), u = [];
      }
      function b() {
        v(u[0][0], u[0][1]), s.lineEnd();
        var t,
          n,
          e,
          r,
          c = s.clean(),
          h = f.result(),
          d = h.length;
        if (u.pop(), o.push(u), u = null, d) if (1 & c) {
          if ((n = (e = h[0]).length - 1) > 0) {
            for (l || (i.polygonStart(), l = !0), i.lineStart(), t = 0; t < n; ++t) i.point((r = e[t])[0], r[1]);
            i.lineEnd();
          }
        } else d > 1 && 2 & c && h.push(h.pop().concat(h.shift())), a.push(h.filter(wl));
      }
      return h;
    };
  }
  function wl(t) {
    return t.length > 1;
  }
  function Ml(t, n) {
    return ((t = t.x)[0] < 0 ? t[1] - yf - df : yf - t[1]) - ((n = n.x)[0] < 0 ? n[1] - yf - df : yf - n[1]);
  }
  al.invert = al;
  var Tl = xl(function () {
    return !0;
  }, function (t) {
    var n,
      e = NaN,
      r = NaN,
      i = NaN;
    return {
      lineStart: function () {
        t.lineStart(), n = 1;
      },
      point: function (o, a) {
        var u = o > 0 ? gf : -gf,
          c = xf(o - e);
        xf(c - gf) < df ? (t.point(e, r = (r + a) / 2 > 0 ? yf : -yf), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(u, r), t.point(o, r), n = 0) : i !== u && c >= gf && (xf(e - i) < df && (e -= i * df), xf(o - u) < df && (o -= u * df), r = function (t, n, e, r) {
          var i,
            o,
            a = Cf(t - e);
          return xf(a) > df ? wf((Cf(n) * (o = Tf(r)) * Cf(e) - Cf(r) * (i = Tf(n)) * Cf(t)) / (i * o * a)) : (n + r) / 2;
        }(e, r, o, a), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(u, r), n = 0), t.point(e = o, r = a), i = u;
      },
      lineEnd: function () {
        t.lineEnd(), e = r = NaN;
      },
      clean: function () {
        return 2 - n;
      }
    };
  }, function (t, n, e, r) {
    var i;
    if (null == t) i = e * yf, r.point(-gf, i), r.point(0, i), r.point(gf, i), r.point(gf, 0), r.point(gf, -i), r.point(0, -i), r.point(-gf, -i), r.point(-gf, 0), r.point(-gf, i);else if (xf(t[0] - n[0]) > df) {
      var o = t[0] < n[0] ? gf : -gf;
      i = e * o / 2, r.point(-o, i), r.point(0, i), r.point(o, i);
    } else r.point(n[0], n[1]);
  }, [-gf, -yf]);
  function Al(t) {
    var n = Tf(t),
      e = 6 * mf,
      r = n > 0,
      i = xf(n) > df;
    function o(t, e) {
      return Tf(t) * Tf(e) > n;
    }
    function a(t, e, r) {
      var i = [1, 0, 0],
        o = ys(ps(t), ps(e)),
        a = gs(o, o),
        u = o[0],
        c = a - u * u;
      if (!c) return !r && t;
      var f = n * a / c,
        s = -n * u / c,
        l = ys(i, o),
        h = _s(i, f);
      vs(h, _s(o, s));
      var d = l,
        p = gs(h, d),
        g = gs(d, d),
        y = p * p - g * (gs(h, h) - 1);
      if (!(y < 0)) {
        var v = zf(y),
          _ = _s(d, (-p - v) / g);
        if (vs(_, h), _ = ds(_), !r) return _;
        var b,
          m = t[0],
          x = e[0],
          w = t[1],
          M = e[1];
        x < m && (b = m, m = x, x = b);
        var T = x - m,
          A = xf(T - gf) < df;
        if (!A && M < w && (b = w, w = M, M = b), A || T < df ? A ? w + M > 0 ^ _[1] < (xf(_[0] - m) < df ? w : M) : w <= _[1] && _[1] <= M : T > gf ^ (m <= _[0] && _[0] <= x)) {
          var S = _s(d, (-p + v) / g);
          return vs(S, h), [_, ds(S)];
        }
      }
    }
    function u(n, e) {
      var i = r ? t : gf - t,
        o = 0;
      return n < -i ? o |= 1 : n > i && (o |= 2), e < -i ? o |= 4 : e > i && (o |= 8), o;
    }
    return xl(o, function (t) {
      var n, e, c, f, s;
      return {
        lineStart: function () {
          f = c = !1, s = 1;
        },
        point: function (l, h) {
          var d,
            p = [l, h],
            g = o(l, h),
            y = r ? g ? 0 : u(l, h) : g ? u(l + (l < 0 ? gf : -gf), h) : 0;
          if (!n && (f = c = g) && t.lineStart(), g !== c && (!(d = a(n, p)) || gl(n, d) || gl(p, d)) && (p[2] = 1), g !== c) s = 0, g ? (t.lineStart(), d = a(p, n), t.point(d[0], d[1])) : (d = a(n, p), t.point(d[0], d[1], 2), t.lineEnd()), n = d;else if (i && n && r ^ g) {
            var v;
            y & e || !(v = a(p, n, !0)) || (s = 0, r ? (t.lineStart(), t.point(v[0][0], v[0][1]), t.point(v[1][0], v[1][1]), t.lineEnd()) : (t.point(v[1][0], v[1][1]), t.lineEnd(), t.lineStart(), t.point(v[0][0], v[0][1], 3)));
          }
          !g || n && gl(n, p) || t.point(p[0], p[1]), n = p, c = g, e = y;
        },
        lineEnd: function () {
          c && t.lineEnd(), n = null;
        },
        clean: function () {
          return s | (f && c) << 1;
        }
      };
    }, function (n, r, i, o) {
      hl(o, t, e, i, n, r);
    }, r ? [0, -t] : [-gf, t - gf]);
  }
  var Sl,
    El,
    Nl,
    kl,
    Cl = 1e9,
    Pl = -Cl;
  function zl(t, n, e, r) {
    function i(i, o) {
      return t <= i && i <= e && n <= o && o <= r;
    }
    function o(i, o, u, f) {
      var s = 0,
        l = 0;
      if (null == i || (s = a(i, u)) !== (l = a(o, u)) || c(i, o) < 0 ^ u > 0) do {
        f.point(0 === s || 3 === s ? t : e, s > 1 ? r : n);
      } while ((s = (s + u + 4) % 4) !== l);else f.point(o[0], o[1]);
    }
    function a(r, i) {
      return xf(r[0] - t) < df ? i > 0 ? 0 : 3 : xf(r[0] - e) < df ? i > 0 ? 2 : 1 : xf(r[1] - n) < df ? i > 0 ? 1 : 0 : i > 0 ? 3 : 2;
    }
    function u(t, n) {
      return c(t.x, n.x);
    }
    function c(t, n) {
      var e = a(t, 1),
        r = a(n, 1);
      return e !== r ? e - r : 0 === e ? n[1] - t[1] : 1 === e ? t[0] - n[0] : 2 === e ? t[1] - n[1] : n[0] - t[0];
    }
    return function (a) {
      var c,
        f,
        s,
        l,
        h,
        d,
        p,
        g,
        y,
        v,
        _,
        b = a,
        m = pl(),
        x = {
          point: w,
          lineStart: function () {
            x.point = M, f && f.push(s = []);
            v = !0, y = !1, p = g = NaN;
          },
          lineEnd: function () {
            c && (M(l, h), d && y && m.rejoin(), c.push(m.result()));
            x.point = w, y && b.lineEnd();
          },
          polygonStart: function () {
            b = m, c = [], f = [], _ = !0;
          },
          polygonEnd: function () {
            var n = function () {
                for (var n = 0, e = 0, i = f.length; e < i; ++e) for (var o, a, u = f[e], c = 1, s = u.length, l = u[0], h = l[0], d = l[1]; c < s; ++c) o = h, a = d, h = (l = u[c])[0], d = l[1], a <= r ? d > r && (h - o) * (r - a) > (d - a) * (t - o) && ++n : d <= r && (h - o) * (r - a) < (d - a) * (t - o) && --n;
                return n;
              }(),
              e = _ && n,
              i = (c = ft(c)).length;
            (e || i) && (a.polygonStart(), e && (a.lineStart(), o(null, null, 1, a), a.lineEnd()), i && vl(c, u, n, o, a), a.polygonEnd());
            b = a, c = f = s = null;
          }
        };
      function w(t, n) {
        i(t, n) && b.point(t, n);
      }
      function M(o, a) {
        var u = i(o, a);
        if (f && s.push([o, a]), v) l = o, h = a, d = u, v = !1, u && (b.lineStart(), b.point(o, a));else if (u && y) b.point(o, a);else {
          var c = [p = Math.max(Pl, Math.min(Cl, p)), g = Math.max(Pl, Math.min(Cl, g))],
            m = [o = Math.max(Pl, Math.min(Cl, o)), a = Math.max(Pl, Math.min(Cl, a))];
          !function (t, n, e, r, i, o) {
            var a,
              u = t[0],
              c = t[1],
              f = 0,
              s = 1,
              l = n[0] - u,
              h = n[1] - c;
            if (a = e - u, l || !(a > 0)) {
              if (a /= l, l < 0) {
                if (a < f) return;
                a < s && (s = a);
              } else if (l > 0) {
                if (a > s) return;
                a > f && (f = a);
              }
              if (a = i - u, l || !(a < 0)) {
                if (a /= l, l < 0) {
                  if (a > s) return;
                  a > f && (f = a);
                } else if (l > 0) {
                  if (a < f) return;
                  a < s && (s = a);
                }
                if (a = r - c, h || !(a > 0)) {
                  if (a /= h, h < 0) {
                    if (a < f) return;
                    a < s && (s = a);
                  } else if (h > 0) {
                    if (a > s) return;
                    a > f && (f = a);
                  }
                  if (a = o - c, h || !(a < 0)) {
                    if (a /= h, h < 0) {
                      if (a > s) return;
                      a > f && (f = a);
                    } else if (h > 0) {
                      if (a < f) return;
                      a < s && (s = a);
                    }
                    return f > 0 && (t[0] = u + f * l, t[1] = c + f * h), s < 1 && (n[0] = u + s * l, n[1] = c + s * h), !0;
                  }
                }
              }
            }
          }(c, m, t, n, e, r) ? u && (b.lineStart(), b.point(o, a), _ = !1) : (y || (b.lineStart(), b.point(c[0], c[1])), b.point(m[0], m[1]), u || b.lineEnd(), _ = !1);
        }
        p = o, g = a, y = u;
      }
      return x;
    };
  }
  var $l = {
    sphere: qf,
    point: qf,
    lineStart: function () {
      $l.point = Rl, $l.lineEnd = Dl;
    },
    lineEnd: qf,
    polygonStart: qf,
    polygonEnd: qf
  };
  function Dl() {
    $l.point = $l.lineEnd = qf;
  }
  function Rl(t, n) {
    El = t *= mf, Nl = Cf(n *= mf), kl = Tf(n), $l.point = Fl;
  }
  function Fl(t, n) {
    t *= mf;
    var e = Cf(n *= mf),
      r = Tf(n),
      i = xf(t - El),
      o = Tf(i),
      a = r * Cf(i),
      u = kl * e - Nl * r * o,
      c = Nl * e + kl * r * o;
    Sl.add(Mf(zf(a * a + u * u), c)), El = t, Nl = e, kl = r;
  }
  function ql(t) {
    return Sl = new T(), Lf(t, $l), +Sl;
  }
  var Ul = [null, null],
    Il = {
      type: "LineString",
      coordinates: Ul
    };
  function Ol(t, n) {
    return Ul[0] = t, Ul[1] = n, ql(Il);
  }
  var Bl = {
      Feature: function (t, n) {
        return Ll(t.geometry, n);
      },
      FeatureCollection: function (t, n) {
        for (var e = t.features, r = -1, i = e.length; ++r < i;) if (Ll(e[r].geometry, n)) return !0;
        return !1;
      }
    },
    Yl = {
      Sphere: function () {
        return !0;
      },
      Point: function (t, n) {
        return jl(t.coordinates, n);
      },
      MultiPoint: function (t, n) {
        for (var e = t.coordinates, r = -1, i = e.length; ++r < i;) if (jl(e[r], n)) return !0;
        return !1;
      },
      LineString: function (t, n) {
        return Hl(t.coordinates, n);
      },
      MultiLineString: function (t, n) {
        for (var e = t.coordinates, r = -1, i = e.length; ++r < i;) if (Hl(e[r], n)) return !0;
        return !1;
      },
      Polygon: function (t, n) {
        return Xl(t.coordinates, n);
      },
      MultiPolygon: function (t, n) {
        for (var e = t.coordinates, r = -1, i = e.length; ++r < i;) if (Xl(e[r], n)) return !0;
        return !1;
      },
      GeometryCollection: function (t, n) {
        for (var e = t.geometries, r = -1, i = e.length; ++r < i;) if (Ll(e[r], n)) return !0;
        return !1;
      }
    };
  function Ll(t, n) {
    return !(!t || !Yl.hasOwnProperty(t.type)) && Yl[t.type](t, n);
  }
  function jl(t, n) {
    return 0 === Ol(t, n);
  }
  function Hl(t, n) {
    for (var e, r, i, o = 0, a = t.length; o < a; o++) {
      if (0 === (r = Ol(t[o], n))) return !0;
      if (o > 0 && (i = Ol(t[o], t[o - 1])) > 0 && e <= i && r <= i && (e + r - i) * (1 - Math.pow((e - r) / i, 2)) < pf * i) return !0;
      e = r;
    }
    return !1;
  }
  function Xl(t, n) {
    return !!ml(t.map(Gl), Vl(n));
  }
  function Gl(t) {
    return (t = t.map(Vl)).pop(), t;
  }
  function Vl(t) {
    return [t[0] * mf, t[1] * mf];
  }
  function Wl(t, n, e) {
    var r = lt(t, n - df, e).concat(n);
    return function (t) {
      return r.map(function (n) {
        return [t, n];
      });
    };
  }
  function Zl(t, n, e) {
    var r = lt(t, n - df, e).concat(n);
    return function (t) {
      return r.map(function (n) {
        return [n, t];
      });
    };
  }
  function Kl() {
    var t,
      n,
      e,
      r,
      i,
      o,
      a,
      u,
      c,
      f,
      s,
      l,
      h = 10,
      d = h,
      p = 90,
      g = 360,
      y = 2.5;
    function v() {
      return {
        type: "MultiLineString",
        coordinates: _()
      };
    }
    function _() {
      return lt(Af(r / p) * p, e, p).map(s).concat(lt(Af(u / g) * g, a, g).map(l)).concat(lt(Af(n / h) * h, t, h).filter(function (t) {
        return xf(t % p) > df;
      }).map(c)).concat(lt(Af(o / d) * d, i, d).filter(function (t) {
        return xf(t % g) > df;
      }).map(f));
    }
    return v.lines = function () {
      return _().map(function (t) {
        return {
          type: "LineString",
          coordinates: t
        };
      });
    }, v.outline = function () {
      return {
        type: "Polygon",
        coordinates: [s(r).concat(l(a).slice(1), s(e).reverse().slice(1), l(u).reverse().slice(1))]
      };
    }, v.extent = function (t) {
      return arguments.length ? v.extentMajor(t).extentMinor(t) : v.extentMinor();
    }, v.extentMajor = function (t) {
      return arguments.length ? (r = +t[0][0], e = +t[1][0], u = +t[0][1], a = +t[1][1], r > e && (t = r, r = e, e = t), u > a && (t = u, u = a, a = t), v.precision(y)) : [[r, u], [e, a]];
    }, v.extentMinor = function (e) {
      return arguments.length ? (n = +e[0][0], t = +e[1][0], o = +e[0][1], i = +e[1][1], n > t && (e = n, n = t, t = e), o > i && (e = o, o = i, i = e), v.precision(y)) : [[n, o], [t, i]];
    }, v.step = function (t) {
      return arguments.length ? v.stepMajor(t).stepMinor(t) : v.stepMinor();
    }, v.stepMajor = function (t) {
      return arguments.length ? (p = +t[0], g = +t[1], v) : [p, g];
    }, v.stepMinor = function (t) {
      return arguments.length ? (h = +t[0], d = +t[1], v) : [h, d];
    }, v.precision = function (h) {
      return arguments.length ? (y = +h, c = Wl(o, i, 90), f = Zl(n, t, y), s = Wl(u, a, 90), l = Zl(r, e, y), v) : y;
    }, v.extentMajor([[-180, -90 + df], [180, 90 - df]]).extentMinor([[-180, -80 - df], [180, 80 + df]]);
  }
  var Ql,
    Jl,
    th,
    nh,
    eh = t => t,
    rh = new T(),
    ih = new T(),
    oh = {
      point: qf,
      lineStart: qf,
      lineEnd: qf,
      polygonStart: function () {
        oh.lineStart = ah, oh.lineEnd = fh;
      },
      polygonEnd: function () {
        oh.lineStart = oh.lineEnd = oh.point = qf, rh.add(xf(ih)), ih = new T();
      },
      result: function () {
        var t = rh / 2;
        return rh = new T(), t;
      }
    };
  function ah() {
    oh.point = uh;
  }
  function uh(t, n) {
    oh.point = ch, Ql = th = t, Jl = nh = n;
  }
  function ch(t, n) {
    ih.add(nh * t - th * n), th = t, nh = n;
  }
  function fh() {
    ch(Ql, Jl);
  }
  var sh = oh,
    lh = 1 / 0,
    hh = lh,
    dh = -lh,
    ph = dh,
    gh = {
      point: function (t, n) {
        t < lh && (lh = t);
        t > dh && (dh = t);
        n < hh && (hh = n);
        n > ph && (ph = n);
      },
      lineStart: qf,
      lineEnd: qf,
      polygonStart: qf,
      polygonEnd: qf,
      result: function () {
        var t = [[lh, hh], [dh, ph]];
        return dh = ph = -(hh = lh = 1 / 0), t;
      }
    };
  var yh,
    vh,
    _h,
    bh,
    mh = gh,
    xh = 0,
    wh = 0,
    Mh = 0,
    Th = 0,
    Ah = 0,
    Sh = 0,
    Eh = 0,
    Nh = 0,
    kh = 0,
    Ch = {
      point: Ph,
      lineStart: zh,
      lineEnd: Rh,
      polygonStart: function () {
        Ch.lineStart = Fh, Ch.lineEnd = qh;
      },
      polygonEnd: function () {
        Ch.point = Ph, Ch.lineStart = zh, Ch.lineEnd = Rh;
      },
      result: function () {
        var t = kh ? [Eh / kh, Nh / kh] : Sh ? [Th / Sh, Ah / Sh] : Mh ? [xh / Mh, wh / Mh] : [NaN, NaN];
        return xh = wh = Mh = Th = Ah = Sh = Eh = Nh = kh = 0, t;
      }
    };
  function Ph(t, n) {
    xh += t, wh += n, ++Mh;
  }
  function zh() {
    Ch.point = $h;
  }
  function $h(t, n) {
    Ch.point = Dh, Ph(_h = t, bh = n);
  }
  function Dh(t, n) {
    var e = t - _h,
      r = n - bh,
      i = zf(e * e + r * r);
    Th += i * (_h + t) / 2, Ah += i * (bh + n) / 2, Sh += i, Ph(_h = t, bh = n);
  }
  function Rh() {
    Ch.point = Ph;
  }
  function Fh() {
    Ch.point = Uh;
  }
  function qh() {
    Ih(yh, vh);
  }
  function Uh(t, n) {
    Ch.point = Ih, Ph(yh = _h = t, vh = bh = n);
  }
  function Ih(t, n) {
    var e = t - _h,
      r = n - bh,
      i = zf(e * e + r * r);
    Th += i * (_h + t) / 2, Ah += i * (bh + n) / 2, Sh += i, Eh += (i = bh * t - _h * n) * (_h + t), Nh += i * (bh + n), kh += 3 * i, Ph(_h = t, bh = n);
  }
  var Oh = Ch;
  function Bh(t) {
    this._context = t;
  }
  Bh.prototype = {
    _radius: 4.5,
    pointRadius: function (t) {
      return this._radius = t, this;
    },
    polygonStart: function () {
      this._line = 0;
    },
    polygonEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._point = 0;
    },
    lineEnd: function () {
      0 === this._line && this._context.closePath(), this._point = NaN;
    },
    point: function (t, n) {
      switch (this._point) {
        case 0:
          this._context.moveTo(t, n), this._point = 1;
          break;
        case 1:
          this._context.lineTo(t, n);
          break;
        default:
          this._context.moveTo(t + this._radius, n), this._context.arc(t, n, this._radius, 0, _f);
      }
    },
    result: qf
  };
  var Yh,
    Lh,
    jh,
    Hh,
    Xh,
    Gh = new T(),
    Vh = {
      point: qf,
      lineStart: function () {
        Vh.point = Wh;
      },
      lineEnd: function () {
        Yh && Zh(Lh, jh), Vh.point = qf;
      },
      polygonStart: function () {
        Yh = !0;
      },
      polygonEnd: function () {
        Yh = null;
      },
      result: function () {
        var t = +Gh;
        return Gh = new T(), t;
      }
    };
  function Wh(t, n) {
    Vh.point = Zh, Lh = Hh = t, jh = Xh = n;
  }
  function Zh(t, n) {
    Hh -= t, Xh -= n, Gh.add(zf(Hh * Hh + Xh * Xh)), Hh = t, Xh = n;
  }
  var Kh = Vh;
  let Qh, Jh, td, nd;
  class ed {
    constructor(t) {
      this._append = null == t ? rd : function (t) {
        const n = Math.floor(t);
        if (!(n >= 0)) throw new RangeError(`invalid digits: ${t}`);
        if (n > 15) return rd;
        if (n !== Qh) {
          const t = 10 ** n;
          Qh = n, Jh = function (n) {
            let e = 1;
            this._ += n[0];
            for (const r = n.length; e < r; ++e) this._ += Math.round(arguments[e] * t) / t + n[e];
          };
        }
        return Jh;
      }(t), this._radius = 4.5, this._ = "";
    }
    pointRadius(t) {
      return this._radius = +t, this;
    }
    polygonStart() {
      this._line = 0;
    }
    polygonEnd() {
      this._line = NaN;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
      0 === this._line && (this._ += "Z"), this._point = NaN;
    }
    point(t, n) {
      switch (this._point) {
        case 0:
          this._append`M${t},${n}`, this._point = 1;
          break;
        case 1:
          this._append`L${t},${n}`;
          break;
        default:
          if (this._append`M${t},${n}`, this._radius !== td || this._append !== Jh) {
            const t = this._radius,
              n = this._;
            this._ = "", this._append`m0,${t}a${t},${t} 0 1,1 0,${-2 * t}a${t},${t} 0 1,1 0,${2 * t}z`, td = t, Jh = this._append, nd = this._, this._ = n;
          }
          this._ += nd;
      }
    }
    result() {
      const t = this._;
      return this._ = "", t.length ? t : null;
    }
  }
  function rd(t) {
    let n = 1;
    this._ += t[0];
    for (const e = t.length; n < e; ++n) this._ += arguments[n] + t[n];
  }
  function id(t) {
    return function (n) {
      var e = new od();
      for (var r in t) e[r] = t[r];
      return e.stream = n, e;
    };
  }
  function od() {}
  function ad(t, n, e) {
    var r = t.clipExtent && t.clipExtent();
    return t.scale(150).translate([0, 0]), null != r && t.clipExtent(null), Lf(e, t.stream(mh)), n(mh.result()), null != r && t.clipExtent(r), t;
  }
  function ud(t, n, e) {
    return ad(t, function (e) {
      var r = n[1][0] - n[0][0],
        i = n[1][1] - n[0][1],
        o = Math.min(r / (e[1][0] - e[0][0]), i / (e[1][1] - e[0][1])),
        a = +n[0][0] + (r - o * (e[1][0] + e[0][0])) / 2,
        u = +n[0][1] + (i - o * (e[1][1] + e[0][1])) / 2;
      t.scale(150 * o).translate([a, u]);
    }, e);
  }
  function cd(t, n, e) {
    return ud(t, [[0, 0], n], e);
  }
  function fd(t, n, e) {
    return ad(t, function (e) {
      var r = +n,
        i = r / (e[1][0] - e[0][0]),
        o = (r - i * (e[1][0] + e[0][0])) / 2,
        a = -i * e[0][1];
      t.scale(150 * i).translate([o, a]);
    }, e);
  }
  function sd(t, n, e) {
    return ad(t, function (e) {
      var r = +n,
        i = r / (e[1][1] - e[0][1]),
        o = -i * e[0][0],
        a = (r - i * (e[1][1] + e[0][1])) / 2;
      t.scale(150 * i).translate([o, a]);
    }, e);
  }
  od.prototype = {
    constructor: od,
    point: function (t, n) {
      this.stream.point(t, n);
    },
    sphere: function () {
      this.stream.sphere();
    },
    lineStart: function () {
      this.stream.lineStart();
    },
    lineEnd: function () {
      this.stream.lineEnd();
    },
    polygonStart: function () {
      this.stream.polygonStart();
    },
    polygonEnd: function () {
      this.stream.polygonEnd();
    }
  };
  var ld = 16,
    hd = Tf(30 * mf);
  function dd(t, n) {
    return +n ? function (t, n) {
      function e(r, i, o, a, u, c, f, s, l, h, d, p, g, y) {
        var v = f - r,
          _ = s - i,
          b = v * v + _ * _;
        if (b > 4 * n && g--) {
          var m = a + h,
            x = u + d,
            w = c + p,
            M = zf(m * m + x * x + w * w),
            T = Rf(w /= M),
            A = xf(xf(w) - 1) < df || xf(o - l) < df ? (o + l) / 2 : Mf(x, m),
            S = t(A, T),
            E = S[0],
            N = S[1],
            k = E - r,
            C = N - i,
            P = _ * k - v * C;
          (P * P / b > n || xf((v * k + _ * C) / b - .5) > .3 || a * h + u * d + c * p < hd) && (e(r, i, o, a, u, c, E, N, A, m /= M, x /= M, w, g, y), y.point(E, N), e(E, N, A, m, x, w, f, s, l, h, d, p, g, y));
        }
      }
      return function (n) {
        var r,
          i,
          o,
          a,
          u,
          c,
          f,
          s,
          l,
          h,
          d,
          p,
          g = {
            point: y,
            lineStart: v,
            lineEnd: b,
            polygonStart: function () {
              n.polygonStart(), g.lineStart = m;
            },
            polygonEnd: function () {
              n.polygonEnd(), g.lineStart = v;
            }
          };
        function y(e, r) {
          e = t(e, r), n.point(e[0], e[1]);
        }
        function v() {
          s = NaN, g.point = _, n.lineStart();
        }
        function _(r, i) {
          var o = ps([r, i]),
            a = t(r, i);
          e(s, l, f, h, d, p, s = a[0], l = a[1], f = r, h = o[0], d = o[1], p = o[2], ld, n), n.point(s, l);
        }
        function b() {
          g.point = y, n.lineEnd();
        }
        function m() {
          v(), g.point = x, g.lineEnd = w;
        }
        function x(t, n) {
          _(r = t, n), i = s, o = l, a = h, u = d, c = p, g.point = _;
        }
        function w() {
          e(s, l, f, h, d, p, i, o, r, a, u, c, ld, n), g.lineEnd = b, b();
        }
        return g;
      };
    }(t, n) : function (t) {
      return id({
        point: function (n, e) {
          n = t(n, e), this.stream.point(n[0], n[1]);
        }
      });
    }(t);
  }
  var pd = id({
    point: function (t, n) {
      this.stream.point(t * mf, n * mf);
    }
  });
  function gd(t, n, e, r, i, o) {
    if (!o) return function (t, n, e, r, i) {
      function o(o, a) {
        return [n + t * (o *= r), e - t * (a *= i)];
      }
      return o.invert = function (o, a) {
        return [(o - n) / t * r, (e - a) / t * i];
      }, o;
    }(t, n, e, r, i);
    var a = Tf(o),
      u = Cf(o),
      c = a * t,
      f = u * t,
      s = a / t,
      l = u / t,
      h = (u * e - a * n) / t,
      d = (u * n + a * e) / t;
    function p(t, o) {
      return [c * (t *= r) - f * (o *= i) + n, e - f * t - c * o];
    }
    return p.invert = function (t, n) {
      return [r * (s * t - l * n + h), i * (d - l * t - s * n)];
    }, p;
  }
  function yd(t) {
    return vd(function () {
      return t;
    })();
  }
  function vd(t) {
    var n,
      e,
      r,
      i,
      o,
      a,
      u,
      c,
      f,
      s,
      l = 150,
      h = 480,
      d = 250,
      p = 0,
      g = 0,
      y = 0,
      v = 0,
      _ = 0,
      b = 0,
      m = 1,
      x = 1,
      w = null,
      M = Tl,
      T = null,
      A = eh,
      S = .5;
    function E(t) {
      return c(t[0] * mf, t[1] * mf);
    }
    function N(t) {
      return (t = c.invert(t[0], t[1])) && [t[0] * bf, t[1] * bf];
    }
    function k() {
      var t = gd(l, 0, 0, m, x, b).apply(null, n(p, g)),
        r = gd(l, h - t[0], d - t[1], m, x, b);
      return e = ul(y, v, _), u = ol(n, r), c = ol(e, u), a = dd(u, S), C();
    }
    function C() {
      return f = s = null, E;
    }
    return E.stream = function (t) {
      return f && s === t ? f : f = pd(function (t) {
        return id({
          point: function (n, e) {
            var r = t(n, e);
            return this.stream.point(r[0], r[1]);
          }
        });
      }(e)(M(a(A(s = t)))));
    }, E.preclip = function (t) {
      return arguments.length ? (M = t, w = void 0, C()) : M;
    }, E.postclip = function (t) {
      return arguments.length ? (A = t, T = r = i = o = null, C()) : A;
    }, E.clipAngle = function (t) {
      return arguments.length ? (M = +t ? Al(w = t * mf) : (w = null, Tl), C()) : w * bf;
    }, E.clipExtent = function (t) {
      return arguments.length ? (A = null == t ? (T = r = i = o = null, eh) : zl(T = +t[0][0], r = +t[0][1], i = +t[1][0], o = +t[1][1]), C()) : null == T ? null : [[T, r], [i, o]];
    }, E.scale = function (t) {
      return arguments.length ? (l = +t, k()) : l;
    }, E.translate = function (t) {
      return arguments.length ? (h = +t[0], d = +t[1], k()) : [h, d];
    }, E.center = function (t) {
      return arguments.length ? (p = t[0] % 360 * mf, g = t[1] % 360 * mf, k()) : [p * bf, g * bf];
    }, E.rotate = function (t) {
      return arguments.length ? (y = t[0] % 360 * mf, v = t[1] % 360 * mf, _ = t.length > 2 ? t[2] % 360 * mf : 0, k()) : [y * bf, v * bf, _ * bf];
    }, E.angle = function (t) {
      return arguments.length ? (b = t % 360 * mf, k()) : b * bf;
    }, E.reflectX = function (t) {
      return arguments.length ? (m = t ? -1 : 1, k()) : m < 0;
    }, E.reflectY = function (t) {
      return arguments.length ? (x = t ? -1 : 1, k()) : x < 0;
    }, E.precision = function (t) {
      return arguments.length ? (a = dd(u, S = t * t), C()) : zf(S);
    }, E.fitExtent = function (t, n) {
      return ud(E, t, n);
    }, E.fitSize = function (t, n) {
      return cd(E, t, n);
    }, E.fitWidth = function (t, n) {
      return fd(E, t, n);
    }, E.fitHeight = function (t, n) {
      return sd(E, t, n);
    }, function () {
      return n = t.apply(this, arguments), E.invert = n.invert && N, k();
    };
  }
  function _d(t) {
    var n = 0,
      e = gf / 3,
      r = vd(t),
      i = r(n, e);
    return i.parallels = function (t) {
      return arguments.length ? r(n = t[0] * mf, e = t[1] * mf) : [n * bf, e * bf];
    }, i;
  }
  function bd(t, n) {
    var e = Cf(t),
      r = (e + Cf(n)) / 2;
    if (xf(r) < df) return function (t) {
      var n = Tf(t);
      function e(t, e) {
        return [t * n, Cf(e) / n];
      }
      return e.invert = function (t, e) {
        return [t / n, Rf(e * n)];
      }, e;
    }(t);
    var i = 1 + e * (2 * r - e),
      o = zf(i) / r;
    function a(t, n) {
      var e = zf(i - 2 * r * Cf(n)) / r;
      return [e * Cf(t *= r), o - e * Tf(t)];
    }
    return a.invert = function (t, n) {
      var e = o - n,
        a = Mf(t, xf(e)) * Pf(e);
      return e * r < 0 && (a -= gf * Pf(t) * Pf(e)), [a / r, Rf((i - (t * t + e * e) * r * r) / (2 * r))];
    }, a;
  }
  function md() {
    return _d(bd).scale(155.424).center([0, 33.6442]);
  }
  function xd() {
    return md().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-.6, 38.7]);
  }
  function wd(t) {
    return function (n, e) {
      var r = Tf(n),
        i = Tf(e),
        o = t(r * i);
      return o === 1 / 0 ? [2, 0] : [o * i * Cf(n), o * Cf(e)];
    };
  }
  function Md(t) {
    return function (n, e) {
      var r = zf(n * n + e * e),
        i = t(r),
        o = Cf(i),
        a = Tf(i);
      return [Mf(n * o, r * a), Rf(r && e * o / r)];
    };
  }
  var Td = wd(function (t) {
    return zf(2 / (1 + t));
  });
  Td.invert = Md(function (t) {
    return 2 * Rf(t / 2);
  });
  var Ad = wd(function (t) {
    return (t = Df(t)) && t / Cf(t);
  });
  function Sd(t, n) {
    return [t, Nf($f((yf + n) / 2))];
  }
  function Ed(t) {
    var n,
      e,
      r,
      i = yd(t),
      o = i.center,
      a = i.scale,
      u = i.translate,
      c = i.clipExtent,
      f = null;
    function s() {
      var o = gf * a(),
        u = i(ll(i.rotate()).invert([0, 0]));
      return c(null == f ? [[u[0] - o, u[1] - o], [u[0] + o, u[1] + o]] : t === Sd ? [[Math.max(u[0] - o, f), n], [Math.min(u[0] + o, e), r]] : [[f, Math.max(u[1] - o, n)], [e, Math.min(u[1] + o, r)]]);
    }
    return i.scale = function (t) {
      return arguments.length ? (a(t), s()) : a();
    }, i.translate = function (t) {
      return arguments.length ? (u(t), s()) : u();
    }, i.center = function (t) {
      return arguments.length ? (o(t), s()) : o();
    }, i.clipExtent = function (t) {
      return arguments.length ? (null == t ? f = n = e = r = null : (f = +t[0][0], n = +t[0][1], e = +t[1][0], r = +t[1][1]), s()) : null == f ? null : [[f, n], [e, r]];
    }, s();
  }
  function Nd(t) {
    return $f((yf + t) / 2);
  }
  function kd(t, n) {
    var e = Tf(t),
      r = t === n ? Cf(t) : Nf(e / Tf(n)) / Nf(Nd(n) / Nd(t)),
      i = e * kf(Nd(t), r) / r;
    if (!r) return Sd;
    function o(t, n) {
      i > 0 ? n < -yf + df && (n = -yf + df) : n > yf - df && (n = yf - df);
      var e = i / kf(Nd(n), r);
      return [e * Cf(r * t), i - e * Tf(r * t)];
    }
    return o.invert = function (t, n) {
      var e = i - n,
        o = Pf(r) * zf(t * t + e * e),
        a = Mf(t, xf(e)) * Pf(e);
      return e * r < 0 && (a -= gf * Pf(t) * Pf(e)), [a / r, 2 * wf(kf(i / o, 1 / r)) - yf];
    }, o;
  }
  function Cd(t, n) {
    return [t, n];
  }
  function Pd(t, n) {
    var e = Tf(t),
      r = t === n ? Cf(t) : (e - Tf(n)) / (n - t),
      i = e / r + t;
    if (xf(r) < df) return Cd;
    function o(t, n) {
      var e = i - n,
        o = r * t;
      return [e * Cf(o), i - e * Tf(o)];
    }
    return o.invert = function (t, n) {
      var e = i - n,
        o = Mf(t, xf(e)) * Pf(e);
      return e * r < 0 && (o -= gf * Pf(t) * Pf(e)), [o / r, i - Pf(r) * zf(t * t + e * e)];
    }, o;
  }
  Ad.invert = Md(function (t) {
    return t;
  }), Sd.invert = function (t, n) {
    return [t, 2 * wf(Sf(n)) - yf];
  }, Cd.invert = Cd;
  var zd = 1.340264,
    $d = -.081106,
    Dd = 893e-6,
    Rd = .003796,
    Fd = zf(3) / 2;
  function qd(t, n) {
    var e = Rf(Fd * Cf(n)),
      r = e * e,
      i = r * r * r;
    return [t * Tf(e) / (Fd * (zd + 3 * $d * r + i * (7 * Dd + 9 * Rd * r))), e * (zd + $d * r + i * (Dd + Rd * r))];
  }
  function Ud(t, n) {
    var e = Tf(n),
      r = Tf(t) * e;
    return [e * Cf(t) / r, Cf(n) / r];
  }
  function Id(t, n) {
    var e = n * n,
      r = e * e;
    return [t * (.8707 - .131979 * e + r * (r * (.003971 * e - .001529 * r) - .013791)), n * (1.007226 + e * (.015085 + r * (.028874 * e - .044475 - .005916 * r)))];
  }
  function Od(t, n) {
    return [Tf(n) * Cf(t), Cf(n)];
  }
  function Bd(t, n) {
    var e = Tf(n),
      r = 1 + Tf(t) * e;
    return [e * Cf(t) / r, Cf(n) / r];
  }
  function Yd(t, n) {
    return [Nf($f((yf + n) / 2)), -t];
  }
  function Ld(t, n) {
    return t.parent === n.parent ? 1 : 2;
  }
  function jd(t, n) {
    return t + n.x;
  }
  function Hd(t, n) {
    return Math.max(t, n.y);
  }
  function Xd(t) {
    var n = 0,
      e = t.children,
      r = e && e.length;
    if (r) for (; --r >= 0;) n += e[r].value;else n = 1;
    t.value = n;
  }
  function Gd(t, n) {
    t instanceof Map ? (t = [void 0, t], void 0 === n && (n = Wd)) : void 0 === n && (n = Vd);
    for (var e, r, i, o, a, u = new Qd(t), c = [u]; e = c.pop();) if ((i = n(e.data)) && (a = (i = Array.from(i)).length)) for (e.children = i, o = a - 1; o >= 0; --o) c.push(r = i[o] = new Qd(i[o])), r.parent = e, r.depth = e.depth + 1;
    return u.eachBefore(Kd);
  }
  function Vd(t) {
    return t.children;
  }
  function Wd(t) {
    return Array.isArray(t) ? t[1] : null;
  }
  function Zd(t) {
    void 0 !== t.data.value && (t.value = t.data.value), t.data = t.data.data;
  }
  function Kd(t) {
    var n = 0;
    do {
      t.height = n;
    } while ((t = t.parent) && t.height < ++n);
  }
  function Qd(t) {
    this.data = t, this.depth = this.height = 0, this.parent = null;
  }
  function Jd(t) {
    return null == t ? null : tp(t);
  }
  function tp(t) {
    if ("function" != typeof t) throw new Error();
    return t;
  }
  function np() {
    return 0;
  }
  function ep(t) {
    return function () {
      return t;
    };
  }
  qd.invert = function (t, n) {
    for (var e, r = n, i = r * r, o = i * i * i, a = 0; a < 12 && (o = (i = (r -= e = (r * (zd + $d * i + o * (Dd + Rd * i)) - n) / (zd + 3 * $d * i + o * (7 * Dd + 9 * Rd * i))) * r) * i * i, !(xf(e) < pf)); ++a);
    return [Fd * t * (zd + 3 * $d * i + o * (7 * Dd + 9 * Rd * i)) / Tf(r), Rf(Cf(r) / Fd)];
  }, Ud.invert = Md(wf), Id.invert = function (t, n) {
    var e,
      r = n,
      i = 25;
    do {
      var o = r * r,
        a = o * o;
      r -= e = (r * (1.007226 + o * (.015085 + a * (.028874 * o - .044475 - .005916 * a))) - n) / (1.007226 + o * (.045255 + a * (.259866 * o - .311325 - .005916 * 11 * a)));
    } while (xf(e) > df && --i > 0);
    return [t / (.8707 + (o = r * r) * (o * (o * o * o * (.003971 - .001529 * o) - .013791) - .131979)), r];
  }, Od.invert = Md(Rf), Bd.invert = Md(function (t) {
    return 2 * wf(t);
  }), Yd.invert = function (t, n) {
    return [-n, 2 * wf(Sf(t)) - yf];
  }, Qd.prototype = Gd.prototype = {
    constructor: Qd,
    count: function () {
      return this.eachAfter(Xd);
    },
    each: function (t, n) {
      let e = -1;
      for (const r of this) t.call(n, r, ++e, this);
      return this;
    },
    eachAfter: function (t, n) {
      for (var e, r, i, o = this, a = [o], u = [], c = -1; o = a.pop();) if (u.push(o), e = o.children) for (r = 0, i = e.length; r < i; ++r) a.push(e[r]);
      for (; o = u.pop();) t.call(n, o, ++c, this);
      return this;
    },
    eachBefore: function (t, n) {
      for (var e, r, i = this, o = [i], a = -1; i = o.pop();) if (t.call(n, i, ++a, this), e = i.children) for (r = e.length - 1; r >= 0; --r) o.push(e[r]);
      return this;
    },
    find: function (t, n) {
      let e = -1;
      for (const r of this) if (t.call(n, r, ++e, this)) return r;
    },
    sum: function (t) {
      return this.eachAfter(function (n) {
        for (var e = +t(n.data) || 0, r = n.children, i = r && r.length; --i >= 0;) e += r[i].value;
        n.value = e;
      });
    },
    sort: function (t) {
      return this.eachBefore(function (n) {
        n.children && n.children.sort(t);
      });
    },
    path: function (t) {
      for (var n = this, e = function (t, n) {
          if (t === n) return t;
          var e = t.ancestors(),
            r = n.ancestors(),
            i = null;
          t = e.pop(), n = r.pop();
          for (; t === n;) i = t, t = e.pop(), n = r.pop();
          return i;
        }(n, t), r = [n]; n !== e;) n = n.parent, r.push(n);
      for (var i = r.length; t !== e;) r.splice(i, 0, t), t = t.parent;
      return r;
    },
    ancestors: function () {
      for (var t = this, n = [t]; t = t.parent;) n.push(t);
      return n;
    },
    descendants: function () {
      return Array.from(this);
    },
    leaves: function () {
      var t = [];
      return this.eachBefore(function (n) {
        n.children || t.push(n);
      }), t;
    },
    links: function () {
      var t = this,
        n = [];
      return t.each(function (e) {
        e !== t && n.push({
          source: e.parent,
          target: e
        });
      }), n;
    },
    copy: function () {
      return Gd(this).eachBefore(Zd);
    },
    [Symbol.iterator]: function* () {
      var t,
        n,
        e,
        r,
        i = this,
        o = [i];
      do {
        for (t = o.reverse(), o = []; i = t.pop();) if (yield i, n = i.children) for (e = 0, r = n.length; e < r; ++e) o.push(n[e]);
      } while (o.length);
    }
  };
  const rp = 1664525,
    ip = 1013904223,
    op = 4294967296;
  function ap() {
    let t = 1;
    return () => (t = (rp * t + ip) % op) / op;
  }
  function up(t, n) {
    for (var e, r, i = 0, o = (t = function (t, n) {
        let e,
          r,
          i = t.length;
        for (; i;) r = n() * i-- | 0, e = t[i], t[i] = t[r], t[r] = e;
        return t;
      }(Array.from(t), n)).length, a = []; i < o;) e = t[i], r && sp(r, e) ? ++i : (r = hp(a = cp(a, e)), i = 0);
    return r;
  }
  function cp(t, n) {
    var e, r;
    if (lp(n, t)) return [n];
    for (e = 0; e < t.length; ++e) if (fp(n, t[e]) && lp(dp(t[e], n), t)) return [t[e], n];
    for (e = 0; e < t.length - 1; ++e) for (r = e + 1; r < t.length; ++r) if (fp(dp(t[e], t[r]), n) && fp(dp(t[e], n), t[r]) && fp(dp(t[r], n), t[e]) && lp(pp(t[e], t[r], n), t)) return [t[e], t[r], n];
    throw new Error();
  }
  function fp(t, n) {
    var e = t.r - n.r,
      r = n.x - t.x,
      i = n.y - t.y;
    return e < 0 || e * e < r * r + i * i;
  }
  function sp(t, n) {
    var e = t.r - n.r + 1e-9 * Math.max(t.r, n.r, 1),
      r = n.x - t.x,
      i = n.y - t.y;
    return e > 0 && e * e > r * r + i * i;
  }
  function lp(t, n) {
    for (var e = 0; e < n.length; ++e) if (!sp(t, n[e])) return !1;
    return !0;
  }
  function hp(t) {
    switch (t.length) {
      case 1:
        return function (t) {
          return {
            x: t.x,
            y: t.y,
            r: t.r
          };
        }(t[0]);
      case 2:
        return dp(t[0], t[1]);
      case 3:
        return pp(t[0], t[1], t[2]);
    }
  }
  function dp(t, n) {
    var e = t.x,
      r = t.y,
      i = t.r,
      o = n.x,
      a = n.y,
      u = n.r,
      c = o - e,
      f = a - r,
      s = u - i,
      l = Math.sqrt(c * c + f * f);
    return {
      x: (e + o + c / l * s) / 2,
      y: (r + a + f / l * s) / 2,
      r: (l + i + u) / 2
    };
  }
  function pp(t, n, e) {
    var r = t.x,
      i = t.y,
      o = t.r,
      a = n.x,
      u = n.y,
      c = n.r,
      f = e.x,
      s = e.y,
      l = e.r,
      h = r - a,
      d = r - f,
      p = i - u,
      g = i - s,
      y = c - o,
      v = l - o,
      _ = r * r + i * i - o * o,
      b = _ - a * a - u * u + c * c,
      m = _ - f * f - s * s + l * l,
      x = d * p - h * g,
      w = (p * m - g * b) / (2 * x) - r,
      M = (g * y - p * v) / x,
      T = (d * b - h * m) / (2 * x) - i,
      A = (h * v - d * y) / x,
      S = M * M + A * A - 1,
      E = 2 * (o + w * M + T * A),
      N = w * w + T * T - o * o,
      k = -(Math.abs(S) > 1e-6 ? (E + Math.sqrt(E * E - 4 * S * N)) / (2 * S) : N / E);
    return {
      x: r + w + M * k,
      y: i + T + A * k,
      r: k
    };
  }
  function gp(t, n, e) {
    var r,
      i,
      o,
      a,
      u = t.x - n.x,
      c = t.y - n.y,
      f = u * u + c * c;
    f ? (i = n.r + e.r, i *= i, a = t.r + e.r, i > (a *= a) ? (r = (f + a - i) / (2 * f), o = Math.sqrt(Math.max(0, a / f - r * r)), e.x = t.x - r * u - o * c, e.y = t.y - r * c + o * u) : (r = (f + i - a) / (2 * f), o = Math.sqrt(Math.max(0, i / f - r * r)), e.x = n.x + r * u - o * c, e.y = n.y + r * c + o * u)) : (e.x = n.x + e.r, e.y = n.y);
  }
  function yp(t, n) {
    var e = t.r + n.r - 1e-6,
      r = n.x - t.x,
      i = n.y - t.y;
    return e > 0 && e * e > r * r + i * i;
  }
  function vp(t) {
    var n = t._,
      e = t.next._,
      r = n.r + e.r,
      i = (n.x * e.r + e.x * n.r) / r,
      o = (n.y * e.r + e.y * n.r) / r;
    return i * i + o * o;
  }
  function _p(t) {
    this._ = t, this.next = null, this.previous = null;
  }
  function bp(t, n) {
    if (!(o = (t = function (t) {
      return "object" == typeof t && "length" in t ? t : Array.from(t);
    }(t)).length)) return 0;
    var e, r, i, o, a, u, c, f, s, l, h;
    if ((e = t[0]).x = 0, e.y = 0, !(o > 1)) return e.r;
    if (r = t[1], e.x = -r.r, r.x = e.r, r.y = 0, !(o > 2)) return e.r + r.r;
    gp(r, e, i = t[2]), e = new _p(e), r = new _p(r), i = new _p(i), e.next = i.previous = r, r.next = e.previous = i, i.next = r.previous = e;
    t: for (c = 3; c < o; ++c) {
      gp(e._, r._, i = t[c]), i = new _p(i), f = r.next, s = e.previous, l = r._.r, h = e._.r;
      do {
        if (l <= h) {
          if (yp(f._, i._)) {
            r = f, e.next = r, r.previous = e, --c;
            continue t;
          }
          l += f._.r, f = f.next;
        } else {
          if (yp(s._, i._)) {
            (e = s).next = r, r.previous = e, --c;
            continue t;
          }
          h += s._.r, s = s.previous;
        }
      } while (f !== s.next);
      for (i.previous = e, i.next = r, e.next = r.previous = r = i, a = vp(e); (i = i.next) !== r;) (u = vp(i)) < a && (e = i, a = u);
      r = e.next;
    }
    for (e = [r._], i = r; (i = i.next) !== r;) e.push(i._);
    for (i = up(e, n), c = 0; c < o; ++c) (e = t[c]).x -= i.x, e.y -= i.y;
    return i.r;
  }
  function mp(t) {
    return Math.sqrt(t.value);
  }
  function xp(t) {
    return function (n) {
      n.children || (n.r = Math.max(0, +t(n) || 0));
    };
  }
  function wp(t, n, e) {
    return function (r) {
      if (i = r.children) {
        var i,
          o,
          a,
          u = i.length,
          c = t(r) * n || 0;
        if (c) for (o = 0; o < u; ++o) i[o].r += c;
        if (a = bp(i, e), c) for (o = 0; o < u; ++o) i[o].r -= c;
        r.r = a + c;
      }
    };
  }
  function Mp(t) {
    return function (n) {
      var e = n.parent;
      n.r *= t, e && (n.x = e.x + t * n.x, n.y = e.y + t * n.y);
    };
  }
  function Tp(t) {
    t.x0 = Math.round(t.x0), t.y0 = Math.round(t.y0), t.x1 = Math.round(t.x1), t.y1 = Math.round(t.y1);
  }
  function Ap(t, n, e, r, i) {
    for (var o, a = t.children, u = -1, c = a.length, f = t.value && (r - n) / t.value; ++u < c;) (o = a[u]).y0 = e, o.y1 = i, o.x0 = n, o.x1 = n += o.value * f;
  }
  var Sp = {
      depth: -1
    },
    Ep = {},
    Np = {};
  function kp(t) {
    return t.id;
  }
  function Cp(t) {
    return t.parentId;
  }
  function Pp(t) {
    let n = t.length;
    if (n < 2) return "";
    for (; --n > 1 && !zp(t, n););
    return t.slice(0, n);
  }
  function zp(t, n) {
    if ("/" === t[n]) {
      let e = 0;
      for (; n > 0 && "\\" === t[--n];) ++e;
      if (0 == (1 & e)) return !0;
    }
    return !1;
  }
  function $p(t, n) {
    return t.parent === n.parent ? 1 : 2;
  }
  function Dp(t) {
    var n = t.children;
    return n ? n[0] : t.t;
  }
  function Rp(t) {
    var n = t.children;
    return n ? n[n.length - 1] : t.t;
  }
  function Fp(t, n, e) {
    var r = e / (n.i - t.i);
    n.c -= r, n.s += e, t.c += r, n.z += e, n.m += e;
  }
  function qp(t, n, e) {
    return t.a.parent === n.parent ? t.a : e;
  }
  function Up(t, n) {
    this._ = t, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = n;
  }
  function Ip(t, n, e, r, i) {
    for (var o, a = t.children, u = -1, c = a.length, f = t.value && (i - e) / t.value; ++u < c;) (o = a[u]).x0 = n, o.x1 = r, o.y0 = e, o.y1 = e += o.value * f;
  }
  Up.prototype = Object.create(Qd.prototype);
  var Op = (1 + Math.sqrt(5)) / 2;
  function Bp(t, n, e, r, i, o) {
    for (var a, u, c, f, s, l, h, d, p, g, y, v = [], _ = n.children, b = 0, m = 0, x = _.length, w = n.value; b < x;) {
      c = i - e, f = o - r;
      do {
        s = _[m++].value;
      } while (!s && m < x);
      for (l = h = s, y = s * s * (g = Math.max(f / c, c / f) / (w * t)), p = Math.max(h / y, y / l); m < x; ++m) {
        if (s += u = _[m].value, u < l && (l = u), u > h && (h = u), y = s * s * g, (d = Math.max(h / y, y / l)) > p) {
          s -= u;
          break;
        }
        p = d;
      }
      v.push(a = {
        value: s,
        dice: c < f,
        children: _.slice(b, m)
      }), a.dice ? Ap(a, e, r, i, w ? r += f * s / w : o) : Ip(a, e, r, w ? e += c * s / w : i, o), w -= s, b = m;
    }
    return v;
  }
  var Yp = function t(n) {
    function e(t, e, r, i, o) {
      Bp(n, t, e, r, i, o);
    }
    return e.ratio = function (n) {
      return t((n = +n) > 1 ? n : 1);
    }, e;
  }(Op);
  var Lp = function t(n) {
    function e(t, e, r, i, o) {
      if ((a = t._squarify) && a.ratio === n) for (var a, u, c, f, s, l = -1, h = a.length, d = t.value; ++l < h;) {
        for (c = (u = a[l]).children, f = u.value = 0, s = c.length; f < s; ++f) u.value += c[f].value;
        u.dice ? Ap(u, e, r, i, d ? r += (o - r) * u.value / d : o) : Ip(u, e, r, d ? e += (i - e) * u.value / d : i, o), d -= u.value;
      } else t._squarify = a = Bp(n, t, e, r, i, o), a.ratio = n;
    }
    return e.ratio = function (n) {
      return t((n = +n) > 1 ? n : 1);
    }, e;
  }(Op);
  function jp(t, n, e) {
    return (n[0] - t[0]) * (e[1] - t[1]) - (n[1] - t[1]) * (e[0] - t[0]);
  }
  function Hp(t, n) {
    return t[0] - n[0] || t[1] - n[1];
  }
  function Xp(t) {
    const n = t.length,
      e = [0, 1];
    let r,
      i = 2;
    for (r = 2; r < n; ++r) {
      for (; i > 1 && jp(t[e[i - 2]], t[e[i - 1]], t[r]) <= 0;) --i;
      e[i++] = r;
    }
    return e.slice(0, i);
  }
  var Gp = Math.random,
    Vp = function t(n) {
      function e(t, e) {
        return t = null == t ? 0 : +t, e = null == e ? 1 : +e, 1 === arguments.length ? (e = t, t = 0) : e -= t, function () {
          return n() * e + t;
        };
      }
      return e.source = t, e;
    }(Gp),
    Wp = function t(n) {
      function e(t, e) {
        return arguments.length < 2 && (e = t, t = 0), t = Math.floor(t), e = Math.floor(e) - t, function () {
          return Math.floor(n() * e + t);
        };
      }
      return e.source = t, e;
    }(Gp),
    Zp = function t(n) {
      function e(t, e) {
        var r, i;
        return t = null == t ? 0 : +t, e = null == e ? 1 : +e, function () {
          var o;
          if (null != r) o = r, r = null;else do {
            r = 2 * n() - 1, o = 2 * n() - 1, i = r * r + o * o;
          } while (!i || i > 1);
          return t + e * o * Math.sqrt(-2 * Math.log(i) / i);
        };
      }
      return e.source = t, e;
    }(Gp),
    Kp = function t(n) {
      var e = Zp.source(n);
      function r() {
        var t = e.apply(this, arguments);
        return function () {
          return Math.exp(t());
        };
      }
      return r.source = t, r;
    }(Gp),
    Qp = function t(n) {
      function e(t) {
        return (t = +t) <= 0 ? () => 0 : function () {
          for (var e = 0, r = t; r > 1; --r) e += n();
          return e + r * n();
        };
      }
      return e.source = t, e;
    }(Gp),
    Jp = function t(n) {
      var e = Qp.source(n);
      function r(t) {
        if (0 == (t = +t)) return n;
        var r = e(t);
        return function () {
          return r() / t;
        };
      }
      return r.source = t, r;
    }(Gp),
    tg = function t(n) {
      function e(t) {
        return function () {
          return -Math.log1p(-n()) / t;
        };
      }
      return e.source = t, e;
    }(Gp),
    ng = function t(n) {
      function e(t) {
        if ((t = +t) < 0) throw new RangeError("invalid alpha");
        return t = 1 / -t, function () {
          return Math.pow(1 - n(), t);
        };
      }
      return e.source = t, e;
    }(Gp),
    eg = function t(n) {
      function e(t) {
        if ((t = +t) < 0 || t > 1) throw new RangeError("invalid p");
        return function () {
          return Math.floor(n() + t);
        };
      }
      return e.source = t, e;
    }(Gp),
    rg = function t(n) {
      function e(t) {
        if ((t = +t) < 0 || t > 1) throw new RangeError("invalid p");
        return 0 === t ? () => 1 / 0 : 1 === t ? () => 1 : (t = Math.log1p(-t), function () {
          return 1 + Math.floor(Math.log1p(-n()) / t);
        });
      }
      return e.source = t, e;
    }(Gp),
    ig = function t(n) {
      var e = Zp.source(n)();
      function r(t, r) {
        if ((t = +t) < 0) throw new RangeError("invalid k");
        if (0 === t) return () => 0;
        if (r = null == r ? 1 : +r, 1 === t) return () => -Math.log1p(-n()) * r;
        var i = (t < 1 ? t + 1 : t) - 1 / 3,
          o = 1 / (3 * Math.sqrt(i)),
          a = t < 1 ? () => Math.pow(n(), 1 / t) : () => 1;
        return function () {
          do {
            do {
              var t = e(),
                u = 1 + o * t;
            } while (u <= 0);
            u *= u * u;
            var c = 1 - n();
          } while (c >= 1 - .0331 * t * t * t * t && Math.log(c) >= .5 * t * t + i * (1 - u + Math.log(u)));
          return i * u * a() * r;
        };
      }
      return r.source = t, r;
    }(Gp),
    og = function t(n) {
      var e = ig.source(n);
      function r(t, n) {
        var r = e(t),
          i = e(n);
        return function () {
          var t = r();
          return 0 === t ? 0 : t / (t + i());
        };
      }
      return r.source = t, r;
    }(Gp),
    ag = function t(n) {
      var e = rg.source(n),
        r = og.source(n);
      function i(t, n) {
        return t = +t, (n = +n) >= 1 ? () => t : n <= 0 ? () => 0 : function () {
          for (var i = 0, o = t, a = n; o * a > 16 && o * (1 - a) > 16;) {
            var u = Math.floor((o + 1) * a),
              c = r(u, o - u + 1)();
            c <= a ? (i += u, o -= u, a = (a - c) / (1 - c)) : (o = u - 1, a /= c);
          }
          for (var f = a < .5, s = e(f ? a : 1 - a), l = s(), h = 0; l <= o; ++h) l += s();
          return i + (f ? h : o - h);
        };
      }
      return i.source = t, i;
    }(Gp),
    ug = function t(n) {
      function e(t, e, r) {
        var i;
        return 0 == (t = +t) ? i = t => -Math.log(t) : (t = 1 / t, i = n => Math.pow(n, t)), e = null == e ? 0 : +e, r = null == r ? 1 : +r, function () {
          return e + r * i(-Math.log1p(-n()));
        };
      }
      return e.source = t, e;
    }(Gp),
    cg = function t(n) {
      function e(t, e) {
        return t = null == t ? 0 : +t, e = null == e ? 1 : +e, function () {
          return t + e * Math.tan(Math.PI * n());
        };
      }
      return e.source = t, e;
    }(Gp),
    fg = function t(n) {
      function e(t, e) {
        return t = null == t ? 0 : +t, e = null == e ? 1 : +e, function () {
          var r = n();
          return t + e * Math.log(r / (1 - r));
        };
      }
      return e.source = t, e;
    }(Gp),
    sg = function t(n) {
      var e = ig.source(n),
        r = ag.source(n);
      function i(t) {
        return function () {
          for (var i = 0, o = t; o > 16;) {
            var a = Math.floor(.875 * o),
              u = e(a)();
            if (u > o) return i + r(a - 1, o / u)();
            i += a, o -= u;
          }
          for (var c = -Math.log1p(-n()), f = 0; c <= o; ++f) c -= Math.log1p(-n());
          return i + f;
        };
      }
      return i.source = t, i;
    }(Gp);
  const lg = 1 / 4294967296;
  function hg(t, n) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(t);
        break;
      default:
        this.range(n).domain(t);
    }
    return this;
  }
  function dg(t, n) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        "function" == typeof t ? this.interpolator(t) : this.range(t);
        break;
      default:
        this.domain(t), "function" == typeof n ? this.interpolator(n) : this.range(n);
    }
    return this;
  }
  const pg = Symbol("implicit");
  function gg() {
    var t = new InternMap(),
      n = [],
      e = [],
      r = pg;
    function i(i) {
      let o = t.get(i);
      if (void 0 === o) {
        if (r !== pg) return r;
        t.set(i, o = n.push(i) - 1);
      }
      return e[o % e.length];
    }
    return i.domain = function (e) {
      if (!arguments.length) return n.slice();
      n = [], t = new InternMap();
      for (const r of e) t.has(r) || t.set(r, n.push(r) - 1);
      return i;
    }, i.range = function (t) {
      return arguments.length ? (e = Array.from(t), i) : e.slice();
    }, i.unknown = function (t) {
      return arguments.length ? (r = t, i) : r;
    }, i.copy = function () {
      return gg(n, e).unknown(r);
    }, hg.apply(i, arguments), i;
  }
  function yg() {
    var t,
      n,
      e = gg().unknown(void 0),
      r = e.domain,
      i = e.range,
      o = 0,
      a = 1,
      u = !1,
      c = 0,
      f = 0,
      s = .5;
    function l() {
      var e = r().length,
        l = a < o,
        h = l ? a : o,
        d = l ? o : a;
      t = (d - h) / Math.max(1, e - c + 2 * f), u && (t = Math.floor(t)), h += (d - h - t * (e - c)) * s, n = t * (1 - c), u && (h = Math.round(h), n = Math.round(n));
      var p = lt(e).map(function (n) {
        return h + t * n;
      });
      return i(l ? p.reverse() : p);
    }
    return delete e.unknown, e.domain = function (t) {
      return arguments.length ? (r(t), l()) : r();
    }, e.range = function (t) {
      return arguments.length ? ([o, a] = t, o = +o, a = +a, l()) : [o, a];
    }, e.rangeRound = function (t) {
      return [o, a] = t, o = +o, a = +a, u = !0, l();
    }, e.bandwidth = function () {
      return n;
    }, e.step = function () {
      return t;
    }, e.round = function (t) {
      return arguments.length ? (u = !!t, l()) : u;
    }, e.padding = function (t) {
      return arguments.length ? (c = Math.min(1, f = +t), l()) : c;
    }, e.paddingInner = function (t) {
      return arguments.length ? (c = Math.min(1, t), l()) : c;
    }, e.paddingOuter = function (t) {
      return arguments.length ? (f = +t, l()) : f;
    }, e.align = function (t) {
      return arguments.length ? (s = Math.max(0, Math.min(1, t)), l()) : s;
    }, e.copy = function () {
      return yg(r(), [o, a]).round(u).paddingInner(c).paddingOuter(f).align(s);
    }, hg.apply(l(), arguments);
  }
  function vg(t) {
    var n = t.copy;
    return t.padding = t.paddingOuter, delete t.paddingInner, delete t.paddingOuter, t.copy = function () {
      return vg(n());
    }, t;
  }
  function _g(t) {
    return +t;
  }
  var bg = [0, 1];
  function mg(t) {
    return t;
  }
  function xg(t, n) {
    return (n -= t = +t) ? function (e) {
      return (e - t) / n;
    } : function (t) {
      return function () {
        return t;
      };
    }(isNaN(n) ? NaN : .5);
  }
  function wg(t, n, e) {
    var r = t[0],
      i = t[1],
      o = n[0],
      a = n[1];
    return i < r ? (r = xg(i, r), o = e(a, o)) : (r = xg(r, i), o = e(o, a)), function (t) {
      return o(r(t));
    };
  }
  function Mg(t, n, e) {
    var r = Math.min(t.length, n.length) - 1,
      i = new Array(r),
      o = new Array(r),
      a = -1;
    for (t[r] < t[0] && (t = t.slice().reverse(), n = n.slice().reverse()); ++a < r;) i[a] = xg(t[a], t[a + 1]), o[a] = e(n[a], n[a + 1]);
    return function (n) {
      var e = s(t, n, 1, r) - 1;
      return o[e](i[e](n));
    };
  }
  function Tg(t, n) {
    return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());
  }
  function Ag() {
    var t,
      n,
      e,
      r,
      i,
      o,
      a = bg,
      u = bg,
      c = Gr,
      f = mg;
    function s() {
      var t = Math.min(a.length, u.length);
      return f !== mg && (f = function (t, n) {
        var e;
        return t > n && (e = t, t = n, n = e), function (e) {
          return Math.max(t, Math.min(n, e));
        };
      }(a[0], a[t - 1])), r = t > 2 ? Mg : wg, i = o = null, l;
    }
    function l(n) {
      return null == n || isNaN(n = +n) ? e : (i || (i = r(a.map(t), u, c)))(t(f(n)));
    }
    return l.invert = function (e) {
      return f(n((o || (o = r(u, a.map(t), Yr)))(e)));
    }, l.domain = function (t) {
      return arguments.length ? (a = Array.from(t, _g), s()) : a.slice();
    }, l.range = function (t) {
      return arguments.length ? (u = Array.from(t), s()) : u.slice();
    }, l.rangeRound = function (t) {
      return u = Array.from(t), c = Vr, s();
    }, l.clamp = function (t) {
      return arguments.length ? (f = !!t || mg, s()) : f !== mg;
    }, l.interpolate = function (t) {
      return arguments.length ? (c = t, s()) : c;
    }, l.unknown = function (t) {
      return arguments.length ? (e = t, l) : e;
    }, function (e, r) {
      return t = e, n = r, s();
    };
  }
  function Sg() {
    return Ag()(mg, mg);
  }
  function Eg(n, e, r, i) {
    var o,
      a = W(n, e, r);
    switch ((i = Jc(null == i ? ",f" : i)).type) {
      case "s":
        var u = Math.max(Math.abs(n), Math.abs(e));
        return null != i.precision || isNaN(o = lf(a, u)) || (i.precision = o), t.formatPrefix(i, u);
      case "":
      case "e":
      case "g":
      case "p":
      case "r":
        null != i.precision || isNaN(o = hf(a, Math.max(Math.abs(n), Math.abs(e)))) || (i.precision = o - ("e" === i.type));
        break;
      case "f":
      case "%":
        null != i.precision || isNaN(o = sf(a)) || (i.precision = o - 2 * ("%" === i.type));
    }
    return t.format(i);
  }
  function Ng(t) {
    var n = t.domain;
    return t.ticks = function (t) {
      var e = n();
      return G(e[0], e[e.length - 1], null == t ? 10 : t);
    }, t.tickFormat = function (t, e) {
      var r = n();
      return Eg(r[0], r[r.length - 1], null == t ? 10 : t, e);
    }, t.nice = function (e) {
      null == e && (e = 10);
      var r,
        i,
        o = n(),
        a = 0,
        u = o.length - 1,
        c = o[a],
        f = o[u],
        s = 10;
      for (f < c && (i = c, c = f, f = i, i = a, a = u, u = i); s-- > 0;) {
        if ((i = V(c, f, e)) === r) return o[a] = c, o[u] = f, n(o);
        if (i > 0) c = Math.floor(c / i) * i, f = Math.ceil(f / i) * i;else {
          if (!(i < 0)) break;
          c = Math.ceil(c * i) / i, f = Math.floor(f * i) / i;
        }
        r = i;
      }
      return t;
    }, t;
  }
  function kg(t, n) {
    var e,
      r = 0,
      i = (t = t.slice()).length - 1,
      o = t[r],
      a = t[i];
    return a < o && (e = r, r = i, i = e, e = o, o = a, a = e), t[r] = n.floor(o), t[i] = n.ceil(a), t;
  }
  function Cg(t) {
    return Math.log(t);
  }
  function Pg(t) {
    return Math.exp(t);
  }
  function zg(t) {
    return -Math.log(-t);
  }
  function $g(t) {
    return -Math.exp(-t);
  }
  function Dg(t) {
    return isFinite(t) ? +("1e" + t) : t < 0 ? 0 : t;
  }
  function Rg(t) {
    return (n, e) => -t(-n, e);
  }
  function Fg(n) {
    const e = n(Cg, Pg),
      r = e.domain;
    let i,
      o,
      a = 10;
    function u() {
      return i = function (t) {
        return t === Math.E ? Math.log : 10 === t && Math.log10 || 2 === t && Math.log2 || (t = Math.log(t), n => Math.log(n) / t);
      }(a), o = function (t) {
        return 10 === t ? Dg : t === Math.E ? Math.exp : n => Math.pow(t, n);
      }(a), r()[0] < 0 ? (i = Rg(i), o = Rg(o), n(zg, $g)) : n(Cg, Pg), e;
    }
    return e.base = function (t) {
      return arguments.length ? (a = +t, u()) : a;
    }, e.domain = function (t) {
      return arguments.length ? (r(t), u()) : r();
    }, e.ticks = t => {
      const n = r();
      let e = n[0],
        u = n[n.length - 1];
      const c = u < e;
      c && ([e, u] = [u, e]);
      let f,
        s,
        l = i(e),
        h = i(u);
      const d = null == t ? 10 : +t;
      let p = [];
      if (!(a % 1) && h - l < d) {
        if (l = Math.floor(l), h = Math.ceil(h), e > 0) {
          for (; l <= h; ++l) for (f = 1; f < a; ++f) if (s = l < 0 ? f / o(-l) : f * o(l), !(s < e)) {
            if (s > u) break;
            p.push(s);
          }
        } else for (; l <= h; ++l) for (f = a - 1; f >= 1; --f) if (s = l > 0 ? f / o(-l) : f * o(l), !(s < e)) {
          if (s > u) break;
          p.push(s);
        }
        2 * p.length < d && (p = G(e, u, d));
      } else p = G(l, h, Math.min(h - l, d)).map(o);
      return c ? p.reverse() : p;
    }, e.tickFormat = (n, r) => {
      if (null == n && (n = 10), null == r && (r = 10 === a ? "s" : ","), "function" != typeof r && (a % 1 || null != (r = Jc(r)).precision || (r.trim = !0), r = t.format(r)), n === 1 / 0) return r;
      const u = Math.max(1, a * n / e.ticks().length);
      return t => {
        let n = t / o(Math.round(i(t)));
        return n * a < a - .5 && (n *= a), n <= u ? r(t) : "";
      };
    }, e.nice = () => r(kg(r(), {
      floor: t => o(Math.floor(i(t))),
      ceil: t => o(Math.ceil(i(t)))
    })), e;
  }
  function qg(t) {
    return function (n) {
      return Math.sign(n) * Math.log1p(Math.abs(n / t));
    };
  }
  function Ug(t) {
    return function (n) {
      return Math.sign(n) * Math.expm1(Math.abs(n)) * t;
    };
  }
  function Ig(t) {
    var n = 1,
      e = t(qg(n), Ug(n));
    return e.constant = function (e) {
      return arguments.length ? t(qg(n = +e), Ug(n)) : n;
    }, Ng(e);
  }
  function Og(t) {
    return function (n) {
      return n < 0 ? -Math.pow(-n, t) : Math.pow(n, t);
    };
  }
  function Bg(t) {
    return t < 0 ? -Math.sqrt(-t) : Math.sqrt(t);
  }
  function Yg(t) {
    return t < 0 ? -t * t : t * t;
  }
  function Lg(t) {
    var n = t(mg, mg),
      e = 1;
    return n.exponent = function (n) {
      return arguments.length ? 1 === (e = +n) ? t(mg, mg) : .5 === e ? t(Bg, Yg) : t(Og(e), Og(1 / e)) : e;
    }, Ng(n);
  }
  function jg() {
    var t = Lg(Ag());
    return t.copy = function () {
      return Tg(t, jg()).exponent(t.exponent());
    }, hg.apply(t, arguments), t;
  }
  function Hg(t) {
    return Math.sign(t) * t * t;
  }
  const Xg = new Date(),
    Gg = new Date();
  function Vg(t, n, e, r) {
    function i(n) {
      return t(n = 0 === arguments.length ? new Date() : new Date(+n)), n;
    }
    return i.floor = n => (t(n = new Date(+n)), n), i.ceil = e => (t(e = new Date(e - 1)), n(e, 1), t(e), e), i.round = t => {
      const n = i(t),
        e = i.ceil(t);
      return t - n < e - t ? n : e;
    }, i.offset = (t, e) => (n(t = new Date(+t), null == e ? 1 : Math.floor(e)), t), i.range = (e, r, o) => {
      const a = [];
      if (e = i.ceil(e), o = null == o ? 1 : Math.floor(o), !(e < r && o > 0)) return a;
      let u;
      do {
        a.push(u = new Date(+e)), n(e, o), t(e);
      } while (u < e && e < r);
      return a;
    }, i.filter = e => Vg(n => {
      if (n >= n) for (; t(n), !e(n);) n.setTime(n - 1);
    }, (t, r) => {
      if (t >= t) if (r < 0) for (; ++r <= 0;) for (; n(t, -1), !e(t););else for (; --r >= 0;) for (; n(t, 1), !e(t););
    }), e && (i.count = (n, r) => (Xg.setTime(+n), Gg.setTime(+r), t(Xg), t(Gg), Math.floor(e(Xg, Gg))), i.every = t => (t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? i.filter(r ? n => r(n) % t == 0 : n => i.count(0, n) % t == 0) : i : null)), i;
  }
  const Wg = Vg(() => {}, (t, n) => {
    t.setTime(+t + n);
  }, (t, n) => n - t);
  Wg.every = t => (t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? Vg(n => {
    n.setTime(Math.floor(n / t) * t);
  }, (n, e) => {
    n.setTime(+n + e * t);
  }, (n, e) => (e - n) / t) : Wg : null);
  const Zg = Wg.range,
    Kg = 1e3,
    Qg = 6e4,
    Jg = 36e5,
    ty = 864e5,
    ny = 6048e5,
    ey = 2592e6,
    ry = 31536e6,
    iy = Vg(t => {
      t.setTime(t - t.getMilliseconds());
    }, (t, n) => {
      t.setTime(+t + n * Kg);
    }, (t, n) => (n - t) / Kg, t => t.getUTCSeconds()),
    oy = iy.range,
    ay = Vg(t => {
      t.setTime(t - t.getMilliseconds() - t.getSeconds() * Kg);
    }, (t, n) => {
      t.setTime(+t + n * Qg);
    }, (t, n) => (n - t) / Qg, t => t.getMinutes()),
    uy = ay.range,
    cy = Vg(t => {
      t.setUTCSeconds(0, 0);
    }, (t, n) => {
      t.setTime(+t + n * Qg);
    }, (t, n) => (n - t) / Qg, t => t.getUTCMinutes()),
    fy = cy.range,
    sy = Vg(t => {
      t.setTime(t - t.getMilliseconds() - t.getSeconds() * Kg - t.getMinutes() * Qg);
    }, (t, n) => {
      t.setTime(+t + n * Jg);
    }, (t, n) => (n - t) / Jg, t => t.getHours()),
    ly = sy.range,
    hy = Vg(t => {
      t.setUTCMinutes(0, 0, 0);
    }, (t, n) => {
      t.setTime(+t + n * Jg);
    }, (t, n) => (n - t) / Jg, t => t.getUTCHours()),
    dy = hy.range,
    py = Vg(t => t.setHours(0, 0, 0, 0), (t, n) => t.setDate(t.getDate() + n), (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Qg) / ty, t => t.getDate() - 1),
    gy = py.range,
    yy = Vg(t => {
      t.setUTCHours(0, 0, 0, 0);
    }, (t, n) => {
      t.setUTCDate(t.getUTCDate() + n);
    }, (t, n) => (n - t) / ty, t => t.getUTCDate() - 1),
    vy = yy.range,
    _y = Vg(t => {
      t.setUTCHours(0, 0, 0, 0);
    }, (t, n) => {
      t.setUTCDate(t.getUTCDate() + n);
    }, (t, n) => (n - t) / ty, t => Math.floor(t / ty)),
    by = _y.range;
  function my(t) {
    return Vg(n => {
      n.setDate(n.getDate() - (n.getDay() + 7 - t) % 7), n.setHours(0, 0, 0, 0);
    }, (t, n) => {
      t.setDate(t.getDate() + 7 * n);
    }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Qg) / ny);
  }
  const xy = my(0),
    wy = my(1),
    My = my(2),
    Ty = my(3),
    Ay = my(4),
    Sy = my(5),
    Ey = my(6),
    Ny = xy.range,
    ky = wy.range,
    Cy = My.range,
    Py = Ty.range,
    zy = Ay.range,
    $y = Sy.range,
    Dy = Ey.range;
  function Ry(t) {
    return Vg(n => {
      n.setUTCDate(n.getUTCDate() - (n.getUTCDay() + 7 - t) % 7), n.setUTCHours(0, 0, 0, 0);
    }, (t, n) => {
      t.setUTCDate(t.getUTCDate() + 7 * n);
    }, (t, n) => (n - t) / ny);
  }
  const Fy = Ry(0),
    qy = Ry(1),
    Uy = Ry(2),
    Iy = Ry(3),
    Oy = Ry(4),
    By = Ry(5),
    Yy = Ry(6),
    Ly = Fy.range,
    jy = qy.range,
    Hy = Uy.range,
    Xy = Iy.range,
    Gy = Oy.range,
    Vy = By.range,
    Wy = Yy.range,
    Zy = Vg(t => {
      t.setDate(1), t.setHours(0, 0, 0, 0);
    }, (t, n) => {
      t.setMonth(t.getMonth() + n);
    }, (t, n) => n.getMonth() - t.getMonth() + 12 * (n.getFullYear() - t.getFullYear()), t => t.getMonth()),
    Ky = Zy.range,
    Qy = Vg(t => {
      t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0);
    }, (t, n) => {
      t.setUTCMonth(t.getUTCMonth() + n);
    }, (t, n) => n.getUTCMonth() - t.getUTCMonth() + 12 * (n.getUTCFullYear() - t.getUTCFullYear()), t => t.getUTCMonth()),
    Jy = Qy.range,
    tv = Vg(t => {
      t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
    }, (t, n) => {
      t.setFullYear(t.getFullYear() + n);
    }, (t, n) => n.getFullYear() - t.getFullYear(), t => t.getFullYear());
  tv.every = t => isFinite(t = Math.floor(t)) && t > 0 ? Vg(n => {
    n.setFullYear(Math.floor(n.getFullYear() / t) * t), n.setMonth(0, 1), n.setHours(0, 0, 0, 0);
  }, (n, e) => {
    n.setFullYear(n.getFullYear() + e * t);
  }) : null;
  const nv = tv.range,
    ev = Vg(t => {
      t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
    }, (t, n) => {
      t.setUTCFullYear(t.getUTCFullYear() + n);
    }, (t, n) => n.getUTCFullYear() - t.getUTCFullYear(), t => t.getUTCFullYear());
  ev.every = t => isFinite(t = Math.floor(t)) && t > 0 ? Vg(n => {
    n.setUTCFullYear(Math.floor(n.getUTCFullYear() / t) * t), n.setUTCMonth(0, 1), n.setUTCHours(0, 0, 0, 0);
  }, (n, e) => {
    n.setUTCFullYear(n.getUTCFullYear() + e * t);
  }) : null;
  const rv = ev.range;
  function iv(t, n, e, i, o, a) {
    const u = [[iy, 1, Kg], [iy, 5, 5e3], [iy, 15, 15e3], [iy, 30, 3e4], [a, 1, Qg], [a, 5, 3e5], [a, 15, 9e5], [a, 30, 18e5], [o, 1, Jg], [o, 3, 108e5], [o, 6, 216e5], [o, 12, 432e5], [i, 1, ty], [i, 2, 1728e5], [e, 1, ny], [n, 1, ey], [n, 3, 7776e6], [t, 1, ry]];
    function c(n, e, i) {
      const o = Math.abs(e - n) / i,
        a = r(([,, t]) => t).right(u, o);
      if (a === u.length) return t.every(W(n / ry, e / ry, i));
      if (0 === a) return Wg.every(Math.max(W(n, e, i), 1));
      const [c, f] = u[o / u[a - 1][2] < u[a][2] / o ? a - 1 : a];
      return c.every(f);
    }
    return [function (t, n, e) {
      const r = n < t;
      r && ([t, n] = [n, t]);
      const i = e && "function" == typeof e.range ? e : c(t, n, e),
        o = i ? i.range(t, +n + 1) : [];
      return r ? o.reverse() : o;
    }, c];
  }
  const [ov, av] = iv(ev, Qy, Fy, _y, hy, cy),
    [uv, cv] = iv(tv, Zy, xy, py, sy, ay);
  function fv(t) {
    if (0 <= t.y && t.y < 100) {
      var n = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L);
      return n.setFullYear(t.y), n;
    }
    return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L);
  }
  function sv(t) {
    if (0 <= t.y && t.y < 100) {
      var n = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L));
      return n.setUTCFullYear(t.y), n;
    }
    return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L));
  }
  function lv(t, n, e) {
    return {
      y: t,
      m: n,
      d: e,
      H: 0,
      M: 0,
      S: 0,
      L: 0
    };
  }
  function hv(t) {
    var n = t.dateTime,
      e = t.date,
      r = t.time,
      i = t.periods,
      o = t.days,
      a = t.shortDays,
      u = t.months,
      c = t.shortMonths,
      f = mv(i),
      s = xv(i),
      l = mv(o),
      h = xv(o),
      d = mv(a),
      p = xv(a),
      g = mv(u),
      y = xv(u),
      v = mv(c),
      _ = xv(c),
      b = {
        a: function (t) {
          return a[t.getDay()];
        },
        A: function (t) {
          return o[t.getDay()];
        },
        b: function (t) {
          return c[t.getMonth()];
        },
        B: function (t) {
          return u[t.getMonth()];
        },
        c: null,
        d: Yv,
        e: Yv,
        f: Gv,
        g: i_,
        G: a_,
        H: Lv,
        I: jv,
        j: Hv,
        L: Xv,
        m: Vv,
        M: Wv,
        p: function (t) {
          return i[+(t.getHours() >= 12)];
        },
        q: function (t) {
          return 1 + ~~(t.getMonth() / 3);
        },
        Q: k_,
        s: C_,
        S: Zv,
        u: Kv,
        U: Qv,
        V: t_,
        w: n_,
        W: e_,
        x: null,
        X: null,
        y: r_,
        Y: o_,
        Z: u_,
        "%": N_
      },
      m = {
        a: function (t) {
          return a[t.getUTCDay()];
        },
        A: function (t) {
          return o[t.getUTCDay()];
        },
        b: function (t) {
          return c[t.getUTCMonth()];
        },
        B: function (t) {
          return u[t.getUTCMonth()];
        },
        c: null,
        d: c_,
        e: c_,
        f: d_,
        g: T_,
        G: S_,
        H: f_,
        I: s_,
        j: l_,
        L: h_,
        m: p_,
        M: g_,
        p: function (t) {
          return i[+(t.getUTCHours() >= 12)];
        },
        q: function (t) {
          return 1 + ~~(t.getUTCMonth() / 3);
        },
        Q: k_,
        s: C_,
        S: y_,
        u: v_,
        U: __,
        V: m_,
        w: x_,
        W: w_,
        x: null,
        X: null,
        y: M_,
        Y: A_,
        Z: E_,
        "%": N_
      },
      x = {
        a: function (t, n, e) {
          var r = d.exec(n.slice(e));
          return r ? (t.w = p.get(r[0].toLowerCase()), e + r[0].length) : -1;
        },
        A: function (t, n, e) {
          var r = l.exec(n.slice(e));
          return r ? (t.w = h.get(r[0].toLowerCase()), e + r[0].length) : -1;
        },
        b: function (t, n, e) {
          var r = v.exec(n.slice(e));
          return r ? (t.m = _.get(r[0].toLowerCase()), e + r[0].length) : -1;
        },
        B: function (t, n, e) {
          var r = g.exec(n.slice(e));
          return r ? (t.m = y.get(r[0].toLowerCase()), e + r[0].length) : -1;
        },
        c: function (t, e, r) {
          return T(t, n, e, r);
        },
        d: zv,
        e: zv,
        f: Uv,
        g: Nv,
        G: Ev,
        H: Dv,
        I: Dv,
        j: $v,
        L: qv,
        m: Pv,
        M: Rv,
        p: function (t, n, e) {
          var r = f.exec(n.slice(e));
          return r ? (t.p = s.get(r[0].toLowerCase()), e + r[0].length) : -1;
        },
        q: Cv,
        Q: Ov,
        s: Bv,
        S: Fv,
        u: Mv,
        U: Tv,
        V: Av,
        w: wv,
        W: Sv,
        x: function (t, n, r) {
          return T(t, e, n, r);
        },
        X: function (t, n, e) {
          return T(t, r, n, e);
        },
        y: Nv,
        Y: Ev,
        Z: kv,
        "%": Iv
      };
    function w(t, n) {
      return function (e) {
        var r,
          i,
          o,
          a = [],
          u = -1,
          c = 0,
          f = t.length;
        for (e instanceof Date || (e = new Date(+e)); ++u < f;) 37 === t.charCodeAt(u) && (a.push(t.slice(c, u)), null != (i = pv[r = t.charAt(++u)]) ? r = t.charAt(++u) : i = "e" === r ? " " : "0", (o = n[r]) && (r = o(e, i)), a.push(r), c = u + 1);
        return a.push(t.slice(c, u)), a.join("");
      };
    }
    function M(t, n) {
      return function (e) {
        var r,
          i,
          o = lv(1900, void 0, 1);
        if (T(o, t, e += "", 0) != e.length) return null;
        if ("Q" in o) return new Date(o.Q);
        if ("s" in o) return new Date(1e3 * o.s + ("L" in o ? o.L : 0));
        if (n && !("Z" in o) && (o.Z = 0), "p" in o && (o.H = o.H % 12 + 12 * o.p), void 0 === o.m && (o.m = "q" in o ? o.q : 0), "V" in o) {
          if (o.V < 1 || o.V > 53) return null;
          "w" in o || (o.w = 1), "Z" in o ? (i = (r = sv(lv(o.y, 0, 1))).getUTCDay(), r = i > 4 || 0 === i ? qy.ceil(r) : qy(r), r = yy.offset(r, 7 * (o.V - 1)), o.y = r.getUTCFullYear(), o.m = r.getUTCMonth(), o.d = r.getUTCDate() + (o.w + 6) % 7) : (i = (r = fv(lv(o.y, 0, 1))).getDay(), r = i > 4 || 0 === i ? wy.ceil(r) : wy(r), r = py.offset(r, 7 * (o.V - 1)), o.y = r.getFullYear(), o.m = r.getMonth(), o.d = r.getDate() + (o.w + 6) % 7);
        } else ("W" in o || "U" in o) && ("w" in o || (o.w = "u" in o ? o.u % 7 : "W" in o ? 1 : 0), i = "Z" in o ? sv(lv(o.y, 0, 1)).getUTCDay() : fv(lv(o.y, 0, 1)).getDay(), o.m = 0, o.d = "W" in o ? (o.w + 6) % 7 + 7 * o.W - (i + 5) % 7 : o.w + 7 * o.U - (i + 6) % 7);
        return "Z" in o ? (o.H += o.Z / 100 | 0, o.M += o.Z % 100, sv(o)) : fv(o);
      };
    }
    function T(t, n, e, r) {
      for (var i, o, a = 0, u = n.length, c = e.length; a < u;) {
        if (r >= c) return -1;
        if (37 === (i = n.charCodeAt(a++))) {
          if (i = n.charAt(a++), !(o = x[i in pv ? n.charAt(a++) : i]) || (r = o(t, e, r)) < 0) return -1;
        } else if (i != e.charCodeAt(r++)) return -1;
      }
      return r;
    }
    return b.x = w(e, b), b.X = w(r, b), b.c = w(n, b), m.x = w(e, m), m.X = w(r, m), m.c = w(n, m), {
      format: function (t) {
        var n = w(t += "", b);
        return n.toString = function () {
          return t;
        }, n;
      },
      parse: function (t) {
        var n = M(t += "", !1);
        return n.toString = function () {
          return t;
        }, n;
      },
      utcFormat: function (t) {
        var n = w(t += "", m);
        return n.toString = function () {
          return t;
        }, n;
      },
      utcParse: function (t) {
        var n = M(t += "", !0);
        return n.toString = function () {
          return t;
        }, n;
      }
    };
  }
  var dv,
    pv = {
      "-": "",
      _: " ",
      0: "0"
    },
    gv = /^\s*\d+/,
    yv = /^%/,
    vv = /[\\^$*+?|[\]().{}]/g;
  function _v(t, n, e) {
    var r = t < 0 ? "-" : "",
      i = (r ? -t : t) + "",
      o = i.length;
    return r + (o < e ? new Array(e - o + 1).join(n) + i : i);
  }
  function bv(t) {
    return t.replace(vv, "\\$&");
  }
  function mv(t) {
    return new RegExp("^(?:" + t.map(bv).join("|") + ")", "i");
  }
  function xv(t) {
    return new Map(t.map((t, n) => [t.toLowerCase(), n]));
  }
  function wv(t, n, e) {
    var r = gv.exec(n.slice(e, e + 1));
    return r ? (t.w = +r[0], e + r[0].length) : -1;
  }
  function Mv(t, n, e) {
    var r = gv.exec(n.slice(e, e + 1));
    return r ? (t.u = +r[0], e + r[0].length) : -1;
  }
  function Tv(t, n, e) {
    var r = gv.exec(n.slice(e, e + 2));
    return r ? (t.U = +r[0], e + r[0].length) : -1;
  }
  function Av(t, n, e) {
    var r = gv.exec(n.slice(e, e + 2));
    return r ? (t.V = +r[0], e + r[0].length) : -1;
  }
  function Sv(t, n, e) {
    var r = gv.exec(n.slice(e, e + 2));
    return r ? (t.W = +r[0], e + r[0].length) : -1;
  }
  function Ev(t, n, e) {
    var r = gv.exec(n.slice(e, e + 4));
    return r ? (t.y = +r[0], e + r[0].length) : -1;
  }
  function Nv(t, n, e) {
    var r = gv.exec(n.slice(e, e + 2));
    return r ? (t.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), e + r[0].length) : -1;
  }
  function kv(t, n, e) {
    var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(n.slice(e, e + 6));
    return r ? (t.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), e + r[0].length) : -1;
  }
  function Cv(t, n, e) {
    var r = gv.exec(n.slice(e, e + 1));
    return r ? (t.q = 3 * r[0] - 3, e + r[0].length) : -1;
  }
  function Pv(t, n, e) {
    var r = gv.exec(n.slice(e, e + 2));
    return r ? (t.m = r[0] - 1, e + r[0].length) : -1;
  }
  function zv(t, n, e) {
    var r = gv.exec(n.slice(e, e + 2));
    return r ? (t.d = +r[0], e + r[0].length) : -1;
  }
  function $v(t, n, e) {
    var r = gv.exec(n.slice(e, e + 3));
    return r ? (t.m = 0, t.d = +r[0], e + r[0].length) : -1;
  }
  function Dv(t, n, e) {
    var r = gv.exec(n.slice(e, e + 2));
    return r ? (t.H = +r[0], e + r[0].length) : -1;
  }
  function Rv(t, n, e) {
    var r = gv.exec(n.slice(e, e + 2));
    return r ? (t.M = +r[0], e + r[0].length) : -1;
  }
  function Fv(t, n, e) {
    var r = gv.exec(n.slice(e, e + 2));
    return r ? (t.S = +r[0], e + r[0].length) : -1;
  }
  function qv(t, n, e) {
    var r = gv.exec(n.slice(e, e + 3));
    return r ? (t.L = +r[0], e + r[0].length) : -1;
  }
  function Uv(t, n, e) {
    var r = gv.exec(n.slice(e, e + 6));
    return r ? (t.L = Math.floor(r[0] / 1e3), e + r[0].length) : -1;
  }
  function Iv(t, n, e) {
    var r = yv.exec(n.slice(e, e + 1));
    return r ? e + r[0].length : -1;
  }
  function Ov(t, n, e) {
    var r = gv.exec(n.slice(e));
    return r ? (t.Q = +r[0], e + r[0].length) : -1;
  }
  function Bv(t, n, e) {
    var r = gv.exec(n.slice(e));
    return r ? (t.s = +r[0], e + r[0].length) : -1;
  }
  function Yv(t, n) {
    return _v(t.getDate(), n, 2);
  }
  function Lv(t, n) {
    return _v(t.getHours(), n, 2);
  }
  function jv(t, n) {
    return _v(t.getHours() % 12 || 12, n, 2);
  }
  function Hv(t, n) {
    return _v(1 + py.count(tv(t), t), n, 3);
  }
  function Xv(t, n) {
    return _v(t.getMilliseconds(), n, 3);
  }
  function Gv(t, n) {
    return Xv(t, n) + "000";
  }
  function Vv(t, n) {
    return _v(t.getMonth() + 1, n, 2);
  }
  function Wv(t, n) {
    return _v(t.getMinutes(), n, 2);
  }
  function Zv(t, n) {
    return _v(t.getSeconds(), n, 2);
  }
  function Kv(t) {
    var n = t.getDay();
    return 0 === n ? 7 : n;
  }
  function Qv(t, n) {
    return _v(xy.count(tv(t) - 1, t), n, 2);
  }
  function Jv(t) {
    var n = t.getDay();
    return n >= 4 || 0 === n ? Ay(t) : Ay.ceil(t);
  }
  function t_(t, n) {
    return t = Jv(t), _v(Ay.count(tv(t), t) + (4 === tv(t).getDay()), n, 2);
  }
  function n_(t) {
    return t.getDay();
  }
  function e_(t, n) {
    return _v(wy.count(tv(t) - 1, t), n, 2);
  }
  function r_(t, n) {
    return _v(t.getFullYear() % 100, n, 2);
  }
  function i_(t, n) {
    return _v((t = Jv(t)).getFullYear() % 100, n, 2);
  }
  function o_(t, n) {
    return _v(t.getFullYear() % 1e4, n, 4);
  }
  function a_(t, n) {
    var e = t.getDay();
    return _v((t = e >= 4 || 0 === e ? Ay(t) : Ay.ceil(t)).getFullYear() % 1e4, n, 4);
  }
  function u_(t) {
    var n = t.getTimezoneOffset();
    return (n > 0 ? "-" : (n *= -1, "+")) + _v(n / 60 | 0, "0", 2) + _v(n % 60, "0", 2);
  }
  function c_(t, n) {
    return _v(t.getUTCDate(), n, 2);
  }
  function f_(t, n) {
    return _v(t.getUTCHours(), n, 2);
  }
  function s_(t, n) {
    return _v(t.getUTCHours() % 12 || 12, n, 2);
  }
  function l_(t, n) {
    return _v(1 + yy.count(ev(t), t), n, 3);
  }
  function h_(t, n) {
    return _v(t.getUTCMilliseconds(), n, 3);
  }
  function d_(t, n) {
    return h_(t, n) + "000";
  }
  function p_(t, n) {
    return _v(t.getUTCMonth() + 1, n, 2);
  }
  function g_(t, n) {
    return _v(t.getUTCMinutes(), n, 2);
  }
  function y_(t, n) {
    return _v(t.getUTCSeconds(), n, 2);
  }
  function v_(t) {
    var n = t.getUTCDay();
    return 0 === n ? 7 : n;
  }
  function __(t, n) {
    return _v(Fy.count(ev(t) - 1, t), n, 2);
  }
  function b_(t) {
    var n = t.getUTCDay();
    return n >= 4 || 0 === n ? Oy(t) : Oy.ceil(t);
  }
  function m_(t, n) {
    return t = b_(t), _v(Oy.count(ev(t), t) + (4 === ev(t).getUTCDay()), n, 2);
  }
  function x_(t) {
    return t.getUTCDay();
  }
  function w_(t, n) {
    return _v(qy.count(ev(t) - 1, t), n, 2);
  }
  function M_(t, n) {
    return _v(t.getUTCFullYear() % 100, n, 2);
  }
  function T_(t, n) {
    return _v((t = b_(t)).getUTCFullYear() % 100, n, 2);
  }
  function A_(t, n) {
    return _v(t.getUTCFullYear() % 1e4, n, 4);
  }
  function S_(t, n) {
    var e = t.getUTCDay();
    return _v((t = e >= 4 || 0 === e ? Oy(t) : Oy.ceil(t)).getUTCFullYear() % 1e4, n, 4);
  }
  function E_() {
    return "+0000";
  }
  function N_() {
    return "%";
  }
  function k_(t) {
    return +t;
  }
  function C_(t) {
    return Math.floor(+t / 1e3);
  }
  function P_(n) {
    return dv = hv(n), t.timeFormat = dv.format, t.timeParse = dv.parse, t.utcFormat = dv.utcFormat, t.utcParse = dv.utcParse, dv;
  }
  t.timeFormat = void 0, t.timeParse = void 0, t.utcFormat = void 0, t.utcParse = void 0, P_({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });
  var z_ = "%Y-%m-%dT%H:%M:%S.%LZ";
  var $_ = Date.prototype.toISOString ? function (t) {
      return t.toISOString();
    } : t.utcFormat(z_),
    D_ = $_;
  var R_ = +new Date("2000-01-01T00:00:00.000Z") ? function (t) {
      var n = new Date(t);
      return isNaN(n) ? null : n;
    } : t.utcParse(z_),
    F_ = R_;
  function q_(t) {
    return new Date(t);
  }
  function U_(t) {
    return t instanceof Date ? +t : +new Date(+t);
  }
  function I_(t, n, e, r, i, o, a, u, c, f) {
    var s = Sg(),
      l = s.invert,
      h = s.domain,
      d = f(".%L"),
      p = f(":%S"),
      g = f("%I:%M"),
      y = f("%I %p"),
      v = f("%a %d"),
      _ = f("%b %d"),
      b = f("%B"),
      m = f("%Y");
    function x(t) {
      return (c(t) < t ? d : u(t) < t ? p : a(t) < t ? g : o(t) < t ? y : r(t) < t ? i(t) < t ? v : _ : e(t) < t ? b : m)(t);
    }
    return s.invert = function (t) {
      return new Date(l(t));
    }, s.domain = function (t) {
      return arguments.length ? h(Array.from(t, U_)) : h().map(q_);
    }, s.ticks = function (n) {
      var e = h();
      return t(e[0], e[e.length - 1], null == n ? 10 : n);
    }, s.tickFormat = function (t, n) {
      return null == n ? x : f(n);
    }, s.nice = function (t) {
      var e = h();
      return t && "function" == typeof t.range || (t = n(e[0], e[e.length - 1], null == t ? 10 : t)), t ? h(kg(e, t)) : s;
    }, s.copy = function () {
      return Tg(s, I_(t, n, e, r, i, o, a, u, c, f));
    }, s;
  }
  function O_() {
    var t,
      n,
      e,
      r,
      i,
      o = 0,
      a = 1,
      u = mg,
      c = !1;
    function f(n) {
      return null == n || isNaN(n = +n) ? i : u(0 === e ? .5 : (n = (r(n) - t) * e, c ? Math.max(0, Math.min(1, n)) : n));
    }
    function s(t) {
      return function (n) {
        var e, r;
        return arguments.length ? ([e, r] = n, u = t(e, r), f) : [u(0), u(1)];
      };
    }
    return f.domain = function (i) {
      return arguments.length ? ([o, a] = i, t = r(o = +o), n = r(a = +a), e = t === n ? 0 : 1 / (n - t), f) : [o, a];
    }, f.clamp = function (t) {
      return arguments.length ? (c = !!t, f) : c;
    }, f.interpolator = function (t) {
      return arguments.length ? (u = t, f) : u;
    }, f.range = s(Gr), f.rangeRound = s(Vr), f.unknown = function (t) {
      return arguments.length ? (i = t, f) : i;
    }, function (i) {
      return r = i, t = i(o), n = i(a), e = t === n ? 0 : 1 / (n - t), f;
    };
  }
  function B_(t, n) {
    return n.domain(t.domain()).interpolator(t.interpolator()).clamp(t.clamp()).unknown(t.unknown());
  }
  function Y_() {
    var t = Lg(O_());
    return t.copy = function () {
      return B_(t, Y_()).exponent(t.exponent());
    }, dg.apply(t, arguments);
  }
  function L_() {
    var t,
      n,
      e,
      r,
      i,
      o,
      a,
      u = 0,
      c = .5,
      f = 1,
      s = 1,
      l = mg,
      h = !1;
    function d(t) {
      return isNaN(t = +t) ? a : (t = .5 + ((t = +o(t)) - n) * (s * t < s * n ? r : i), l(h ? Math.max(0, Math.min(1, t)) : t));
    }
    function p(t) {
      return function (n) {
        var e, r, i;
        return arguments.length ? ([e, r, i] = n, l = di(t, [e, r, i]), d) : [l(0), l(.5), l(1)];
      };
    }
    return d.domain = function (a) {
      return arguments.length ? ([u, c, f] = a, t = o(u = +u), n = o(c = +c), e = o(f = +f), r = t === n ? 0 : .5 / (n - t), i = n === e ? 0 : .5 / (e - n), s = n < t ? -1 : 1, d) : [u, c, f];
    }, d.clamp = function (t) {
      return arguments.length ? (h = !!t, d) : h;
    }, d.interpolator = function (t) {
      return arguments.length ? (l = t, d) : l;
    }, d.range = p(Gr), d.rangeRound = p(Vr), d.unknown = function (t) {
      return arguments.length ? (a = t, d) : a;
    }, function (a) {
      return o = a, t = a(u), n = a(c), e = a(f), r = t === n ? 0 : .5 / (n - t), i = n === e ? 0 : .5 / (e - n), s = n < t ? -1 : 1, d;
    };
  }
  function j_() {
    var t = Lg(L_());
    return t.copy = function () {
      return B_(t, j_()).exponent(t.exponent());
    }, dg.apply(t, arguments);
  }
  function H_(t) {
    for (var n = t.length / 6 | 0, e = new Array(n), r = 0; r < n;) e[r] = "#" + t.slice(6 * r, 6 * ++r);
    return e;
  }
  var X_ = H_("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"),
    G_ = H_("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"),
    V_ = H_("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"),
    W_ = H_("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"),
    Z_ = H_("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"),
    K_ = H_("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"),
    Q_ = H_("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"),
    J_ = H_("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"),
    tb = H_("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"),
    nb = H_("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab"),
    eb = t => Fr(t[t.length - 1]),
    rb = new Array(3).concat("d8b365f5f5f55ab4ac", "a6611adfc27d80cdc1018571", "a6611adfc27df5f5f580cdc1018571", "8c510ad8b365f6e8c3c7eae55ab4ac01665e", "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e", "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e", "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e", "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30", "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30").map(H_),
    ib = eb(rb),
    ob = new Array(3).concat("af8dc3f7f7f77fbf7b", "7b3294c2a5cfa6dba0008837", "7b3294c2a5cff7f7f7a6dba0008837", "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837", "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837", "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837", "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837", "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b", "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b").map(H_),
    ab = eb(ob),
    ub = new Array(3).concat("e9a3c9f7f7f7a1d76a", "d01c8bf1b6dab8e1864dac26", "d01c8bf1b6daf7f7f7b8e1864dac26", "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221", "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221", "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221", "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221", "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419", "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419").map(H_),
    cb = eb(ub),
    fb = new Array(3).concat("998ec3f7f7f7f1a340", "5e3c99b2abd2fdb863e66101", "5e3c99b2abd2f7f7f7fdb863e66101", "542788998ec3d8daebfee0b6f1a340b35806", "542788998ec3d8daebf7f7f7fee0b6f1a340b35806", "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806", "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806", "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08", "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08").map(H_),
    sb = eb(fb),
    lb = new Array(3).concat("ef8a62f7f7f767a9cf", "ca0020f4a58292c5de0571b0", "ca0020f4a582f7f7f792c5de0571b0", "b2182bef8a62fddbc7d1e5f067a9cf2166ac", "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac", "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac", "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac", "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061", "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061").map(H_),
    hb = eb(lb),
    db = new Array(3).concat("ef8a62ffffff999999", "ca0020f4a582bababa404040", "ca0020f4a582ffffffbababa404040", "b2182bef8a62fddbc7e0e0e09999994d4d4d", "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d", "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d", "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d", "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a", "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a").map(H_),
    pb = eb(db),
    gb = new Array(3).concat("fc8d59ffffbf91bfdb", "d7191cfdae61abd9e92c7bb6", "d7191cfdae61ffffbfabd9e92c7bb6", "d73027fc8d59fee090e0f3f891bfdb4575b4", "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4", "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4", "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4", "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695", "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695").map(H_),
    yb = eb(gb),
    vb = new Array(3).concat("fc8d59ffffbf91cf60", "d7191cfdae61a6d96a1a9641", "d7191cfdae61ffffbfa6d96a1a9641", "d73027fc8d59fee08bd9ef8b91cf601a9850", "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850", "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850", "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850", "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837", "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837").map(H_),
    _b = eb(vb),
    bb = new Array(3).concat("fc8d59ffffbf99d594", "d7191cfdae61abdda42b83ba", "d7191cfdae61ffffbfabdda42b83ba", "d53e4ffc8d59fee08be6f59899d5943288bd", "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd", "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd", "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd", "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2", "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2").map(H_),
    mb = eb(bb),
    xb = new Array(3).concat("e5f5f999d8c92ca25f", "edf8fbb2e2e266c2a4238b45", "edf8fbb2e2e266c2a42ca25f006d2c", "edf8fbccece699d8c966c2a42ca25f006d2c", "edf8fbccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b").map(H_),
    wb = eb(xb),
    Mb = new Array(3).concat("e0ecf49ebcda8856a7", "edf8fbb3cde38c96c688419d", "edf8fbb3cde38c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b").map(H_),
    Tb = eb(Mb),
    Ab = new Array(3).concat("e0f3dba8ddb543a2ca", "f0f9e8bae4bc7bccc42b8cbe", "f0f9e8bae4bc7bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081").map(H_),
    Sb = eb(Ab),
    Eb = new Array(3).concat("fee8c8fdbb84e34a33", "fef0d9fdcc8afc8d59d7301f", "fef0d9fdcc8afc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000").map(H_),
    Nb = eb(Eb),
    kb = new Array(3).concat("ece2f0a6bddb1c9099", "f6eff7bdc9e167a9cf02818a", "f6eff7bdc9e167a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636").map(H_),
    Cb = eb(kb),
    Pb = new Array(3).concat("ece7f2a6bddb2b8cbe", "f1eef6bdc9e174a9cf0570b0", "f1eef6bdc9e174a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858").map(H_),
    zb = eb(Pb),
    $b = new Array(3).concat("e7e1efc994c7dd1c77", "f1eef6d7b5d8df65b0ce1256", "f1eef6d7b5d8df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f").map(H_),
    Db = eb($b),
    Rb = new Array(3).concat("fde0ddfa9fb5c51b8a", "feebe2fbb4b9f768a1ae017e", "feebe2fbb4b9f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a").map(H_),
    Fb = eb(Rb),
    qb = new Array(3).concat("edf8b17fcdbb2c7fb8", "ffffcca1dab441b6c4225ea8", "ffffcca1dab441b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58").map(H_),
    Ub = eb(qb),
    Ib = new Array(3).concat("f7fcb9addd8e31a354", "ffffccc2e69978c679238443", "ffffccc2e69978c67931a354006837", "ffffccd9f0a3addd8e78c67931a354006837", "ffffccd9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529").map(H_),
    Ob = eb(Ib),
    Bb = new Array(3).concat("fff7bcfec44fd95f0e", "ffffd4fed98efe9929cc4c02", "ffffd4fed98efe9929d95f0e993404", "ffffd4fee391fec44ffe9929d95f0e993404", "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506").map(H_),
    Yb = eb(Bb),
    Lb = new Array(3).concat("ffeda0feb24cf03b20", "ffffb2fecc5cfd8d3ce31a1c", "ffffb2fecc5cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026").map(H_),
    jb = eb(Lb),
    Hb = new Array(3).concat("deebf79ecae13182bd", "eff3ffbdd7e76baed62171b5", "eff3ffbdd7e76baed63182bd08519c", "eff3ffc6dbef9ecae16baed63182bd08519c", "eff3ffc6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b").map(H_),
    Xb = eb(Hb),
    Gb = new Array(3).concat("e5f5e0a1d99b31a354", "edf8e9bae4b374c476238b45", "edf8e9bae4b374c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b").map(H_),
    Vb = eb(Gb),
    Wb = new Array(3).concat("f0f0f0bdbdbd636363", "f7f7f7cccccc969696525252", "f7f7f7cccccc969696636363252525", "f7f7f7d9d9d9bdbdbd969696636363252525", "f7f7f7d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000").map(H_),
    Zb = eb(Wb),
    Kb = new Array(3).concat("efedf5bcbddc756bb1", "f2f0f7cbc9e29e9ac86a51a3", "f2f0f7cbc9e29e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d").map(H_),
    Qb = eb(Kb),
    Jb = new Array(3).concat("fee0d2fc9272de2d26", "fee5d9fcae91fb6a4acb181d", "fee5d9fcae91fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d").map(H_),
    tm = eb(Jb),
    nm = new Array(3).concat("fee6cefdae6be6550d", "feeddefdbe85fd8d3cd94701", "feeddefdbe85fd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704").map(H_),
    em = eb(nm);
  var rm = hi(Tr(300, .5, 0), Tr(-240, .5, 1)),
    im = hi(Tr(-100, .75, .35), Tr(80, 1.5, .8)),
    om = hi(Tr(260, .75, .35), Tr(80, 1.5, .8)),
    am = Tr();
  var um = Fe(),
    cm = Math.PI / 3,
    fm = 2 * Math.PI / 3;
  function sm(t) {
    var n = t.length;
    return function (e) {
      return t[Math.max(0, Math.min(n - 1, Math.floor(e * n)))];
    };
  }
  var lm = sm(H_("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")),
    hm = sm(H_("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")),
    dm = sm(H_("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")),
    pm = sm(H_("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
  function gm(t) {
    return function () {
      return t;
    };
  }
  const ym = Math.abs,
    vm = Math.atan2,
    _m = Math.cos,
    bm = Math.max,
    mm = Math.min,
    xm = Math.sin,
    wm = Math.sqrt,
    Mm = 1e-12,
    Tm = Math.PI,
    Am = Tm / 2,
    Sm = 2 * Tm;
  function Em(t) {
    return t >= 1 ? Am : t <= -1 ? -Am : Math.asin(t);
  }
  function Nm(t) {
    let n = 3;
    return t.digits = function (e) {
      if (!arguments.length) return n;
      if (null == e) n = null;else {
        const t = Math.floor(e);
        if (!(t >= 0)) throw new RangeError(`invalid digits: ${e}`);
        n = t;
      }
      return t;
    }, () => new Ua(n);
  }
  function km(t) {
    return t.innerRadius;
  }
  function Cm(t) {
    return t.outerRadius;
  }
  function Pm(t) {
    return t.startAngle;
  }
  function zm(t) {
    return t.endAngle;
  }
  function $m(t) {
    return t && t.padAngle;
  }
  function Dm(t, n, e, r, i, o, a) {
    var u = t - e,
      c = n - r,
      f = (a ? o : -o) / wm(u * u + c * c),
      s = f * c,
      l = -f * u,
      h = t + s,
      d = n + l,
      p = e + s,
      g = r + l,
      y = (h + p) / 2,
      v = (d + g) / 2,
      _ = p - h,
      b = g - d,
      m = _ * _ + b * b,
      x = i - o,
      w = h * g - p * d,
      M = (b < 0 ? -1 : 1) * wm(bm(0, x * x * m - w * w)),
      T = (w * b - _ * M) / m,
      A = (-w * _ - b * M) / m,
      S = (w * b + _ * M) / m,
      E = (-w * _ + b * M) / m,
      N = T - y,
      k = A - v,
      C = S - y,
      P = E - v;
    return N * N + k * k > C * C + P * P && (T = S, A = E), {
      cx: T,
      cy: A,
      x01: -s,
      y01: -l,
      x11: T * (i / x - 1),
      y11: A * (i / x - 1)
    };
  }
  var Rm = Array.prototype.slice;
  function Fm(t) {
    return "object" == typeof t && "length" in t ? t : Array.from(t);
  }
  function qm(t) {
    this._context = t;
  }
  function Um(t) {
    return new qm(t);
  }
  function Im(t) {
    return t[0];
  }
  function Om(t) {
    return t[1];
  }
  function Bm(t, n) {
    var e = gm(!0),
      r = null,
      i = Um,
      o = null,
      a = Nm(u);
    function u(u) {
      var c,
        f,
        s,
        l = (u = Fm(u)).length,
        h = !1;
      for (null == r && (o = i(s = a())), c = 0; c <= l; ++c) !(c < l && e(f = u[c], c, u)) === h && ((h = !h) ? o.lineStart() : o.lineEnd()), h && o.point(+t(f, c, u), +n(f, c, u));
      if (s) return o = null, s + "" || null;
    }
    return t = "function" == typeof t ? t : void 0 === t ? Im : gm(t), n = "function" == typeof n ? n : void 0 === n ? Om : gm(n), u.x = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : gm(+n), u) : t;
    }, u.y = function (t) {
      return arguments.length ? (n = "function" == typeof t ? t : gm(+t), u) : n;
    }, u.defined = function (t) {
      return arguments.length ? (e = "function" == typeof t ? t : gm(!!t), u) : e;
    }, u.curve = function (t) {
      return arguments.length ? (i = t, null != r && (o = i(r)), u) : i;
    }, u.context = function (t) {
      return arguments.length ? (null == t ? r = o = null : o = i(r = t), u) : r;
    }, u;
  }
  function Ym(t, n, e) {
    var r = null,
      i = gm(!0),
      o = null,
      a = Um,
      u = null,
      c = Nm(f);
    function f(f) {
      var s,
        l,
        h,
        d,
        p,
        g = (f = Fm(f)).length,
        y = !1,
        v = new Array(g),
        _ = new Array(g);
      for (null == o && (u = a(p = c())), s = 0; s <= g; ++s) {
        if (!(s < g && i(d = f[s], s, f)) === y) if (y = !y) l = s, u.areaStart(), u.lineStart();else {
          for (u.lineEnd(), u.lineStart(), h = s - 1; h >= l; --h) u.point(v[h], _[h]);
          u.lineEnd(), u.areaEnd();
        }
        y && (v[s] = +t(d, s, f), _[s] = +n(d, s, f), u.point(r ? +r(d, s, f) : v[s], e ? +e(d, s, f) : _[s]));
      }
      if (p) return u = null, p + "" || null;
    }
    function s() {
      return Bm().defined(i).curve(a).context(o);
    }
    return t = "function" == typeof t ? t : void 0 === t ? Im : gm(+t), n = "function" == typeof n ? n : gm(void 0 === n ? 0 : +n), e = "function" == typeof e ? e : void 0 === e ? Om : gm(+e), f.x = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : gm(+n), r = null, f) : t;
    }, f.x0 = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : gm(+n), f) : t;
    }, f.x1 = function (t) {
      return arguments.length ? (r = null == t ? null : "function" == typeof t ? t : gm(+t), f) : r;
    }, f.y = function (t) {
      return arguments.length ? (n = "function" == typeof t ? t : gm(+t), e = null, f) : n;
    }, f.y0 = function (t) {
      return arguments.length ? (n = "function" == typeof t ? t : gm(+t), f) : n;
    }, f.y1 = function (t) {
      return arguments.length ? (e = null == t ? null : "function" == typeof t ? t : gm(+t), f) : e;
    }, f.lineX0 = f.lineY0 = function () {
      return s().x(t).y(n);
    }, f.lineY1 = function () {
      return s().x(t).y(e);
    }, f.lineX1 = function () {
      return s().x(r).y(n);
    }, f.defined = function (t) {
      return arguments.length ? (i = "function" == typeof t ? t : gm(!!t), f) : i;
    }, f.curve = function (t) {
      return arguments.length ? (a = t, null != o && (u = a(o)), f) : a;
    }, f.context = function (t) {
      return arguments.length ? (null == t ? o = u = null : u = a(o = t), f) : o;
    }, f;
  }
  function Lm(t, n) {
    return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN;
  }
  function jm(t) {
    return t;
  }
  qm.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._point = 0;
    },
    lineEnd: function () {
      (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function (t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
          break;
        case 1:
          this._point = 2;
        default:
          this._context.lineTo(t, n);
      }
    }
  };
  var Hm = Gm(Um);
  function Xm(t) {
    this._curve = t;
  }
  function Gm(t) {
    function n(n) {
      return new Xm(t(n));
    }
    return n._curve = t, n;
  }
  function Vm(t) {
    var n = t.curve;
    return t.angle = t.x, delete t.x, t.radius = t.y, delete t.y, t.curve = function (t) {
      return arguments.length ? n(Gm(t)) : n()._curve;
    }, t;
  }
  function Wm() {
    return Vm(Bm().curve(Hm));
  }
  function Zm() {
    var t = Ym().curve(Hm),
      n = t.curve,
      e = t.lineX0,
      r = t.lineX1,
      i = t.lineY0,
      o = t.lineY1;
    return t.angle = t.x, delete t.x, t.startAngle = t.x0, delete t.x0, t.endAngle = t.x1, delete t.x1, t.radius = t.y, delete t.y, t.innerRadius = t.y0, delete t.y0, t.outerRadius = t.y1, delete t.y1, t.lineStartAngle = function () {
      return Vm(e());
    }, delete t.lineX0, t.lineEndAngle = function () {
      return Vm(r());
    }, delete t.lineX1, t.lineInnerRadius = function () {
      return Vm(i());
    }, delete t.lineY0, t.lineOuterRadius = function () {
      return Vm(o());
    }, delete t.lineY1, t.curve = function (t) {
      return arguments.length ? n(Gm(t)) : n()._curve;
    }, t;
  }
  function Km(t, n) {
    return [(n = +n) * Math.cos(t -= Math.PI / 2), n * Math.sin(t)];
  }
  Xm.prototype = {
    areaStart: function () {
      this._curve.areaStart();
    },
    areaEnd: function () {
      this._curve.areaEnd();
    },
    lineStart: function () {
      this._curve.lineStart();
    },
    lineEnd: function () {
      this._curve.lineEnd();
    },
    point: function (t, n) {
      this._curve.point(n * Math.sin(t), n * -Math.cos(t));
    }
  };
  class Qm {
    constructor(t, n) {
      this._context = t, this._x = n;
    }
    areaStart() {
      this._line = 0;
    }
    areaEnd() {
      this._line = NaN;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
      (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    }
    point(t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
          break;
        case 1:
          this._point = 2;
        default:
          this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);
      }
      this._x0 = t, this._y0 = n;
    }
  }
  class Jm {
    constructor(t) {
      this._context = t;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {}
    point(t, n) {
      if (t = +t, n = +n, 0 === this._point) this._point = 1;else {
        const e = Km(this._x0, this._y0),
          r = Km(this._x0, this._y0 = (this._y0 + n) / 2),
          i = Km(t, this._y0),
          o = Km(t, n);
        this._context.moveTo(...e), this._context.bezierCurveTo(...r, ...i, ...o);
      }
      this._x0 = t, this._y0 = n;
    }
  }
  function tx(t) {
    return new Qm(t, !0);
  }
  function nx(t) {
    return new Qm(t, !1);
  }
  function ex(t) {
    return new Jm(t);
  }
  function rx(t) {
    return t.source;
  }
  function ix(t) {
    return t.target;
  }
  function ox(t) {
    let n = rx,
      e = ix,
      r = Im,
      i = Om,
      o = null,
      a = null,
      u = Nm(c);
    function c() {
      let c;
      const f = Rm.call(arguments),
        s = n.apply(this, f),
        l = e.apply(this, f);
      if (null == o && (a = t(c = u())), a.lineStart(), f[0] = s, a.point(+r.apply(this, f), +i.apply(this, f)), f[0] = l, a.point(+r.apply(this, f), +i.apply(this, f)), a.lineEnd(), c) return a = null, c + "" || null;
    }
    return c.source = function (t) {
      return arguments.length ? (n = t, c) : n;
    }, c.target = function (t) {
      return arguments.length ? (e = t, c) : e;
    }, c.x = function (t) {
      return arguments.length ? (r = "function" == typeof t ? t : gm(+t), c) : r;
    }, c.y = function (t) {
      return arguments.length ? (i = "function" == typeof t ? t : gm(+t), c) : i;
    }, c.context = function (n) {
      return arguments.length ? (null == n ? o = a = null : a = t(o = n), c) : o;
    }, c;
  }
  const ax = wm(3);
  var ux = {
      draw(t, n) {
        const e = .59436 * wm(n + mm(n / 28, .75)),
          r = e / 2,
          i = r * ax;
        t.moveTo(0, e), t.lineTo(0, -e), t.moveTo(-i, -r), t.lineTo(i, r), t.moveTo(-i, r), t.lineTo(i, -r);
      }
    },
    cx = {
      draw(t, n) {
        const e = wm(n / Tm);
        t.moveTo(e, 0), t.arc(0, 0, e, 0, Sm);
      }
    },
    fx = {
      draw(t, n) {
        const e = wm(n / 5) / 2;
        t.moveTo(-3 * e, -e), t.lineTo(-e, -e), t.lineTo(-e, -3 * e), t.lineTo(e, -3 * e), t.lineTo(e, -e), t.lineTo(3 * e, -e), t.lineTo(3 * e, e), t.lineTo(e, e), t.lineTo(e, 3 * e), t.lineTo(-e, 3 * e), t.lineTo(-e, e), t.lineTo(-3 * e, e), t.closePath();
      }
    };
  const sx = wm(1 / 3),
    lx = 2 * sx;
  var hx = {
      draw(t, n) {
        const e = wm(n / lx),
          r = e * sx;
        t.moveTo(0, -e), t.lineTo(r, 0), t.lineTo(0, e), t.lineTo(-r, 0), t.closePath();
      }
    },
    dx = {
      draw(t, n) {
        const e = .62625 * wm(n);
        t.moveTo(0, -e), t.lineTo(e, 0), t.lineTo(0, e), t.lineTo(-e, 0), t.closePath();
      }
    },
    px = {
      draw(t, n) {
        const e = .87559 * wm(n - mm(n / 7, 2));
        t.moveTo(-e, 0), t.lineTo(e, 0), t.moveTo(0, e), t.lineTo(0, -e);
      }
    },
    gx = {
      draw(t, n) {
        const e = wm(n),
          r = -e / 2;
        t.rect(r, r, e, e);
      }
    },
    yx = {
      draw(t, n) {
        const e = .4431 * wm(n);
        t.moveTo(e, e), t.lineTo(e, -e), t.lineTo(-e, -e), t.lineTo(-e, e), t.closePath();
      }
    };
  const vx = xm(Tm / 10) / xm(7 * Tm / 10),
    _x = xm(Sm / 10) * vx,
    bx = -_m(Sm / 10) * vx;
  var mx = {
    draw(t, n) {
      const e = wm(.8908130915292852 * n),
        r = _x * e,
        i = bx * e;
      t.moveTo(0, -e), t.lineTo(r, i);
      for (let n = 1; n < 5; ++n) {
        const o = Sm * n / 5,
          a = _m(o),
          u = xm(o);
        t.lineTo(u * e, -a * e), t.lineTo(a * r - u * i, u * r + a * i);
      }
      t.closePath();
    }
  };
  const xx = wm(3);
  var wx = {
    draw(t, n) {
      const e = -wm(n / (3 * xx));
      t.moveTo(0, 2 * e), t.lineTo(-xx * e, -e), t.lineTo(xx * e, -e), t.closePath();
    }
  };
  const Mx = wm(3);
  var Tx = {
    draw(t, n) {
      const e = .6824 * wm(n),
        r = e / 2,
        i = e * Mx / 2;
      t.moveTo(0, -e), t.lineTo(i, r), t.lineTo(-i, r), t.closePath();
    }
  };
  const Ax = -.5,
    Sx = wm(3) / 2,
    Ex = 1 / wm(12),
    Nx = 3 * (Ex / 2 + 1);
  var kx = {
      draw(t, n) {
        const e = wm(n / Nx),
          r = e / 2,
          i = e * Ex,
          o = r,
          a = e * Ex + e,
          u = -o,
          c = a;
        t.moveTo(r, i), t.lineTo(o, a), t.lineTo(u, c), t.lineTo(Ax * r - Sx * i, Sx * r + Ax * i), t.lineTo(Ax * o - Sx * a, Sx * o + Ax * a), t.lineTo(Ax * u - Sx * c, Sx * u + Ax * c), t.lineTo(Ax * r + Sx * i, Ax * i - Sx * r), t.lineTo(Ax * o + Sx * a, Ax * a - Sx * o), t.lineTo(Ax * u + Sx * c, Ax * c - Sx * u), t.closePath();
      }
    },
    Cx = {
      draw(t, n) {
        const e = .6189 * wm(n - mm(n / 6, 1.7));
        t.moveTo(-e, -e), t.lineTo(e, e), t.moveTo(-e, e), t.lineTo(e, -e);
      }
    };
  const Px = [cx, fx, hx, gx, mx, wx, kx],
    zx = [cx, px, Cx, Tx, ux, yx, dx];
  function $x() {}
  function Dx(t, n, e) {
    t._context.bezierCurveTo((2 * t._x0 + t._x1) / 3, (2 * t._y0 + t._y1) / 3, (t._x0 + 2 * t._x1) / 3, (t._y0 + 2 * t._y1) / 3, (t._x0 + 4 * t._x1 + n) / 6, (t._y0 + 4 * t._y1 + e) / 6);
  }
  function Rx(t) {
    this._context = t;
  }
  function Fx(t) {
    this._context = t;
  }
  function qx(t) {
    this._context = t;
  }
  function Ux(t, n) {
    this._basis = new Rx(t), this._beta = n;
  }
  Rx.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 3:
          Dx(this, this._x1, this._y1);
        case 2:
          this._context.lineTo(this._x1, this._y1);
      }
      (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function (t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
        default:
          Dx(this, t, n);
      }
      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n;
    }
  }, Fx.prototype = {
    areaStart: $x,
    areaEnd: $x,
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 1:
          this._context.moveTo(this._x2, this._y2), this._context.closePath();
          break;
        case 2:
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
          break;
        case 3:
          this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
      }
    },
    point: function (t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1, this._x2 = t, this._y2 = n;
          break;
        case 1:
          this._point = 2, this._x3 = t, this._y3 = n;
          break;
        case 2:
          this._point = 3, this._x4 = t, this._y4 = n, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + n) / 6);
          break;
        default:
          Dx(this, t, n);
      }
      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n;
    }
  }, qx.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
    },
    lineEnd: function () {
      (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function (t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          var e = (this._x0 + 4 * this._x1 + t) / 6,
            r = (this._y0 + 4 * this._y1 + n) / 6;
          this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r);
          break;
        case 3:
          this._point = 4;
        default:
          Dx(this, t, n);
      }
      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n;
    }
  }, Ux.prototype = {
    lineStart: function () {
      this._x = [], this._y = [], this._basis.lineStart();
    },
    lineEnd: function () {
      var t = this._x,
        n = this._y,
        e = t.length - 1;
      if (e > 0) for (var r, i = t[0], o = n[0], a = t[e] - i, u = n[e] - o, c = -1; ++c <= e;) r = c / e, this._basis.point(this._beta * t[c] + (1 - this._beta) * (i + r * a), this._beta * n[c] + (1 - this._beta) * (o + r * u));
      this._x = this._y = null, this._basis.lineEnd();
    },
    point: function (t, n) {
      this._x.push(+t), this._y.push(+n);
    }
  };
  var Ix = function t(n) {
    function e(t) {
      return 1 === n ? new Rx(t) : new Ux(t, n);
    }
    return e.beta = function (n) {
      return t(+n);
    }, e;
  }(.85);
  function Ox(t, n, e) {
    t._context.bezierCurveTo(t._x1 + t._k * (t._x2 - t._x0), t._y1 + t._k * (t._y2 - t._y0), t._x2 + t._k * (t._x1 - n), t._y2 + t._k * (t._y1 - e), t._x2, t._y2);
  }
  function Bx(t, n) {
    this._context = t, this._k = (1 - n) / 6;
  }
  Bx.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          Ox(this, this._x1, this._y1);
      }
      (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function (t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
          break;
        case 1:
          this._point = 2, this._x1 = t, this._y1 = n;
          break;
        case 2:
          this._point = 3;
        default:
          Ox(this, t, n);
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
    }
  };
  var Yx = function t(n) {
    function e(t) {
      return new Bx(t, n);
    }
    return e.tension = function (n) {
      return t(+n);
    }, e;
  }(0);
  function Lx(t, n) {
    this._context = t, this._k = (1 - n) / 6;
  }
  Lx.prototype = {
    areaStart: $x,
    areaEnd: $x,
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 1:
          this._context.moveTo(this._x3, this._y3), this._context.closePath();
          break;
        case 2:
          this._context.lineTo(this._x3, this._y3), this._context.closePath();
          break;
        case 3:
          this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
      }
    },
    point: function (t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1, this._x3 = t, this._y3 = n;
          break;
        case 1:
          this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = n);
          break;
        case 2:
          this._point = 3, this._x5 = t, this._y5 = n;
          break;
        default:
          Ox(this, t, n);
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
    }
  };
  var jx = function t(n) {
    function e(t) {
      return new Lx(t, n);
    }
    return e.tension = function (n) {
      return t(+n);
    }, e;
  }(0);
  function Hx(t, n) {
    this._context = t, this._k = (1 - n) / 6;
  }
  Hx.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
    },
    lineEnd: function () {
      (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function (t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        default:
          Ox(this, t, n);
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
    }
  };
  var Xx = function t(n) {
    function e(t) {
      return new Hx(t, n);
    }
    return e.tension = function (n) {
      return t(+n);
    }, e;
  }(0);
  function Gx(t, n, e) {
    var r = t._x1,
      i = t._y1,
      o = t._x2,
      a = t._y2;
    if (t._l01_a > Mm) {
      var u = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a,
        c = 3 * t._l01_a * (t._l01_a + t._l12_a);
      r = (r * u - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / c, i = (i * u - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / c;
    }
    if (t._l23_a > Mm) {
      var f = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a,
        s = 3 * t._l23_a * (t._l23_a + t._l12_a);
      o = (o * f + t._x1 * t._l23_2a - n * t._l12_2a) / s, a = (a * f + t._y1 * t._l23_2a - e * t._l12_2a) / s;
    }
    t._context.bezierCurveTo(r, i, o, a, t._x2, t._y2);
  }
  function Vx(t, n) {
    this._context = t, this._alpha = n;
  }
  Vx.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          this.point(this._x2, this._y2);
      }
      (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function (t, n) {
      if (t = +t, n = +n, this._point) {
        var e = this._x2 - t,
          r = this._y2 - n;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + r * r, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
        default:
          Gx(this, t, n);
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
    }
  };
  var Wx = function t(n) {
    function e(t) {
      return n ? new Vx(t, n) : new Bx(t, 0);
    }
    return e.alpha = function (n) {
      return t(+n);
    }, e;
  }(.5);
  function Zx(t, n) {
    this._context = t, this._alpha = n;
  }
  Zx.prototype = {
    areaStart: $x,
    areaEnd: $x,
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 1:
          this._context.moveTo(this._x3, this._y3), this._context.closePath();
          break;
        case 2:
          this._context.lineTo(this._x3, this._y3), this._context.closePath();
          break;
        case 3:
          this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
      }
    },
    point: function (t, n) {
      if (t = +t, n = +n, this._point) {
        var e = this._x2 - t,
          r = this._y2 - n;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + r * r, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1, this._x3 = t, this._y3 = n;
          break;
        case 1:
          this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = n);
          break;
        case 2:
          this._point = 3, this._x5 = t, this._y5 = n;
          break;
        default:
          Gx(this, t, n);
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
    }
  };
  var Kx = function t(n) {
    function e(t) {
      return n ? new Zx(t, n) : new Lx(t, 0);
    }
    return e.alpha = function (n) {
      return t(+n);
    }, e;
  }(.5);
  function Qx(t, n) {
    this._context = t, this._alpha = n;
  }
  Qx.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function () {
      (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function (t, n) {
      if (t = +t, n = +n, this._point) {
        var e = this._x2 - t,
          r = this._y2 - n;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + r * r, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        default:
          Gx(this, t, n);
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
    }
  };
  var Jx = function t(n) {
    function e(t) {
      return n ? new Qx(t, n) : new Hx(t, 0);
    }
    return e.alpha = function (n) {
      return t(+n);
    }, e;
  }(.5);
  function tw(t) {
    this._context = t;
  }
  function nw(t) {
    return t < 0 ? -1 : 1;
  }
  function ew(t, n, e) {
    var r = t._x1 - t._x0,
      i = n - t._x1,
      o = (t._y1 - t._y0) / (r || i < 0 && -0),
      a = (e - t._y1) / (i || r < 0 && -0),
      u = (o * i + a * r) / (r + i);
    return (nw(o) + nw(a)) * Math.min(Math.abs(o), Math.abs(a), .5 * Math.abs(u)) || 0;
  }
  function rw(t, n) {
    var e = t._x1 - t._x0;
    return e ? (3 * (t._y1 - t._y0) / e - n) / 2 : n;
  }
  function iw(t, n, e) {
    var r = t._x0,
      i = t._y0,
      o = t._x1,
      a = t._y1,
      u = (o - r) / 3;
    t._context.bezierCurveTo(r + u, i + u * n, o - u, a - u * e, o, a);
  }
  function ow(t) {
    this._context = t;
  }
  function aw(t) {
    this._context = new uw(t);
  }
  function uw(t) {
    this._context = t;
  }
  function cw(t) {
    this._context = t;
  }
  function fw(t) {
    var n,
      e,
      r = t.length - 1,
      i = new Array(r),
      o = new Array(r),
      a = new Array(r);
    for (i[0] = 0, o[0] = 2, a[0] = t[0] + 2 * t[1], n = 1; n < r - 1; ++n) i[n] = 1, o[n] = 4, a[n] = 4 * t[n] + 2 * t[n + 1];
    for (i[r - 1] = 2, o[r - 1] = 7, a[r - 1] = 8 * t[r - 1] + t[r], n = 1; n < r; ++n) e = i[n] / o[n - 1], o[n] -= e, a[n] -= e * a[n - 1];
    for (i[r - 1] = a[r - 1] / o[r - 1], n = r - 2; n >= 0; --n) i[n] = (a[n] - i[n + 1]) / o[n];
    for (o[r - 1] = (t[r] + i[r - 1]) / 2, n = 0; n < r - 1; ++n) o[n] = 2 * t[n + 1] - i[n + 1];
    return [i, o];
  }
  function sw(t, n) {
    this._context = t, this._t = n;
  }
  function lw(t, n) {
    if ((i = t.length) > 1) for (var e, r, i, o = 1, a = t[n[0]], u = a.length; o < i; ++o) for (r = a, a = t[n[o]], e = 0; e < u; ++e) a[e][1] += a[e][0] = isNaN(r[e][1]) ? r[e][0] : r[e][1];
  }
  function hw(t) {
    for (var n = t.length, e = new Array(n); --n >= 0;) e[n] = n;
    return e;
  }
  function dw(t, n) {
    return t[n];
  }
  function pw(t) {
    const n = [];
    return n.key = t, n;
  }
  function gw(t) {
    var n = t.map(yw);
    return hw(t).sort(function (t, e) {
      return n[t] - n[e];
    });
  }
  function yw(t) {
    for (var n, e = -1, r = 0, i = t.length, o = -1 / 0; ++e < i;) (n = +t[e][1]) > o && (o = n, r = e);
    return r;
  }
  function vw(t) {
    var n = t.map(_w);
    return hw(t).sort(function (t, e) {
      return n[t] - n[e];
    });
  }
  function _w(t) {
    for (var n, e = 0, r = -1, i = t.length; ++r < i;) (n = +t[r][1]) && (e += n);
    return e;
  }
  tw.prototype = {
    areaStart: $x,
    areaEnd: $x,
    lineStart: function () {
      this._point = 0;
    },
    lineEnd: function () {
      this._point && this._context.closePath();
    },
    point: function (t, n) {
      t = +t, n = +n, this._point ? this._context.lineTo(t, n) : (this._point = 1, this._context.moveTo(t, n));
    }
  }, ow.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
        case 3:
          iw(this, this._t0, rw(this, this._t0));
      }
      (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function (t, n) {
      var e = NaN;
      if (n = +n, (t = +t) !== this._x1 || n !== this._y1) {
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3, iw(this, rw(this, e = ew(this, t, n)), e);
            break;
          default:
            iw(this, this._t0, e = ew(this, t, n));
        }
        this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n, this._t0 = e;
      }
    }
  }, (aw.prototype = Object.create(ow.prototype)).point = function (t, n) {
    ow.prototype.point.call(this, n, t);
  }, uw.prototype = {
    moveTo: function (t, n) {
      this._context.moveTo(n, t);
    },
    closePath: function () {
      this._context.closePath();
    },
    lineTo: function (t, n) {
      this._context.lineTo(n, t);
    },
    bezierCurveTo: function (t, n, e, r, i, o) {
      this._context.bezierCurveTo(n, t, r, e, o, i);
    }
  }, cw.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x = [], this._y = [];
    },
    lineEnd: function () {
      var t = this._x,
        n = this._y,
        e = t.length;
      if (e) if (this._line ? this._context.lineTo(t[0], n[0]) : this._context.moveTo(t[0], n[0]), 2 === e) this._context.lineTo(t[1], n[1]);else for (var r = fw(t), i = fw(n), o = 0, a = 1; a < e; ++o, ++a) this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], t[a], n[a]);
      (this._line || 0 !== this._line && 1 === e) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
    },
    point: function (t, n) {
      this._x.push(+t), this._y.push(+n);
    }
  }, sw.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x = this._y = NaN, this._point = 0;
    },
    lineEnd: function () {
      0 < this._t && this._t < 1 && 2 === this._point && this._context.lineTo(this._x, this._y), (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
    },
    point: function (t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
          break;
        case 1:
          this._point = 2;
        default:
          if (this._t <= 0) this._context.lineTo(this._x, n), this._context.lineTo(t, n);else {
            var e = this._x * (1 - this._t) + t * this._t;
            this._context.lineTo(e, this._y), this._context.lineTo(e, n);
          }
      }
      this._x = t, this._y = n;
    }
  };
  var bw = t => () => t;
  function mw(t, {
    sourceEvent: n,
    target: e,
    transform: r,
    dispatch: i
  }) {
    Object.defineProperties(this, {
      type: {
        value: t,
        enumerable: !0,
        configurable: !0
      },
      sourceEvent: {
        value: n,
        enumerable: !0,
        configurable: !0
      },
      target: {
        value: e,
        enumerable: !0,
        configurable: !0
      },
      transform: {
        value: r,
        enumerable: !0,
        configurable: !0
      },
      _: {
        value: i
      }
    });
  }
  function xw(t, n, e) {
    this.k = t, this.x = n, this.y = e;
  }
  xw.prototype = {
    constructor: xw,
    scale: function (t) {
      return 1 === t ? this : new xw(this.k * t, this.x, this.y);
    },
    translate: function (t, n) {
      return 0 === t & 0 === n ? this : new xw(this.k, this.x + this.k * t, this.y + this.k * n);
    },
    apply: function (t) {
      return [t[0] * this.k + this.x, t[1] * this.k + this.y];
    },
    applyX: function (t) {
      return t * this.k + this.x;
    },
    applyY: function (t) {
      return t * this.k + this.y;
    },
    invert: function (t) {
      return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k];
    },
    invertX: function (t) {
      return (t - this.x) / this.k;
    },
    invertY: function (t) {
      return (t - this.y) / this.k;
    },
    rescaleX: function (t) {
      return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t));
    },
    rescaleY: function (t) {
      return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t));
    },
    toString: function () {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var ww = new xw(1, 0, 0);
  function Mw(t) {
    for (; !t.__zoom;) if (!(t = t.parentNode)) return ww;
    return t.__zoom;
  }
  function Tw(t) {
    t.stopImmediatePropagation();
  }
  function Aw(t) {
    t.preventDefault(), t.stopImmediatePropagation();
  }
  function Sw(t) {
    return !(t.ctrlKey && "wheel" !== t.type || t.button);
  }
  function Ew() {
    var t = this;
    return t instanceof SVGElement ? (t = t.ownerSVGElement || t).hasAttribute("viewBox") ? [[(t = t.viewBox.baseVal).x, t.y], [t.x + t.width, t.y + t.height]] : [[0, 0], [t.width.baseVal.value, t.height.baseVal.value]] : [[0, 0], [t.clientWidth, t.clientHeight]];
  }
  function Nw() {
    return this.__zoom || ww;
  }
  function kw(t) {
    return -t.deltaY * (1 === t.deltaMode ? .05 : t.deltaMode ? 1 : .002) * (t.ctrlKey ? 10 : 1);
  }
  function Cw() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function Pw(t, n, e) {
    var r = t.invertX(n[0][0]) - e[0][0],
      i = t.invertX(n[1][0]) - e[1][0],
      o = t.invertY(n[0][1]) - e[0][1],
      a = t.invertY(n[1][1]) - e[1][1];
    return t.translate(i > r ? (r + i) / 2 : Math.min(0, r) || Math.max(0, i), a > o ? (o + a) / 2 : Math.min(0, o) || Math.max(0, a));
  }
  Mw.prototype = xw.prototype, t.Adder = T, t.Delaunay = Lu, t.FormatSpecifier = tf, t.InternMap = InternMap, t.InternSet = InternSet, t.Node = Qd, t.Path = Ua, t.Voronoi = qu, t.ZoomTransform = xw, t.active = function (t, n) {
    var e,
      r,
      i = t.__transition;
    if (i) for (r in n = null == n ? null : n + "", i) if ((e = i[r]).state > qi && e.name === n) return new po([[t]], Zo, n, +r);
    return null;
  }, t.arc = function () {
    var t = km,
      n = Cm,
      e = gm(0),
      r = null,
      i = Pm,
      o = zm,
      a = $m,
      u = null,
      c = Nm(f);
    function f() {
      var f,
        s,
        l = +t.apply(this, arguments),
        h = +n.apply(this, arguments),
        d = i.apply(this, arguments) - Am,
        p = o.apply(this, arguments) - Am,
        g = ym(p - d),
        y = p > d;
      if (u || (u = f = c()), h < l && (s = h, h = l, l = s), h > Mm) {
        if (g > Sm - Mm) u.moveTo(h * _m(d), h * xm(d)), u.arc(0, 0, h, d, p, !y), l > Mm && (u.moveTo(l * _m(p), l * xm(p)), u.arc(0, 0, l, p, d, y));else {
          var v,
            _,
            b = d,
            m = p,
            x = d,
            w = p,
            M = g,
            T = g,
            A = a.apply(this, arguments) / 2,
            S = A > Mm && (r ? +r.apply(this, arguments) : wm(l * l + h * h)),
            E = mm(ym(h - l) / 2, +e.apply(this, arguments)),
            N = E,
            k = E;
          if (S > Mm) {
            var C = Em(S / l * xm(A)),
              P = Em(S / h * xm(A));
            (M -= 2 * C) > Mm ? (x += C *= y ? 1 : -1, w -= C) : (M = 0, x = w = (d + p) / 2), (T -= 2 * P) > Mm ? (b += P *= y ? 1 : -1, m -= P) : (T = 0, b = m = (d + p) / 2);
          }
          var z = h * _m(b),
            $ = h * xm(b),
            D = l * _m(w),
            R = l * xm(w);
          if (E > Mm) {
            var F,
              q = h * _m(m),
              U = h * xm(m),
              I = l * _m(x),
              O = l * xm(x);
            if (g < Tm) if (F = function (t, n, e, r, i, o, a, u) {
              var c = e - t,
                f = r - n,
                s = a - i,
                l = u - o,
                h = l * c - s * f;
              if (!(h * h < Mm)) return [t + (h = (s * (n - o) - l * (t - i)) / h) * c, n + h * f];
            }(z, $, I, O, q, U, D, R)) {
              var B = z - F[0],
                Y = $ - F[1],
                L = q - F[0],
                j = U - F[1],
                H = 1 / xm(function (t) {
                  return t > 1 ? 0 : t < -1 ? Tm : Math.acos(t);
                }((B * L + Y * j) / (wm(B * B + Y * Y) * wm(L * L + j * j))) / 2),
                X = wm(F[0] * F[0] + F[1] * F[1]);
              N = mm(E, (l - X) / (H - 1)), k = mm(E, (h - X) / (H + 1));
            } else N = k = 0;
          }
          T > Mm ? k > Mm ? (v = Dm(I, O, z, $, h, k, y), _ = Dm(q, U, D, R, h, k, y), u.moveTo(v.cx + v.x01, v.cy + v.y01), k < E ? u.arc(v.cx, v.cy, k, vm(v.y01, v.x01), vm(_.y01, _.x01), !y) : (u.arc(v.cx, v.cy, k, vm(v.y01, v.x01), vm(v.y11, v.x11), !y), u.arc(0, 0, h, vm(v.cy + v.y11, v.cx + v.x11), vm(_.cy + _.y11, _.cx + _.x11), !y), u.arc(_.cx, _.cy, k, vm(_.y11, _.x11), vm(_.y01, _.x01), !y))) : (u.moveTo(z, $), u.arc(0, 0, h, b, m, !y)) : u.moveTo(z, $), l > Mm && M > Mm ? N > Mm ? (v = Dm(D, R, q, U, l, -N, y), _ = Dm(z, $, I, O, l, -N, y), u.lineTo(v.cx + v.x01, v.cy + v.y01), N < E ? u.arc(v.cx, v.cy, N, vm(v.y01, v.x01), vm(_.y01, _.x01), !y) : (u.arc(v.cx, v.cy, N, vm(v.y01, v.x01), vm(v.y11, v.x11), !y), u.arc(0, 0, l, vm(v.cy + v.y11, v.cx + v.x11), vm(_.cy + _.y11, _.cx + _.x11), y), u.arc(_.cx, _.cy, N, vm(_.y11, _.x11), vm(_.y01, _.x01), !y))) : u.arc(0, 0, l, w, x, y) : u.lineTo(D, R);
        }
      } else u.moveTo(0, 0);
      if (u.closePath(), f) return u = null, f + "" || null;
    }
    return f.centroid = function () {
      var e = (+t.apply(this, arguments) + +n.apply(this, arguments)) / 2,
        r = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - Tm / 2;
      return [_m(r) * e, xm(r) * e];
    }, f.innerRadius = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : gm(+n), f) : t;
    }, f.outerRadius = function (t) {
      return arguments.length ? (n = "function" == typeof t ? t : gm(+t), f) : n;
    }, f.cornerRadius = function (t) {
      return arguments.length ? (e = "function" == typeof t ? t : gm(+t), f) : e;
    }, f.padRadius = function (t) {
      return arguments.length ? (r = null == t ? null : "function" == typeof t ? t : gm(+t), f) : r;
    }, f.startAngle = function (t) {
      return arguments.length ? (i = "function" == typeof t ? t : gm(+t), f) : i;
    }, f.endAngle = function (t) {
      return arguments.length ? (o = "function" == typeof t ? t : gm(+t), f) : o;
    }, f.padAngle = function (t) {
      return arguments.length ? (a = "function" == typeof t ? t : gm(+t), f) : a;
    }, f.context = function (t) {
      return arguments.length ? (u = null == t ? null : t, f) : u;
    }, f;
  }, t.area = Ym, t.areaRadial = Zm, t.ascending = n, t.autoType = function (t) {
    for (var n in t) {
      var e,
        r,
        i = t[n].trim();
      if (i) {
        if ("true" === i) i = !0;else if ("false" === i) i = !1;else if ("NaN" === i) i = NaN;else if (isNaN(e = +i)) {
          if (!(r = i.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/))) continue;
          yc && r[4] && !r[7] && (i = i.replace(/-/g, "/").replace(/T/, " ")), i = new Date(i);
        } else i = e;
      } else i = null;
      t[n] = i;
    }
    return t;
  }, t.axisBottom = function (t) {
    return Pt(Mt, t);
  }, t.axisLeft = function (t) {
    return Pt(Tt, t);
  }, t.axisRight = function (t) {
    return Pt(wt, t);
  }, t.axisTop = function (t) {
    return Pt(xt, t);
  }, t.bin = Q, t.bisect = s, t.bisectCenter = f, t.bisectLeft = c, t.bisectRight = u, t.bisector = r, t.blob = function (t, n) {
    return fetch(t, n).then(vc);
  }, t.blur = function (t, n) {
    if (!((n = +n) >= 0)) throw new RangeError("invalid r");
    let e = t.length;
    if (!((e = Math.floor(e)) >= 0)) throw new RangeError("invalid length");
    if (!e || !n) return t;
    const r = y(n),
      i = t.slice();
    return r(t, i, 0, e, 1), r(i, t, 0, e, 1), r(t, i, 0, e, 1), t;
  }, t.blur2 = l, t.blurImage = h, t.brush = function () {
    return wa(la);
  }, t.brushSelection = function (t) {
    var n = t.__brush;
    return n ? n.dim.output(n.selection) : null;
  }, t.brushX = function () {
    return wa(fa);
  }, t.brushY = function () {
    return wa(sa);
  }, t.buffer = function (t, n) {
    return fetch(t, n).then(_c);
  }, t.chord = function () {
    return za(!1, !1);
  }, t.chordDirected = function () {
    return za(!0, !1);
  }, t.chordTranspose = function () {
    return za(!1, !0);
  }, t.cluster = function () {
    var t = Ld,
      n = 1,
      e = 1,
      r = !1;
    function i(i) {
      var o,
        a = 0;
      i.eachAfter(function (n) {
        var e = n.children;
        e ? (n.x = function (t) {
          return t.reduce(jd, 0) / t.length;
        }(e), n.y = function (t) {
          return 1 + t.reduce(Hd, 0);
        }(e)) : (n.x = o ? a += t(n, o) : 0, n.y = 0, o = n);
      });
      var u = function (t) {
          for (var n; n = t.children;) t = n[0];
          return t;
        }(i),
        c = function (t) {
          for (var n; n = t.children;) t = n[n.length - 1];
          return t;
        }(i),
        f = u.x - t(u, c) / 2,
        s = c.x + t(c, u) / 2;
      return i.eachAfter(r ? function (t) {
        t.x = (t.x - i.x) * n, t.y = (i.y - t.y) * e;
      } : function (t) {
        t.x = (t.x - f) / (s - f) * n, t.y = (1 - (i.y ? t.y / i.y : 1)) * e;
      });
    }
    return i.separation = function (n) {
      return arguments.length ? (t = n, i) : t;
    }, i.size = function (t) {
      return arguments.length ? (r = !1, n = +t[0], e = +t[1], i) : r ? null : [n, e];
    }, i.nodeSize = function (t) {
      return arguments.length ? (r = !0, n = +t[0], e = +t[1], i) : r ? [n, e] : null;
    }, i;
  }, t.color = ze, t.contourDensity = function () {
    var t = fu,
      n = su,
      e = lu,
      r = 960,
      i = 500,
      o = 20,
      a = 2,
      u = 3 * o,
      c = r + 2 * u >> a,
      f = i + 2 * u >> a,
      s = Qa(20);
    function h(r) {
      var i = new Float32Array(c * f),
        s = Math.pow(2, -a),
        h = -1;
      for (const o of r) {
        var d = (t(o, ++h, r) + u) * s,
          p = (n(o, h, r) + u) * s,
          g = +e(o, h, r);
        if (g && d >= 0 && d < c && p >= 0 && p < f) {
          var y = Math.floor(d),
            v = Math.floor(p),
            _ = d - y - .5,
            b = p - v - .5;
          i[y + v * c] += (1 - _) * (1 - b) * g, i[y + 1 + v * c] += _ * (1 - b) * g, i[y + 1 + (v + 1) * c] += _ * b * g, i[y + (v + 1) * c] += (1 - _) * b * g;
        }
      }
      return l({
        data: i,
        width: c,
        height: f
      }, o * s), i;
    }
    function d(t) {
      var n = h(t),
        e = s(n),
        r = Math.pow(2, 2 * a);
      return Array.isArray(e) || (e = G(Number.MIN_VALUE, J(n) / r, e)), iu().size([c, f]).thresholds(e.map(t => t * r))(n).map((t, n) => (t.value = +e[n], p(t)));
    }
    function p(t) {
      return t.coordinates.forEach(g), t;
    }
    function g(t) {
      t.forEach(y);
    }
    function y(t) {
      t.forEach(v);
    }
    function v(t) {
      t[0] = t[0] * Math.pow(2, a) - u, t[1] = t[1] * Math.pow(2, a) - u;
    }
    function _() {
      return c = r + 2 * (u = 3 * o) >> a, f = i + 2 * u >> a, d;
    }
    return d.contours = function (t) {
      var n = h(t),
        e = iu().size([c, f]),
        r = Math.pow(2, 2 * a),
        i = t => {
          t = +t;
          var i = p(e.contour(n, t * r));
          return i.value = t, i;
        };
      return Object.defineProperty(i, "max", {
        get: () => J(n) / r
      }), i;
    }, d.x = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : Qa(+n), d) : t;
    }, d.y = function (t) {
      return arguments.length ? (n = "function" == typeof t ? t : Qa(+t), d) : n;
    }, d.weight = function (t) {
      return arguments.length ? (e = "function" == typeof t ? t : Qa(+t), d) : e;
    }, d.size = function (t) {
      if (!arguments.length) return [r, i];
      var n = +t[0],
        e = +t[1];
      if (!(n >= 0 && e >= 0)) throw new Error("invalid size");
      return r = n, i = e, _();
    }, d.cellSize = function (t) {
      if (!arguments.length) return 1 << a;
      if (!((t = +t) >= 1)) throw new Error("invalid cell size");
      return a = Math.floor(Math.log(t) / Math.LN2), _();
    }, d.thresholds = function (t) {
      return arguments.length ? (s = "function" == typeof t ? t : Array.isArray(t) ? Qa(Za.call(t)) : Qa(t), d) : s;
    }, d.bandwidth = function (t) {
      if (!arguments.length) return Math.sqrt(o * (o + 1));
      if (!((t = +t) >= 0)) throw new Error("invalid bandwidth");
      return o = (Math.sqrt(4 * t * t + 1) - 1) / 2, _();
    }, d;
  }, t.contours = iu, t.count = v, t.create = function (t) {
    return Zn(Yt(t).call(document.documentElement));
  }, t.creator = Yt, t.cross = function (...t) {
    const n = "function" == typeof t[t.length - 1] && function (t) {
        return n => t(...n);
      }(t.pop()),
      e = (t = t.map(m)).map(_),
      r = t.length - 1,
      i = new Array(r + 1).fill(0),
      o = [];
    if (r < 0 || e.some(b)) return o;
    for (;;) {
      o.push(i.map((n, e) => t[e][n]));
      let a = r;
      for (; ++i[a] === e[a];) {
        if (0 === a) return n ? o.map(n) : o;
        i[a--] = 0;
      }
    }
  }, t.csv = wc, t.csvFormat = rc, t.csvFormatBody = ic, t.csvFormatRow = ac, t.csvFormatRows = oc, t.csvFormatValue = uc, t.csvParse = nc, t.csvParseRows = ec, t.cubehelix = Tr, t.cumsum = function (t, n) {
    var e = 0,
      r = 0;
    return Float64Array.from(t, void 0 === n ? t => e += +t || 0 : i => e += +n(i, r++, t) || 0);
  }, t.curveBasis = function (t) {
    return new Rx(t);
  }, t.curveBasisClosed = function (t) {
    return new Fx(t);
  }, t.curveBasisOpen = function (t) {
    return new qx(t);
  }, t.curveBumpX = tx, t.curveBumpY = nx, t.curveBundle = Ix, t.curveCardinal = Yx, t.curveCardinalClosed = jx, t.curveCardinalOpen = Xx, t.curveCatmullRom = Wx, t.curveCatmullRomClosed = Kx, t.curveCatmullRomOpen = Jx, t.curveLinear = Um, t.curveLinearClosed = function (t) {
    return new tw(t);
  }, t.curveMonotoneX = function (t) {
    return new ow(t);
  }, t.curveMonotoneY = function (t) {
    return new aw(t);
  }, t.curveNatural = function (t) {
    return new cw(t);
  }, t.curveStep = function (t) {
    return new sw(t, .5);
  }, t.curveStepAfter = function (t) {
    return new sw(t, 1);
  }, t.curveStepBefore = function (t) {
    return new sw(t, 0);
  }, t.descending = e, t.deviation = w, t.difference = function (t, ...n) {
    t = new InternSet(t);
    for (const e of n) for (const n of e) t.delete(n);
    return t;
  }, t.disjoint = function (t, n) {
    const e = n[Symbol.iterator](),
      r = new InternSet();
    for (const n of t) {
      if (r.has(n)) return !1;
      let t, i;
      for (; ({
        value: t,
        done: i
      } = e.next()) && !i;) {
        if (Object.is(n, t)) return !1;
        r.add(t);
      }
    }
    return !0;
  }, t.dispatch = $t, t.drag = function () {
    var t,
      n,
      e,
      r,
      i = se,
      o = le,
      a = he,
      u = de,
      c = {},
      f = $t("start", "drag", "end"),
      s = 0,
      l = 0;
    function h(t) {
      t.on("mousedown.drag", d).filter(u).on("touchstart.drag", y).on("touchmove.drag", v, ee).on("touchend.drag touchcancel.drag", _).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function d(a, u) {
      if (!r && i.call(this, a, u)) {
        var c = b(this, o.call(this, a, u), a, u, "mouse");
        c && (Zn(a.view).on("mousemove.drag", p, re).on("mouseup.drag", g, re), ae(a.view), ie(a), e = !1, t = a.clientX, n = a.clientY, c("start", a));
      }
    }
    function p(r) {
      if (oe(r), !e) {
        var i = r.clientX - t,
          o = r.clientY - n;
        e = i * i + o * o > l;
      }
      c.mouse("drag", r);
    }
    function g(t) {
      Zn(t.view).on("mousemove.drag mouseup.drag", null), ue(t.view, e), oe(t), c.mouse("end", t);
    }
    function y(t, n) {
      if (i.call(this, t, n)) {
        var e,
          r,
          a = t.changedTouches,
          u = o.call(this, t, n),
          c = a.length;
        for (e = 0; e < c; ++e) (r = b(this, u, t, n, a[e].identifier, a[e])) && (ie(t), r("start", t, a[e]));
      }
    }
    function v(t) {
      var n,
        e,
        r = t.changedTouches,
        i = r.length;
      for (n = 0; n < i; ++n) (e = c[r[n].identifier]) && (oe(t), e("drag", t, r[n]));
    }
    function _(t) {
      var n,
        e,
        i = t.changedTouches,
        o = i.length;
      for (r && clearTimeout(r), r = setTimeout(function () {
        r = null;
      }, 500), n = 0; n < o; ++n) (e = c[i[n].identifier]) && (ie(t), e("end", t, i[n]));
    }
    function b(t, n, e, r, i, o) {
      var u,
        l,
        d,
        p = f.copy(),
        g = ne(o || e, n);
      if (null != (d = a.call(t, new fe("beforestart", {
        sourceEvent: e,
        target: h,
        identifier: i,
        active: s,
        x: g[0],
        y: g[1],
        dx: 0,
        dy: 0,
        dispatch: p
      }), r))) return u = d.x - g[0] || 0, l = d.y - g[1] || 0, function e(o, a, f) {
        var y,
          v = g;
        switch (o) {
          case "start":
            c[i] = e, y = s++;
            break;
          case "end":
            delete c[i], --s;
          case "drag":
            g = ne(f || a, n), y = s;
        }
        p.call(o, t, new fe(o, {
          sourceEvent: a,
          subject: d,
          target: h,
          identifier: i,
          active: y,
          x: g[0] + u,
          y: g[1] + l,
          dx: g[0] - v[0],
          dy: g[1] - v[1],
          dispatch: p
        }), r);
      };
    }
    return h.filter = function (t) {
      return arguments.length ? (i = "function" == typeof t ? t : ce(!!t), h) : i;
    }, h.container = function (t) {
      return arguments.length ? (o = "function" == typeof t ? t : ce(t), h) : o;
    }, h.subject = function (t) {
      return arguments.length ? (a = "function" == typeof t ? t : ce(t), h) : a;
    }, h.touchable = function (t) {
      return arguments.length ? (u = "function" == typeof t ? t : ce(!!t), h) : u;
    }, h.on = function () {
      var t = f.on.apply(f, arguments);
      return t === f ? h : t;
    }, h.clickDistance = function (t) {
      return arguments.length ? (l = (t = +t) * t, h) : Math.sqrt(l);
    }, h;
  }, t.dragDisable = ae, t.dragEnable = ue, t.dsv = function (t, n, e, r) {
    3 === arguments.length && "function" == typeof e && (r = e, e = void 0);
    var i = Ju(t);
    return mc(n, e).then(function (t) {
      return i.parse(t, r);
    });
  }, t.dsvFormat = Ju, t.easeBack = Lo, t.easeBackIn = Bo, t.easeBackInOut = Lo, t.easeBackOut = Yo, t.easeBounce = Io, t.easeBounceIn = function (t) {
    return 1 - Io(1 - t);
  }, t.easeBounceInOut = function (t) {
    return ((t *= 2) <= 1 ? 1 - Io(1 - t) : Io(t - 1) + 1) / 2;
  }, t.easeBounceOut = Io, t.easeCircle = No, t.easeCircleIn = function (t) {
    return 1 - Math.sqrt(1 - t * t);
  }, t.easeCircleInOut = No, t.easeCircleOut = function (t) {
    return Math.sqrt(1 - --t * t);
  }, t.easeCubic = bo, t.easeCubicIn = function (t) {
    return t * t * t;
  }, t.easeCubicInOut = bo, t.easeCubicOut = function (t) {
    return --t * t * t + 1;
  }, t.easeElastic = Xo, t.easeElasticIn = Ho, t.easeElasticInOut = Go, t.easeElasticOut = Xo, t.easeExp = Eo, t.easeExpIn = function (t) {
    return So(1 - +t);
  }, t.easeExpInOut = Eo, t.easeExpOut = function (t) {
    return 1 - So(t);
  }, t.easeLinear = t => +t, t.easePoly = wo, t.easePolyIn = mo, t.easePolyInOut = wo, t.easePolyOut = xo, t.easeQuad = _o, t.easeQuadIn = function (t) {
    return t * t;
  }, t.easeQuadInOut = _o, t.easeQuadOut = function (t) {
    return t * (2 - t);
  }, t.easeSin = Ao, t.easeSinIn = function (t) {
    return 1 == +t ? 1 : 1 - Math.cos(t * To);
  }, t.easeSinInOut = Ao, t.easeSinOut = function (t) {
    return Math.sin(t * To);
  }, t.every = function (t, n) {
    if ("function" != typeof n) throw new TypeError("test is not a function");
    let e = -1;
    for (const r of t) if (!n(r, ++e, t)) return !1;
    return !0;
  }, t.extent = M, t.fcumsum = function (t, n) {
    const e = new T();
    let r = -1;
    return Float64Array.from(t, void 0 === n ? t => e.add(+t || 0) : i => e.add(+n(i, ++r, t) || 0));
  }, t.filter = function (t, n) {
    if ("function" != typeof n) throw new TypeError("test is not a function");
    const e = [];
    let r = -1;
    for (const i of t) n(i, ++r, t) && e.push(i);
    return e;
  }, t.flatGroup = function (t, ...n) {
    return z(P(t, ...n), n);
  }, t.flatRollup = function (t, n, ...e) {
    return z(D(t, n, ...e), e);
  }, t.forceCenter = function (t, n) {
    var e,
      r = 1;
    function i() {
      var i,
        o,
        a = e.length,
        u = 0,
        c = 0;
      for (i = 0; i < a; ++i) u += (o = e[i]).x, c += o.y;
      for (u = (u / a - t) * r, c = (c / a - n) * r, i = 0; i < a; ++i) (o = e[i]).x -= u, o.y -= c;
    }
    return null == t && (t = 0), null == n && (n = 0), i.initialize = function (t) {
      e = t;
    }, i.x = function (n) {
      return arguments.length ? (t = +n, i) : t;
    }, i.y = function (t) {
      return arguments.length ? (n = +t, i) : n;
    }, i.strength = function (t) {
      return arguments.length ? (r = +t, i) : r;
    }, i;
  }, t.forceCollide = function (t) {
    var n,
      e,
      r,
      i = 1,
      o = 1;
    function a() {
      for (var t, a, c, f, s, l, h, d = n.length, p = 0; p < o; ++p) for (a = $c(n, Ic, Oc).visitAfter(u), t = 0; t < d; ++t) c = n[t], l = e[c.index], h = l * l, f = c.x + c.vx, s = c.y + c.vy, a.visit(g);
      function g(t, n, e, o, a) {
        var u = t.data,
          d = t.r,
          p = l + d;
        if (!u) return n > f + p || o < f - p || e > s + p || a < s - p;
        if (u.index > c.index) {
          var g = f - u.x - u.vx,
            y = s - u.y - u.vy,
            v = g * g + y * y;
          v < p * p && (0 === g && (v += (g = Uc(r)) * g), 0 === y && (v += (y = Uc(r)) * y), v = (p - (v = Math.sqrt(v))) / v * i, c.vx += (g *= v) * (p = (d *= d) / (h + d)), c.vy += (y *= v) * p, u.vx -= g * (p = 1 - p), u.vy -= y * p);
        }
      }
    }
    function u(t) {
      if (t.data) return t.r = e[t.data.index];
      for (var n = t.r = 0; n < 4; ++n) t[n] && t[n].r > t.r && (t.r = t[n].r);
    }
    function c() {
      if (n) {
        var r,
          i,
          o = n.length;
        for (e = new Array(o), r = 0; r < o; ++r) i = n[r], e[i.index] = +t(i, r, n);
      }
    }
    return "function" != typeof t && (t = qc(null == t ? 1 : +t)), a.initialize = function (t, e) {
      n = t, r = e, c();
    }, a.iterations = function (t) {
      return arguments.length ? (o = +t, a) : o;
    }, a.strength = function (t) {
      return arguments.length ? (i = +t, a) : i;
    }, a.radius = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : qc(+n), c(), a) : t;
    }, a;
  }, t.forceLink = function (t) {
    var n,
      e,
      r,
      i,
      o,
      a,
      u = Bc,
      c = function (t) {
        return 1 / Math.min(i[t.source.index], i[t.target.index]);
      },
      f = qc(30),
      s = 1;
    function l(r) {
      for (var i = 0, u = t.length; i < s; ++i) for (var c, f, l, h, d, p, g, y = 0; y < u; ++y) f = (c = t[y]).source, h = (l = c.target).x + l.vx - f.x - f.vx || Uc(a), d = l.y + l.vy - f.y - f.vy || Uc(a), h *= p = ((p = Math.sqrt(h * h + d * d)) - e[y]) / p * r * n[y], d *= p, l.vx -= h * (g = o[y]), l.vy -= d * g, f.vx += h * (g = 1 - g), f.vy += d * g;
    }
    function h() {
      if (r) {
        var a,
          c,
          f = r.length,
          s = t.length,
          l = new Map(r.map((t, n) => [u(t, n, r), t]));
        for (a = 0, i = new Array(f); a < s; ++a) (c = t[a]).index = a, "object" != typeof c.source && (c.source = Yc(l, c.source)), "object" != typeof c.target && (c.target = Yc(l, c.target)), i[c.source.index] = (i[c.source.index] || 0) + 1, i[c.target.index] = (i[c.target.index] || 0) + 1;
        for (a = 0, o = new Array(s); a < s; ++a) c = t[a], o[a] = i[c.source.index] / (i[c.source.index] + i[c.target.index]);
        n = new Array(s), d(), e = new Array(s), p();
      }
    }
    function d() {
      if (r) for (var e = 0, i = t.length; e < i; ++e) n[e] = +c(t[e], e, t);
    }
    function p() {
      if (r) for (var n = 0, i = t.length; n < i; ++n) e[n] = +f(t[n], n, t);
    }
    return null == t && (t = []), l.initialize = function (t, n) {
      r = t, a = n, h();
    }, l.links = function (n) {
      return arguments.length ? (t = n, h(), l) : t;
    }, l.id = function (t) {
      return arguments.length ? (u = t, l) : u;
    }, l.iterations = function (t) {
      return arguments.length ? (s = +t, l) : s;
    }, l.strength = function (t) {
      return arguments.length ? (c = "function" == typeof t ? t : qc(+t), d(), l) : c;
    }, l.distance = function (t) {
      return arguments.length ? (f = "function" == typeof t ? t : qc(+t), p(), l) : f;
    }, l;
  }, t.forceManyBody = function () {
    var t,
      n,
      e,
      r,
      i,
      o = qc(-30),
      a = 1,
      u = 1 / 0,
      c = .81;
    function f(e) {
      var i,
        o = t.length,
        a = $c(t, Xc, Gc).visitAfter(l);
      for (r = e, i = 0; i < o; ++i) n = t[i], a.visit(h);
    }
    function s() {
      if (t) {
        var n,
          e,
          r = t.length;
        for (i = new Array(r), n = 0; n < r; ++n) e = t[n], i[e.index] = +o(e, n, t);
      }
    }
    function l(t) {
      var n,
        e,
        r,
        o,
        a,
        u = 0,
        c = 0;
      if (t.length) {
        for (r = o = a = 0; a < 4; ++a) (n = t[a]) && (e = Math.abs(n.value)) && (u += n.value, c += e, r += e * n.x, o += e * n.y);
        t.x = r / c, t.y = o / c;
      } else {
        (n = t).x = n.data.x, n.y = n.data.y;
        do {
          u += i[n.data.index];
        } while (n = n.next);
      }
      t.value = u;
    }
    function h(t, o, f, s) {
      if (!t.value) return !0;
      var l = t.x - n.x,
        h = t.y - n.y,
        d = s - o,
        p = l * l + h * h;
      if (d * d / c < p) return p < u && (0 === l && (p += (l = Uc(e)) * l), 0 === h && (p += (h = Uc(e)) * h), p < a && (p = Math.sqrt(a * p)), n.vx += l * t.value * r / p, n.vy += h * t.value * r / p), !0;
      if (!(t.length || p >= u)) {
        (t.data !== n || t.next) && (0 === l && (p += (l = Uc(e)) * l), 0 === h && (p += (h = Uc(e)) * h), p < a && (p = Math.sqrt(a * p)));
        do {
          t.data !== n && (d = i[t.data.index] * r / p, n.vx += l * d, n.vy += h * d);
        } while (t = t.next);
      }
    }
    return f.initialize = function (n, r) {
      t = n, e = r, s();
    }, f.strength = function (t) {
      return arguments.length ? (o = "function" == typeof t ? t : qc(+t), s(), f) : o;
    }, f.distanceMin = function (t) {
      return arguments.length ? (a = t * t, f) : Math.sqrt(a);
    }, f.distanceMax = function (t) {
      return arguments.length ? (u = t * t, f) : Math.sqrt(u);
    }, f.theta = function (t) {
      return arguments.length ? (c = t * t, f) : Math.sqrt(c);
    }, f;
  }, t.forceRadial = function (t, n, e) {
    var r,
      i,
      o,
      a = qc(.1);
    function u(t) {
      for (var a = 0, u = r.length; a < u; ++a) {
        var c = r[a],
          f = c.x - n || 1e-6,
          s = c.y - e || 1e-6,
          l = Math.sqrt(f * f + s * s),
          h = (o[a] - l) * i[a] * t / l;
        c.vx += f * h, c.vy += s * h;
      }
    }
    function c() {
      if (r) {
        var n,
          e = r.length;
        for (i = new Array(e), o = new Array(e), n = 0; n < e; ++n) o[n] = +t(r[n], n, r), i[n] = isNaN(o[n]) ? 0 : +a(r[n], n, r);
      }
    }
    return "function" != typeof t && (t = qc(+t)), null == n && (n = 0), null == e && (e = 0), u.initialize = function (t) {
      r = t, c();
    }, u.strength = function (t) {
      return arguments.length ? (a = "function" == typeof t ? t : qc(+t), c(), u) : a;
    }, u.radius = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : qc(+n), c(), u) : t;
    }, u.x = function (t) {
      return arguments.length ? (n = +t, u) : n;
    }, u.y = function (t) {
      return arguments.length ? (e = +t, u) : e;
    }, u;
  }, t.forceSimulation = function (t) {
    var n,
      e = 1,
      r = .001,
      i = 1 - Math.pow(r, 1 / 300),
      o = 0,
      a = .6,
      u = new Map(),
      c = Ni(l),
      f = $t("tick", "end"),
      s = function () {
        let t = 1;
        return () => (t = (Lc * t + jc) % Hc) / Hc;
      }();
    function l() {
      h(), f.call("tick", n), e < r && (c.stop(), f.call("end", n));
    }
    function h(r) {
      var c,
        f,
        s = t.length;
      void 0 === r && (r = 1);
      for (var l = 0; l < r; ++l) for (e += (o - e) * i, u.forEach(function (t) {
        t(e);
      }), c = 0; c < s; ++c) null == (f = t[c]).fx ? f.x += f.vx *= a : (f.x = f.fx, f.vx = 0), null == f.fy ? f.y += f.vy *= a : (f.y = f.fy, f.vy = 0);
      return n;
    }
    function d() {
      for (var n, e = 0, r = t.length; e < r; ++e) {
        if ((n = t[e]).index = e, null != n.fx && (n.x = n.fx), null != n.fy && (n.y = n.fy), isNaN(n.x) || isNaN(n.y)) {
          var i = 10 * Math.sqrt(.5 + e),
            o = e * Vc;
          n.x = i * Math.cos(o), n.y = i * Math.sin(o);
        }
        (isNaN(n.vx) || isNaN(n.vy)) && (n.vx = n.vy = 0);
      }
    }
    function p(n) {
      return n.initialize && n.initialize(t, s), n;
    }
    return null == t && (t = []), d(), n = {
      tick: h,
      restart: function () {
        return c.restart(l), n;
      },
      stop: function () {
        return c.stop(), n;
      },
      nodes: function (e) {
        return arguments.length ? (t = e, d(), u.forEach(p), n) : t;
      },
      alpha: function (t) {
        return arguments.length ? (e = +t, n) : e;
      },
      alphaMin: function (t) {
        return arguments.length ? (r = +t, n) : r;
      },
      alphaDecay: function (t) {
        return arguments.length ? (i = +t, n) : +i;
      },
      alphaTarget: function (t) {
        return arguments.length ? (o = +t, n) : o;
      },
      velocityDecay: function (t) {
        return arguments.length ? (a = 1 - t, n) : 1 - a;
      },
      randomSource: function (t) {
        return arguments.length ? (s = t, u.forEach(p), n) : s;
      },
      force: function (t, e) {
        return arguments.length > 1 ? (null == e ? u.delete(t) : u.set(t, p(e)), n) : u.get(t);
      },
      find: function (n, e, r) {
        var i,
          o,
          a,
          u,
          c,
          f = 0,
          s = t.length;
        for (null == r ? r = 1 / 0 : r *= r, f = 0; f < s; ++f) (a = (i = n - (u = t[f]).x) * i + (o = e - u.y) * o) < r && (c = u, r = a);
        return c;
      },
      on: function (t, e) {
        return arguments.length > 1 ? (f.on(t, e), n) : f.on(t);
      }
    };
  }, t.forceX = function (t) {
    var n,
      e,
      r,
      i = qc(.1);
    function o(t) {
      for (var i, o = 0, a = n.length; o < a; ++o) (i = n[o]).vx += (r[o] - i.x) * e[o] * t;
    }
    function a() {
      if (n) {
        var o,
          a = n.length;
        for (e = new Array(a), r = new Array(a), o = 0; o < a; ++o) e[o] = isNaN(r[o] = +t(n[o], o, n)) ? 0 : +i(n[o], o, n);
      }
    }
    return "function" != typeof t && (t = qc(null == t ? 0 : +t)), o.initialize = function (t) {
      n = t, a();
    }, o.strength = function (t) {
      return arguments.length ? (i = "function" == typeof t ? t : qc(+t), a(), o) : i;
    }, o.x = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : qc(+n), a(), o) : t;
    }, o;
  }, t.forceY = function (t) {
    var n,
      e,
      r,
      i = qc(.1);
    function o(t) {
      for (var i, o = 0, a = n.length; o < a; ++o) (i = n[o]).vy += (r[o] - i.y) * e[o] * t;
    }
    function a() {
      if (n) {
        var o,
          a = n.length;
        for (e = new Array(a), r = new Array(a), o = 0; o < a; ++o) e[o] = isNaN(r[o] = +t(n[o], o, n)) ? 0 : +i(n[o], o, n);
      }
    }
    return "function" != typeof t && (t = qc(null == t ? 0 : +t)), o.initialize = function (t) {
      n = t, a();
    }, o.strength = function (t) {
      return arguments.length ? (i = "function" == typeof t ? t : qc(+t), a(), o) : i;
    }, o.y = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : qc(+n), a(), o) : t;
    }, o;
  }, t.formatDefaultLocale = ff, t.formatLocale = cf, t.formatSpecifier = Jc, t.fsum = function (t, n) {
    const e = new T();
    if (void 0 === n) for (let n of t) (n = +n) && e.add(n);else {
      let r = -1;
      for (let i of t) (i = +n(i, ++r, t)) && e.add(i);
    }
    return +e;
  }, t.geoAlbers = xd, t.geoAlbersUsa = function () {
    var t,
      n,
      e,
      r,
      i,
      o,
      a = xd(),
      u = md().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
      c = md().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
      f = {
        point: function (t, n) {
          o = [t, n];
        }
      };
    function s(t) {
      var n = t[0],
        a = t[1];
      return o = null, e.point(n, a), o || (r.point(n, a), o) || (i.point(n, a), o);
    }
    function l() {
      return t = n = null, s;
    }
    return s.invert = function (t) {
      var n = a.scale(),
        e = a.translate(),
        r = (t[0] - e[0]) / n,
        i = (t[1] - e[1]) / n;
      return (i >= .12 && i < .234 && r >= -.425 && r < -.214 ? u : i >= .166 && i < .234 && r >= -.214 && r < -.115 ? c : a).invert(t);
    }, s.stream = function (e) {
      return t && n === e ? t : (r = [a.stream(n = e), u.stream(e), c.stream(e)], i = r.length, t = {
        point: function (t, n) {
          for (var e = -1; ++e < i;) r[e].point(t, n);
        },
        sphere: function () {
          for (var t = -1; ++t < i;) r[t].sphere();
        },
        lineStart: function () {
          for (var t = -1; ++t < i;) r[t].lineStart();
        },
        lineEnd: function () {
          for (var t = -1; ++t < i;) r[t].lineEnd();
        },
        polygonStart: function () {
          for (var t = -1; ++t < i;) r[t].polygonStart();
        },
        polygonEnd: function () {
          for (var t = -1; ++t < i;) r[t].polygonEnd();
        }
      });
      var r, i;
    }, s.precision = function (t) {
      return arguments.length ? (a.precision(t), u.precision(t), c.precision(t), l()) : a.precision();
    }, s.scale = function (t) {
      return arguments.length ? (a.scale(t), u.scale(.35 * t), c.scale(t), s.translate(a.translate())) : a.scale();
    }, s.translate = function (t) {
      if (!arguments.length) return a.translate();
      var n = a.scale(),
        o = +t[0],
        s = +t[1];
      return e = a.translate(t).clipExtent([[o - .455 * n, s - .238 * n], [o + .455 * n, s + .238 * n]]).stream(f), r = u.translate([o - .307 * n, s + .201 * n]).clipExtent([[o - .425 * n + df, s + .12 * n + df], [o - .214 * n - df, s + .234 * n - df]]).stream(f), i = c.translate([o - .205 * n, s + .212 * n]).clipExtent([[o - .214 * n + df, s + .166 * n + df], [o - .115 * n - df, s + .234 * n - df]]).stream(f), l();
    }, s.fitExtent = function (t, n) {
      return ud(s, t, n);
    }, s.fitSize = function (t, n) {
      return cd(s, t, n);
    }, s.fitWidth = function (t, n) {
      return fd(s, t, n);
    }, s.fitHeight = function (t, n) {
      return sd(s, t, n);
    }, s.scale(1070);
  }, t.geoArea = function (t) {
    return us = new T(), Lf(t, cs), 2 * us;
  }, t.geoAzimuthalEqualArea = function () {
    return yd(Td).scale(124.75).clipAngle(179.999);
  }, t.geoAzimuthalEqualAreaRaw = Td, t.geoAzimuthalEquidistant = function () {
    return yd(Ad).scale(79.4188).clipAngle(179.999);
  }, t.geoAzimuthalEquidistantRaw = Ad, t.geoBounds = function (t) {
    var n, e, r, i, o, a, u;
    if (Qf = Kf = -(Wf = Zf = 1 / 0), is = [], Lf(t, Fs), e = is.length) {
      for (is.sort(Hs), n = 1, o = [r = is[0]]; n < e; ++n) Xs(r, (i = is[n])[0]) || Xs(r, i[1]) ? (js(r[0], i[1]) > js(r[0], r[1]) && (r[1] = i[1]), js(i[0], r[1]) > js(r[0], r[1]) && (r[0] = i[0])) : o.push(r = i);
      for (a = -1 / 0, n = 0, r = o[e = o.length - 1]; n <= e; r = i, ++n) i = o[n], (u = js(r[1], i[0])) > a && (a = u, Wf = i[0], Kf = r[1]);
    }
    return is = os = null, Wf === 1 / 0 || Zf === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[Wf, Zf], [Kf, Qf]];
  }, t.geoCentroid = function (t) {
    ms = xs = ws = Ms = Ts = As = Ss = Es = 0, Ns = new T(), ks = new T(), Cs = new T(), Lf(t, Gs);
    var n = +Ns,
      e = +ks,
      r = +Cs,
      i = Ef(n, e, r);
    return i < pf && (n = As, e = Ss, r = Es, xs < df && (n = ws, e = Ms, r = Ts), (i = Ef(n, e, r)) < pf) ? [NaN, NaN] : [Mf(e, n) * bf, Rf(r / i) * bf];
  }, t.geoCircle = function () {
    var t,
      n,
      e = il([0, 0]),
      r = il(90),
      i = il(6),
      o = {
        point: function (e, r) {
          t.push(e = n(e, r)), e[0] *= bf, e[1] *= bf;
        }
      };
    function a() {
      var a = e.apply(this, arguments),
        u = r.apply(this, arguments) * mf,
        c = i.apply(this, arguments) * mf;
      return t = [], n = ul(-a[0] * mf, -a[1] * mf, 0).invert, hl(o, u, c, 1), a = {
        type: "Polygon",
        coordinates: [t]
      }, t = n = null, a;
    }
    return a.center = function (t) {
      return arguments.length ? (e = "function" == typeof t ? t : il([+t[0], +t[1]]), a) : e;
    }, a.radius = function (t) {
      return arguments.length ? (r = "function" == typeof t ? t : il(+t), a) : r;
    }, a.precision = function (t) {
      return arguments.length ? (i = "function" == typeof t ? t : il(+t), a) : i;
    }, a;
  }, t.geoClipAntimeridian = Tl, t.geoClipCircle = Al, t.geoClipExtent = function () {
    var t,
      n,
      e,
      r = 0,
      i = 0,
      o = 960,
      a = 500;
    return e = {
      stream: function (e) {
        return t && n === e ? t : t = zl(r, i, o, a)(n = e);
      },
      extent: function (u) {
        return arguments.length ? (r = +u[0][0], i = +u[0][1], o = +u[1][0], a = +u[1][1], t = n = null, e) : [[r, i], [o, a]];
      }
    };
  }, t.geoClipRectangle = zl, t.geoConicConformal = function () {
    return _d(kd).scale(109.5).parallels([30, 30]);
  }, t.geoConicConformalRaw = kd, t.geoConicEqualArea = md, t.geoConicEqualAreaRaw = bd, t.geoConicEquidistant = function () {
    return _d(Pd).scale(131.154).center([0, 13.9389]);
  }, t.geoConicEquidistantRaw = Pd, t.geoContains = function (t, n) {
    return (t && Bl.hasOwnProperty(t.type) ? Bl[t.type] : Ll)(t, n);
  }, t.geoDistance = Ol, t.geoEqualEarth = function () {
    return yd(qd).scale(177.158);
  }, t.geoEqualEarthRaw = qd, t.geoEquirectangular = function () {
    return yd(Cd).scale(152.63);
  }, t.geoEquirectangularRaw = Cd, t.geoGnomonic = function () {
    return yd(Ud).scale(144.049).clipAngle(60);
  }, t.geoGnomonicRaw = Ud, t.geoGraticule = Kl, t.geoGraticule10 = function () {
    return Kl()();
  }, t.geoIdentity = function () {
    var t,
      n,
      e,
      r,
      i,
      o,
      a,
      u = 1,
      c = 0,
      f = 0,
      s = 1,
      l = 1,
      h = 0,
      d = null,
      p = 1,
      g = 1,
      y = id({
        point: function (t, n) {
          var e = b([t, n]);
          this.stream.point(e[0], e[1]);
        }
      }),
      v = eh;
    function _() {
      return p = u * s, g = u * l, o = a = null, b;
    }
    function b(e) {
      var r = e[0] * p,
        i = e[1] * g;
      if (h) {
        var o = i * t - r * n;
        r = r * t + i * n, i = o;
      }
      return [r + c, i + f];
    }
    return b.invert = function (e) {
      var r = e[0] - c,
        i = e[1] - f;
      if (h) {
        var o = i * t + r * n;
        r = r * t - i * n, i = o;
      }
      return [r / p, i / g];
    }, b.stream = function (t) {
      return o && a === t ? o : o = y(v(a = t));
    }, b.postclip = function (t) {
      return arguments.length ? (v = t, d = e = r = i = null, _()) : v;
    }, b.clipExtent = function (t) {
      return arguments.length ? (v = null == t ? (d = e = r = i = null, eh) : zl(d = +t[0][0], e = +t[0][1], r = +t[1][0], i = +t[1][1]), _()) : null == d ? null : [[d, e], [r, i]];
    }, b.scale = function (t) {
      return arguments.length ? (u = +t, _()) : u;
    }, b.translate = function (t) {
      return arguments.length ? (c = +t[0], f = +t[1], _()) : [c, f];
    }, b.angle = function (e) {
      return arguments.length ? (n = Cf(h = e % 360 * mf), t = Tf(h), _()) : h * bf;
    }, b.reflectX = function (t) {
      return arguments.length ? (s = t ? -1 : 1, _()) : s < 0;
    }, b.reflectY = function (t) {
      return arguments.length ? (l = t ? -1 : 1, _()) : l < 0;
    }, b.fitExtent = function (t, n) {
      return ud(b, t, n);
    }, b.fitSize = function (t, n) {
      return cd(b, t, n);
    }, b.fitWidth = function (t, n) {
      return fd(b, t, n);
    }, b.fitHeight = function (t, n) {
      return sd(b, t, n);
    }, b;
  }, t.geoInterpolate = function (t, n) {
    var e = t[0] * mf,
      r = t[1] * mf,
      i = n[0] * mf,
      o = n[1] * mf,
      a = Tf(r),
      u = Cf(r),
      c = Tf(o),
      f = Cf(o),
      s = a * Tf(e),
      l = a * Cf(e),
      h = c * Tf(i),
      d = c * Cf(i),
      p = 2 * Rf(zf(Ff(o - r) + a * c * Ff(i - e))),
      g = Cf(p),
      y = p ? function (t) {
        var n = Cf(t *= p) / g,
          e = Cf(p - t) / g,
          r = e * s + n * h,
          i = e * l + n * d,
          o = e * u + n * f;
        return [Mf(i, r) * bf, Mf(o, zf(r * r + i * i)) * bf];
      } : function () {
        return [e * bf, r * bf];
      };
    return y.distance = p, y;
  }, t.geoLength = ql, t.geoMercator = function () {
    return Ed(Sd).scale(961 / _f);
  }, t.geoMercatorRaw = Sd, t.geoNaturalEarth1 = function () {
    return yd(Id).scale(175.295);
  }, t.geoNaturalEarth1Raw = Id, t.geoOrthographic = function () {
    return yd(Od).scale(249.5).clipAngle(90 + df);
  }, t.geoOrthographicRaw = Od, t.geoPath = function (t, n) {
    let e,
      r,
      i = 3,
      o = 4.5;
    function a(t) {
      return t && ("function" == typeof o && r.pointRadius(+o.apply(this, arguments)), Lf(t, e(r))), r.result();
    }
    return a.area = function (t) {
      return Lf(t, e(sh)), sh.result();
    }, a.measure = function (t) {
      return Lf(t, e(Kh)), Kh.result();
    }, a.bounds = function (t) {
      return Lf(t, e(mh)), mh.result();
    }, a.centroid = function (t) {
      return Lf(t, e(Oh)), Oh.result();
    }, a.projection = function (n) {
      return arguments.length ? (e = null == n ? (t = null, eh) : (t = n).stream, a) : t;
    }, a.context = function (t) {
      return arguments.length ? (r = null == t ? (n = null, new ed(i)) : new Bh(n = t), "function" != typeof o && r.pointRadius(o), a) : n;
    }, a.pointRadius = function (t) {
      return arguments.length ? (o = "function" == typeof t ? t : (r.pointRadius(+t), +t), a) : o;
    }, a.digits = function (t) {
      if (!arguments.length) return i;
      if (null == t) i = null;else {
        const n = Math.floor(t);
        if (!(n >= 0)) throw new RangeError(`invalid digits: ${t}`);
        i = n;
      }
      return null === n && (r = new ed(i)), a;
    }, a.projection(t).digits(i).context(n);
  }, t.geoProjection = yd, t.geoProjectionMutator = vd, t.geoRotation = ll, t.geoStereographic = function () {
    return yd(Bd).scale(250).clipAngle(142);
  }, t.geoStereographicRaw = Bd, t.geoStream = Lf, t.geoTransform = function (t) {
    return {
      stream: id(t)
    };
  }, t.geoTransverseMercator = function () {
    var t = Ed(Yd),
      n = t.center,
      e = t.rotate;
    return t.center = function (t) {
      return arguments.length ? n([-t[1], t[0]]) : [(t = n())[1], -t[0]];
    }, t.rotate = function (t) {
      return arguments.length ? e([t[0], t[1], t.length > 2 ? t[2] + 90 : 90]) : [(t = e())[0], t[1], t[2] - 90];
    }, e([0, 0, 90]).scale(159.155);
  }, t.geoTransverseMercatorRaw = Yd, t.gray = function (t, n) {
    return new ur(t, 0, 0, null == n ? 1 : n);
  }, t.greatest = ot, t.greatestIndex = function (t, e = n) {
    if (1 === e.length) return tt(t, e);
    let r,
      i = -1,
      o = -1;
    for (const n of t) ++o, (i < 0 ? 0 === e(n, n) : e(n, r) > 0) && (r = n, i = o);
    return i;
  }, t.group = C, t.groupSort = function (t, e, r) {
    return (2 !== e.length ? U($(t, e, r), ([t, e], [r, i]) => n(e, i) || n(t, r)) : U(C(t, r), ([t, r], [i, o]) => e(r, o) || n(t, i))).map(([t]) => t);
  }, t.groups = P, t.hcl = dr, t.hierarchy = Gd, t.histogram = Q, t.hsl = He, t.html = Ec, t.image = function (t, n) {
    return new Promise(function (e, r) {
      var i = new Image();
      for (var o in n) i[o] = n[o];
      i.onerror = r, i.onload = function () {
        e(i);
      }, i.src = t;
    });
  }, t.index = function (t, ...n) {
    return F(t, k, R, n);
  }, t.indexes = function (t, ...n) {
    return F(t, Array.from, R, n);
  }, t.interpolate = Gr, t.interpolateArray = function (t, n) {
    return (Ir(n) ? Ur : Or)(t, n);
  }, t.interpolateBasis = Er, t.interpolateBasisClosed = Nr, t.interpolateBlues = Xb, t.interpolateBrBG = ib, t.interpolateBuGn = wb, t.interpolateBuPu = Tb, t.interpolateCividis = function (t) {
    return t = Math.max(0, Math.min(1, t)), "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - 2710.57 * t))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - 67.37 * t))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - 2475.67 * t))))))) + ")";
  }, t.interpolateCool = om, t.interpolateCubehelix = li, t.interpolateCubehelixDefault = rm, t.interpolateCubehelixLong = hi, t.interpolateDate = Br, t.interpolateDiscrete = function (t) {
    var n = t.length;
    return function (e) {
      return t[Math.max(0, Math.min(n - 1, Math.floor(e * n)))];
    };
  }, t.interpolateGnBu = Sb, t.interpolateGreens = Vb, t.interpolateGreys = Zb, t.interpolateHcl = ci, t.interpolateHclLong = fi, t.interpolateHsl = oi, t.interpolateHslLong = ai, t.interpolateHue = function (t, n) {
    var e = Pr(+t, +n);
    return function (t) {
      var n = e(t);
      return n - 360 * Math.floor(n / 360);
    };
  }, t.interpolateInferno = dm, t.interpolateLab = function (t, n) {
    var e = $r((t = ar(t)).l, (n = ar(n)).l),
      r = $r(t.a, n.a),
      i = $r(t.b, n.b),
      o = $r(t.opacity, n.opacity);
    return function (n) {
      return t.l = e(n), t.a = r(n), t.b = i(n), t.opacity = o(n), t + "";
    };
  }, t.interpolateMagma = hm, t.interpolateNumber = Yr, t.interpolateNumberArray = Ur, t.interpolateObject = Lr, t.interpolateOrRd = Nb, t.interpolateOranges = em, t.interpolatePRGn = ab, t.interpolatePiYG = cb, t.interpolatePlasma = pm, t.interpolatePuBu = zb, t.interpolatePuBuGn = Cb, t.interpolatePuOr = sb, t.interpolatePuRd = Db, t.interpolatePurples = Qb, t.interpolateRainbow = function (t) {
    (t < 0 || t > 1) && (t -= Math.floor(t));
    var n = Math.abs(t - .5);
    return am.h = 360 * t - 100, am.s = 1.5 - 1.5 * n, am.l = .8 - .9 * n, am + "";
  }, t.interpolateRdBu = hb, t.interpolateRdGy = pb, t.interpolateRdPu = Fb, t.interpolateRdYlBu = yb, t.interpolateRdYlGn = _b, t.interpolateReds = tm, t.interpolateRgb = Dr, t.interpolateRgbBasis = Fr, t.interpolateRgbBasisClosed = qr, t.interpolateRound = Vr, t.interpolateSinebow = function (t) {
    var n;
    return t = (.5 - t) * Math.PI, um.r = 255 * (n = Math.sin(t)) * n, um.g = 255 * (n = Math.sin(t + cm)) * n, um.b = 255 * (n = Math.sin(t + fm)) * n, um + "";
  }, t.interpolateSpectral = mb, t.interpolateString = Xr, t.interpolateTransformCss = ti, t.interpolateTransformSvg = ni, t.interpolateTurbo = function (t) {
    return t = Math.max(0, Math.min(1, t)), "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - 14825.05 * t))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + 707.56 * t))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - 6838.66 * t))))))) + ")";
  }, t.interpolateViridis = lm, t.interpolateWarm = im, t.interpolateYlGn = Ob, t.interpolateYlGnBu = Ub, t.interpolateYlOrBr = Yb, t.interpolateYlOrRd = jb, t.interpolateZoom = ri, t.interrupt = Gi, t.intersection = function (t, ...n) {
    t = new InternSet(t), n = n.map(vt);
    t: for (const e of t) for (const r of n) if (!r.has(e)) {
      t.delete(e);
      continue t;
    }
    return t;
  }, t.interval = function (t, n, e) {
    var r = new Ei(),
      i = n;
    return null == n ? (r.restart(t, n, e), r) : (r._restart = r.restart, r.restart = function (t, n, e) {
      n = +n, e = null == e ? Ai() : +e, r._restart(function o(a) {
        a += i, r._restart(o, i += n, e), t(a);
      }, n, e);
    }, r.restart(t, n, e), r);
  }, t.isoFormat = D_, t.isoParse = F_, t.json = function (t, n) {
    return fetch(t, n).then(Tc);
  }, t.lab = ar, t.lch = function (t, n, e, r) {
    return 1 === arguments.length ? hr(t) : new pr(e, n, t, null == r ? 1 : r);
  }, t.least = function (t, e = n) {
    let r,
      i = !1;
    if (1 === e.length) {
      let o;
      for (const a of t) {
        const t = e(a);
        (i ? n(t, o) < 0 : 0 === n(t, t)) && (r = a, o = t, i = !0);
      }
    } else for (const n of t) (i ? e(n, r) < 0 : 0 === e(n, n)) && (r = n, i = !0);
    return r;
  }, t.leastIndex = ht, t.line = Bm, t.lineRadial = Wm, t.link = ox, t.linkHorizontal = function () {
    return ox(tx);
  }, t.linkRadial = function () {
    const t = ox(ex);
    return t.angle = t.x, delete t.x, t.radius = t.y, delete t.y, t;
  }, t.linkVertical = function () {
    return ox(nx);
  }, t.local = Qn, t.map = function (t, n) {
    if ("function" != typeof t[Symbol.iterator]) throw new TypeError("values is not iterable");
    if ("function" != typeof n) throw new TypeError("mapper is not a function");
    return Array.from(t, (e, r) => n(e, r, t));
  }, t.matcher = Vt, t.max = J, t.maxIndex = tt, t.mean = function (t, n) {
    let e = 0,
      r = 0;
    if (void 0 === n) for (let n of t) null != n && (n = +n) >= n && (++e, r += n);else {
      let i = -1;
      for (let o of t) null != (o = n(o, ++i, t)) && (o = +o) >= o && (++e, r += o);
    }
    if (e) return r / e;
  }, t.median = function (t, n) {
    return at(t, .5, n);
  }, t.medianIndex = function (t, n) {
    return ct(t, .5, n);
  }, t.merge = ft, t.min = nt, t.minIndex = et, t.mode = function (t, n) {
    const e = new InternMap();
    if (void 0 === n) for (let n of t) null != n && n >= n && e.set(n, (e.get(n) || 0) + 1);else {
      let r = -1;
      for (let i of t) null != (i = n(i, ++r, t)) && i >= i && e.set(i, (e.get(i) || 0) + 1);
    }
    let r,
      i = 0;
    for (const [t, n] of e) n > i && (i = n, r = t);
    return r;
  }, t.namespace = It, t.namespaces = Ut, t.nice = Z, t.now = Ai, t.pack = function () {
    var t = null,
      n = 1,
      e = 1,
      r = np;
    function i(i) {
      const o = ap();
      return i.x = n / 2, i.y = e / 2, t ? i.eachBefore(xp(t)).eachAfter(wp(r, .5, o)).eachBefore(Mp(1)) : i.eachBefore(xp(mp)).eachAfter(wp(np, 1, o)).eachAfter(wp(r, i.r / Math.min(n, e), o)).eachBefore(Mp(Math.min(n, e) / (2 * i.r))), i;
    }
    return i.radius = function (n) {
      return arguments.length ? (t = Jd(n), i) : t;
    }, i.size = function (t) {
      return arguments.length ? (n = +t[0], e = +t[1], i) : [n, e];
    }, i.padding = function (t) {
      return arguments.length ? (r = "function" == typeof t ? t : ep(+t), i) : r;
    }, i;
  }, t.packEnclose = function (t) {
    return up(t, ap());
  }, t.packSiblings = function (t) {
    return bp(t, ap()), t;
  }, t.pairs = function (t, n = st) {
    const e = [];
    let r,
      i = !1;
    for (const o of t) i && e.push(n(r, o)), r = o, i = !0;
    return e;
  }, t.partition = function () {
    var t = 1,
      n = 1,
      e = 0,
      r = !1;
    function i(i) {
      var o = i.height + 1;
      return i.x0 = i.y0 = e, i.x1 = t, i.y1 = n / o, i.eachBefore(function (t, n) {
        return function (r) {
          r.children && Ap(r, r.x0, t * (r.depth + 1) / n, r.x1, t * (r.depth + 2) / n);
          var i = r.x0,
            o = r.y0,
            a = r.x1 - e,
            u = r.y1 - e;
          a < i && (i = a = (i + a) / 2), u < o && (o = u = (o + u) / 2), r.x0 = i, r.y0 = o, r.x1 = a, r.y1 = u;
        };
      }(n, o)), r && i.eachBefore(Tp), i;
    }
    return i.round = function (t) {
      return arguments.length ? (r = !!t, i) : r;
    }, i.size = function (e) {
      return arguments.length ? (t = +e[0], n = +e[1], i) : [t, n];
    }, i.padding = function (t) {
      return arguments.length ? (e = +t, i) : e;
    }, i;
  }, t.path = Ia, t.pathRound = function (t = 3) {
    return new Ua(+t);
  }, t.permute = q, t.pie = function () {
    var t = jm,
      n = Lm,
      e = null,
      r = gm(0),
      i = gm(Sm),
      o = gm(0);
    function a(a) {
      var u,
        c,
        f,
        s,
        l,
        h = (a = Fm(a)).length,
        d = 0,
        p = new Array(h),
        g = new Array(h),
        y = +r.apply(this, arguments),
        v = Math.min(Sm, Math.max(-Sm, i.apply(this, arguments) - y)),
        _ = Math.min(Math.abs(v) / h, o.apply(this, arguments)),
        b = _ * (v < 0 ? -1 : 1);
      for (u = 0; u < h; ++u) (l = g[p[u] = u] = +t(a[u], u, a)) > 0 && (d += l);
      for (null != n ? p.sort(function (t, e) {
        return n(g[t], g[e]);
      }) : null != e && p.sort(function (t, n) {
        return e(a[t], a[n]);
      }), u = 0, f = d ? (v - h * b) / d : 0; u < h; ++u, y = s) c = p[u], s = y + ((l = g[c]) > 0 ? l * f : 0) + b, g[c] = {
        data: a[c],
        index: u,
        value: l,
        startAngle: y,
        endAngle: s,
        padAngle: _
      };
      return g;
    }
    return a.value = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : gm(+n), a) : t;
    }, a.sortValues = function (t) {
      return arguments.length ? (n = t, e = null, a) : n;
    }, a.sort = function (t) {
      return arguments.length ? (e = t, n = null, a) : e;
    }, a.startAngle = function (t) {
      return arguments.length ? (r = "function" == typeof t ? t : gm(+t), a) : r;
    }, a.endAngle = function (t) {
      return arguments.length ? (i = "function" == typeof t ? t : gm(+t), a) : i;
    }, a.padAngle = function (t) {
      return arguments.length ? (o = "function" == typeof t ? t : gm(+t), a) : o;
    }, a;
  }, t.piecewise = di, t.pointRadial = Km, t.pointer = ne, t.pointers = function (t, n) {
    return t.target && (t = te(t), void 0 === n && (n = t.currentTarget), t = t.touches || [t]), Array.from(t, t => ne(t, n));
  }, t.polygonArea = function (t) {
    for (var n, e = -1, r = t.length, i = t[r - 1], o = 0; ++e < r;) n = i, i = t[e], o += n[1] * i[0] - n[0] * i[1];
    return o / 2;
  }, t.polygonCentroid = function (t) {
    for (var n, e, r = -1, i = t.length, o = 0, a = 0, u = t[i - 1], c = 0; ++r < i;) n = u, u = t[r], c += e = n[0] * u[1] - u[0] * n[1], o += (n[0] + u[0]) * e, a += (n[1] + u[1]) * e;
    return [o / (c *= 3), a / c];
  }, t.polygonContains = function (t, n) {
    for (var e, r, i = t.length, o = t[i - 1], a = n[0], u = n[1], c = o[0], f = o[1], s = !1, l = 0; l < i; ++l) e = (o = t[l])[0], (r = o[1]) > u != f > u && a < (c - e) * (u - r) / (f - r) + e && (s = !s), c = e, f = r;
    return s;
  }, t.polygonHull = function (t) {
    if ((e = t.length) < 3) return null;
    var n,
      e,
      r = new Array(e),
      i = new Array(e);
    for (n = 0; n < e; ++n) r[n] = [+t[n][0], +t[n][1], n];
    for (r.sort(Hp), n = 0; n < e; ++n) i[n] = [r[n][0], -r[n][1]];
    var o = Xp(r),
      a = Xp(i),
      u = a[0] === o[0],
      c = a[a.length - 1] === o[o.length - 1],
      f = [];
    for (n = o.length - 1; n >= 0; --n) f.push(t[r[o[n]][2]]);
    for (n = +u; n < a.length - c; ++n) f.push(t[r[a[n]][2]]);
    return f;
  }, t.polygonLength = function (t) {
    for (var n, e, r = -1, i = t.length, o = t[i - 1], a = o[0], u = o[1], c = 0; ++r < i;) n = a, e = u, n -= a = (o = t[r])[0], e -= u = o[1], c += Math.hypot(n, e);
    return c;
  }, t.precisionFixed = sf, t.precisionPrefix = lf, t.precisionRound = hf, t.quadtree = $c, t.quantile = at, t.quantileIndex = ct, t.quantileSorted = ut, t.quantize = function (t, n) {
    for (var e = new Array(n), r = 0; r < n; ++r) e[r] = t(r / (n - 1));
    return e;
  }, t.quickselect = rt, t.radialArea = Zm, t.radialLine = Wm, t.randomBates = Jp, t.randomBernoulli = eg, t.randomBeta = og, t.randomBinomial = ag, t.randomCauchy = cg, t.randomExponential = tg, t.randomGamma = ig, t.randomGeometric = rg, t.randomInt = Wp, t.randomIrwinHall = Qp, t.randomLcg = function (t = Math.random()) {
    let n = 0 | (0 <= t && t < 1 ? t / lg : Math.abs(t));
    return () => (n = 1664525 * n + 1013904223 | 0, lg * (n >>> 0));
  }, t.randomLogNormal = Kp, t.randomLogistic = fg, t.randomNormal = Zp, t.randomPareto = ng, t.randomPoisson = sg, t.randomUniform = Vp, t.randomWeibull = ug, t.range = lt, t.rank = function (t, e = n) {
    if ("function" != typeof t[Symbol.iterator]) throw new TypeError("values is not iterable");
    let r = Array.from(t);
    const i = new Float64Array(r.length);
    2 !== e.length && (r = r.map(e), e = n);
    const o = (t, n) => e(r[t], r[n]);
    let a, u;
    return (t = Uint32Array.from(r, (t, n) => n)).sort(e === n ? (t, n) => O(r[t], r[n]) : I(o)), t.forEach((t, n) => {
      const e = o(t, void 0 === a ? t : a);
      e >= 0 ? ((void 0 === a || e > 0) && (a = t, u = n), i[t] = u) : i[t] = NaN;
    }), i;
  }, t.reduce = function (t, n, e) {
    if ("function" != typeof n) throw new TypeError("reducer is not a function");
    const r = t[Symbol.iterator]();
    let i,
      o,
      a = -1;
    if (arguments.length < 3) {
      if (({
        done: i,
        value: e
      } = r.next()), i) return;
      ++a;
    }
    for (; ({
      done: i,
      value: o
    } = r.next()), !i;) e = n(e, o, ++a, t);
    return e;
  }, t.reverse = function (t) {
    if ("function" != typeof t[Symbol.iterator]) throw new TypeError("values is not iterable");
    return Array.from(t).reverse();
  }, t.rgb = Fe, t.ribbon = function () {
    return Wa();
  }, t.ribbonArrow = function () {
    return Wa(Va);
  }, t.rollup = $, t.rollups = D, t.scaleBand = yg, t.scaleDiverging = function t() {
    var n = Ng(L_()(mg));
    return n.copy = function () {
      return B_(n, t());
    }, dg.apply(n, arguments);
  }, t.scaleDivergingLog = function t() {
    var n = Fg(L_()).domain([.1, 1, 10]);
    return n.copy = function () {
      return B_(n, t()).base(n.base());
    }, dg.apply(n, arguments);
  }, t.scaleDivergingPow = j_, t.scaleDivergingSqrt = function () {
    return j_.apply(null, arguments).exponent(.5);
  }, t.scaleDivergingSymlog = function t() {
    var n = Ig(L_());
    return n.copy = function () {
      return B_(n, t()).constant(n.constant());
    }, dg.apply(n, arguments);
  }, t.scaleIdentity = function t(n) {
    var e;
    function r(t) {
      return null == t || isNaN(t = +t) ? e : t;
    }
    return r.invert = r, r.domain = r.range = function (t) {
      return arguments.length ? (n = Array.from(t, _g), r) : n.slice();
    }, r.unknown = function (t) {
      return arguments.length ? (e = t, r) : e;
    }, r.copy = function () {
      return t(n).unknown(e);
    }, n = arguments.length ? Array.from(n, _g) : [0, 1], Ng(r);
  }, t.scaleImplicit = pg, t.scaleLinear = function t() {
    var n = Sg();
    return n.copy = function () {
      return Tg(n, t());
    }, hg.apply(n, arguments), Ng(n);
  }, t.scaleLog = function t() {
    const n = Fg(Ag()).domain([1, 10]);
    return n.copy = () => Tg(n, t()).base(n.base()), hg.apply(n, arguments), n;
  }, t.scaleOrdinal = gg, t.scalePoint = function () {
    return vg(yg.apply(null, arguments).paddingInner(1));
  }, t.scalePow = jg, t.scaleQuantile = function t() {
    var e,
      r = [],
      i = [],
      o = [];
    function a() {
      var t = 0,
        n = Math.max(1, i.length);
      for (o = new Array(n - 1); ++t < n;) o[t - 1] = ut(r, t / n);
      return u;
    }
    function u(t) {
      return null == t || isNaN(t = +t) ? e : i[s(o, t)];
    }
    return u.invertExtent = function (t) {
      var n = i.indexOf(t);
      return n < 0 ? [NaN, NaN] : [n > 0 ? o[n - 1] : r[0], n < o.length ? o[n] : r[r.length - 1]];
    }, u.domain = function (t) {
      if (!arguments.length) return r.slice();
      r = [];
      for (let n of t) null == n || isNaN(n = +n) || r.push(n);
      return r.sort(n), a();
    }, u.range = function (t) {
      return arguments.length ? (i = Array.from(t), a()) : i.slice();
    }, u.unknown = function (t) {
      return arguments.length ? (e = t, u) : e;
    }, u.quantiles = function () {
      return o.slice();
    }, u.copy = function () {
      return t().domain(r).range(i).unknown(e);
    }, hg.apply(u, arguments);
  }, t.scaleQuantize = function t() {
    var n,
      e = 0,
      r = 1,
      i = 1,
      o = [.5],
      a = [0, 1];
    function u(t) {
      return null != t && t <= t ? a[s(o, t, 0, i)] : n;
    }
    function c() {
      var t = -1;
      for (o = new Array(i); ++t < i;) o[t] = ((t + 1) * r - (t - i) * e) / (i + 1);
      return u;
    }
    return u.domain = function (t) {
      return arguments.length ? ([e, r] = t, e = +e, r = +r, c()) : [e, r];
    }, u.range = function (t) {
      return arguments.length ? (i = (a = Array.from(t)).length - 1, c()) : a.slice();
    }, u.invertExtent = function (t) {
      var n = a.indexOf(t);
      return n < 0 ? [NaN, NaN] : n < 1 ? [e, o[0]] : n >= i ? [o[i - 1], r] : [o[n - 1], o[n]];
    }, u.unknown = function (t) {
      return arguments.length ? (n = t, u) : u;
    }, u.thresholds = function () {
      return o.slice();
    }, u.copy = function () {
      return t().domain([e, r]).range(a).unknown(n);
    }, hg.apply(Ng(u), arguments);
  }, t.scaleRadial = function t() {
    var n,
      e = Sg(),
      r = [0, 1],
      i = !1;
    function o(t) {
      var r = function (t) {
        return Math.sign(t) * Math.sqrt(Math.abs(t));
      }(e(t));
      return isNaN(r) ? n : i ? Math.round(r) : r;
    }
    return o.invert = function (t) {
      return e.invert(Hg(t));
    }, o.domain = function (t) {
      return arguments.length ? (e.domain(t), o) : e.domain();
    }, o.range = function (t) {
      return arguments.length ? (e.range((r = Array.from(t, _g)).map(Hg)), o) : r.slice();
    }, o.rangeRound = function (t) {
      return o.range(t).round(!0);
    }, o.round = function (t) {
      return arguments.length ? (i = !!t, o) : i;
    }, o.clamp = function (t) {
      return arguments.length ? (e.clamp(t), o) : e.clamp();
    }, o.unknown = function (t) {
      return arguments.length ? (n = t, o) : n;
    }, o.copy = function () {
      return t(e.domain(), r).round(i).clamp(e.clamp()).unknown(n);
    }, hg.apply(o, arguments), Ng(o);
  }, t.scaleSequential = function t() {
    var n = Ng(O_()(mg));
    return n.copy = function () {
      return B_(n, t());
    }, dg.apply(n, arguments);
  }, t.scaleSequentialLog = function t() {
    var n = Fg(O_()).domain([1, 10]);
    return n.copy = function () {
      return B_(n, t()).base(n.base());
    }, dg.apply(n, arguments);
  }, t.scaleSequentialPow = Y_, t.scaleSequentialQuantile = function t() {
    var e = [],
      r = mg;
    function i(t) {
      if (null != t && !isNaN(t = +t)) return r((s(e, t, 1) - 1) / (e.length - 1));
    }
    return i.domain = function (t) {
      if (!arguments.length) return e.slice();
      e = [];
      for (let n of t) null == n || isNaN(n = +n) || e.push(n);
      return e.sort(n), i;
    }, i.interpolator = function (t) {
      return arguments.length ? (r = t, i) : r;
    }, i.range = function () {
      return e.map((t, n) => r(n / (e.length - 1)));
    }, i.quantiles = function (t) {
      return Array.from({
        length: t + 1
      }, (n, r) => at(e, r / t));
    }, i.copy = function () {
      return t(r).domain(e);
    }, dg.apply(i, arguments);
  }, t.scaleSequentialSqrt = function () {
    return Y_.apply(null, arguments).exponent(.5);
  }, t.scaleSequentialSymlog = function t() {
    var n = Ig(O_());
    return n.copy = function () {
      return B_(n, t()).constant(n.constant());
    }, dg.apply(n, arguments);
  }, t.scaleSqrt = function () {
    return jg.apply(null, arguments).exponent(.5);
  }, t.scaleSymlog = function t() {
    var n = Ig(Ag());
    return n.copy = function () {
      return Tg(n, t()).constant(n.constant());
    }, hg.apply(n, arguments);
  }, t.scaleThreshold = function t() {
    var n,
      e = [.5],
      r = [0, 1],
      i = 1;
    function o(t) {
      return null != t && t <= t ? r[s(e, t, 0, i)] : n;
    }
    return o.domain = function (t) {
      return arguments.length ? (e = Array.from(t), i = Math.min(e.length, r.length - 1), o) : e.slice();
    }, o.range = function (t) {
      return arguments.length ? (r = Array.from(t), i = Math.min(e.length, r.length - 1), o) : r.slice();
    }, o.invertExtent = function (t) {
      var n = r.indexOf(t);
      return [e[n - 1], e[n]];
    }, o.unknown = function (t) {
      return arguments.length ? (n = t, o) : n;
    }, o.copy = function () {
      return t().domain(e).range(r).unknown(n);
    }, hg.apply(o, arguments);
  }, t.scaleTime = function () {
    return hg.apply(I_(uv, cv, tv, Zy, xy, py, sy, ay, iy, t.timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
  }, t.scaleUtc = function () {
    return hg.apply(I_(ov, av, ev, Qy, Fy, yy, hy, cy, iy, t.utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
  }, t.scan = function (t, n) {
    const e = ht(t, n);
    return e < 0 ? void 0 : e;
  }, t.schemeAccent = G_, t.schemeBlues = Hb, t.schemeBrBG = rb, t.schemeBuGn = xb, t.schemeBuPu = Mb, t.schemeCategory10 = X_, t.schemeDark2 = V_, t.schemeGnBu = Ab, t.schemeGreens = Gb, t.schemeGreys = Wb, t.schemeOrRd = Eb, t.schemeOranges = nm, t.schemePRGn = ob, t.schemePaired = W_, t.schemePastel1 = Z_, t.schemePastel2 = K_, t.schemePiYG = ub, t.schemePuBu = Pb, t.schemePuBuGn = kb, t.schemePuOr = fb, t.schemePuRd = $b, t.schemePurples = Kb, t.schemeRdBu = lb, t.schemeRdGy = db, t.schemeRdPu = Rb, t.schemeRdYlBu = gb, t.schemeRdYlGn = vb, t.schemeReds = Jb, t.schemeSet1 = Q_, t.schemeSet2 = J_, t.schemeSet3 = tb, t.schemeSpectral = bb, t.schemeTableau10 = nb, t.schemeYlGn = Ib, t.schemeYlGnBu = qb, t.schemeYlOrBr = Bb, t.schemeYlOrRd = Lb, t.select = Zn, t.selectAll = function (t) {
    return "string" == typeof t ? new Vn([document.querySelectorAll(t)], [document.documentElement]) : new Vn([Ht(t)], Gn);
  }, t.selection = Wn, t.selector = jt, t.selectorAll = Gt, t.shuffle = dt, t.shuffler = pt, t.some = function (t, n) {
    if ("function" != typeof n) throw new TypeError("test is not a function");
    let e = -1;
    for (const r of t) if (n(r, ++e, t)) return !0;
    return !1;
  }, t.sort = U, t.stack = function () {
    var t = gm([]),
      n = hw,
      e = lw,
      r = dw;
    function i(i) {
      var o,
        a,
        u = Array.from(t.apply(this, arguments), pw),
        c = u.length,
        f = -1;
      for (const t of i) for (o = 0, ++f; o < c; ++o) (u[o][f] = [0, +r(t, u[o].key, f, i)]).data = t;
      for (o = 0, a = Fm(n(u)); o < c; ++o) u[a[o]].index = o;
      return e(u, a), u;
    }
    return i.keys = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : gm(Array.from(n)), i) : t;
    }, i.value = function (t) {
      return arguments.length ? (r = "function" == typeof t ? t : gm(+t), i) : r;
    }, i.order = function (t) {
      return arguments.length ? (n = null == t ? hw : "function" == typeof t ? t : gm(Array.from(t)), i) : n;
    }, i.offset = function (t) {
      return arguments.length ? (e = null == t ? lw : t, i) : e;
    }, i;
  }, t.stackOffsetDiverging = function (t, n) {
    if ((u = t.length) > 0) for (var e, r, i, o, a, u, c = 0, f = t[n[0]].length; c < f; ++c) for (o = a = 0, e = 0; e < u; ++e) (i = (r = t[n[e]][c])[1] - r[0]) > 0 ? (r[0] = o, r[1] = o += i) : i < 0 ? (r[1] = a, r[0] = a += i) : (r[0] = 0, r[1] = i);
  }, t.stackOffsetExpand = function (t, n) {
    if ((r = t.length) > 0) {
      for (var e, r, i, o = 0, a = t[0].length; o < a; ++o) {
        for (i = e = 0; e < r; ++e) i += t[e][o][1] || 0;
        if (i) for (e = 0; e < r; ++e) t[e][o][1] /= i;
      }
      lw(t, n);
    }
  }, t.stackOffsetNone = lw, t.stackOffsetSilhouette = function (t, n) {
    if ((e = t.length) > 0) {
      for (var e, r = 0, i = t[n[0]], o = i.length; r < o; ++r) {
        for (var a = 0, u = 0; a < e; ++a) u += t[a][r][1] || 0;
        i[r][1] += i[r][0] = -u / 2;
      }
      lw(t, n);
    }
  }, t.stackOffsetWiggle = function (t, n) {
    if ((i = t.length) > 0 && (r = (e = t[n[0]]).length) > 0) {
      for (var e, r, i, o = 0, a = 1; a < r; ++a) {
        for (var u = 0, c = 0, f = 0; u < i; ++u) {
          for (var s = t[n[u]], l = s[a][1] || 0, h = (l - (s[a - 1][1] || 0)) / 2, d = 0; d < u; ++d) {
            var p = t[n[d]];
            h += (p[a][1] || 0) - (p[a - 1][1] || 0);
          }
          c += l, f += h * l;
        }
        e[a - 1][1] += e[a - 1][0] = o, c && (o -= f / c);
      }
      e[a - 1][1] += e[a - 1][0] = o, lw(t, n);
    }
  }, t.stackOrderAppearance = gw, t.stackOrderAscending = vw, t.stackOrderDescending = function (t) {
    return vw(t).reverse();
  }, t.stackOrderInsideOut = function (t) {
    var n,
      e,
      r = t.length,
      i = t.map(_w),
      o = gw(t),
      a = 0,
      u = 0,
      c = [],
      f = [];
    for (n = 0; n < r; ++n) e = o[n], a < u ? (a += i[e], c.push(e)) : (u += i[e], f.push(e));
    return f.reverse().concat(c);
  }, t.stackOrderNone = hw, t.stackOrderReverse = function (t) {
    return hw(t).reverse();
  }, t.stratify = function () {
    var t,
      n = kp,
      e = Cp;
    function r(r) {
      var i,
        o,
        a,
        u,
        c,
        f,
        s,
        l,
        h = Array.from(r),
        d = n,
        p = e,
        g = new Map();
      if (null != t) {
        const n = h.map((n, e) => function (t) {
            t = `${t}`;
            let n = t.length;
            zp(t, n - 1) && !zp(t, n - 2) && (t = t.slice(0, -1));
            return "/" === t[0] ? t : `/${t}`;
          }(t(n, e, r))),
          e = n.map(Pp),
          i = new Set(n).add("");
        for (const t of e) i.has(t) || (i.add(t), n.push(t), e.push(Pp(t)), h.push(Np));
        d = (t, e) => n[e], p = (t, n) => e[n];
      }
      for (a = 0, i = h.length; a < i; ++a) o = h[a], f = h[a] = new Qd(o), null != (s = d(o, a, r)) && (s += "") && (l = f.id = s, g.set(l, g.has(l) ? Ep : f)), null != (s = p(o, a, r)) && (s += "") && (f.parent = s);
      for (a = 0; a < i; ++a) if (s = (f = h[a]).parent) {
        if (!(c = g.get(s))) throw new Error("missing: " + s);
        if (c === Ep) throw new Error("ambiguous: " + s);
        c.children ? c.children.push(f) : c.children = [f], f.parent = c;
      } else {
        if (u) throw new Error("multiple roots");
        u = f;
      }
      if (!u) throw new Error("no root");
      if (null != t) {
        for (; u.data === Np && 1 === u.children.length;) u = u.children[0], --i;
        for (let t = h.length - 1; t >= 0 && (f = h[t]).data === Np; --t) f.data = null;
      }
      if (u.parent = Sp, u.eachBefore(function (t) {
        t.depth = t.parent.depth + 1, --i;
      }).eachBefore(Kd), u.parent = null, i > 0) throw new Error("cycle");
      return u;
    }
    return r.id = function (t) {
      return arguments.length ? (n = Jd(t), r) : n;
    }, r.parentId = function (t) {
      return arguments.length ? (e = Jd(t), r) : e;
    }, r.path = function (n) {
      return arguments.length ? (t = Jd(n), r) : t;
    }, r;
  }, t.style = _n, t.subset = function (t, n) {
    return _t(n, t);
  }, t.sum = function (t, n) {
    let e = 0;
    if (void 0 === n) for (let n of t) (n = +n) && (e += n);else {
      let r = -1;
      for (let i of t) (i = +n(i, ++r, t)) && (e += i);
    }
    return e;
  }, t.superset = _t, t.svg = Nc, t.symbol = function (t, n) {
    let e = null,
      r = Nm(i);
    function i() {
      let i;
      if (e || (e = i = r()), t.apply(this, arguments).draw(e, +n.apply(this, arguments)), i) return e = null, i + "" || null;
    }
    return t = "function" == typeof t ? t : gm(t || cx), n = "function" == typeof n ? n : gm(void 0 === n ? 64 : +n), i.type = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : gm(n), i) : t;
    }, i.size = function (t) {
      return arguments.length ? (n = "function" == typeof t ? t : gm(+t), i) : n;
    }, i.context = function (t) {
      return arguments.length ? (e = null == t ? null : t, i) : e;
    }, i;
  }, t.symbolAsterisk = ux, t.symbolCircle = cx, t.symbolCross = fx, t.symbolDiamond = hx, t.symbolDiamond2 = dx, t.symbolPlus = px, t.symbolSquare = gx, t.symbolSquare2 = yx, t.symbolStar = mx, t.symbolTimes = Cx, t.symbolTriangle = wx, t.symbolTriangle2 = Tx, t.symbolWye = kx, t.symbolX = Cx, t.symbols = Px, t.symbolsFill = Px, t.symbolsStroke = zx, t.text = mc, t.thresholdFreedmanDiaconis = function (t, n, e) {
    const r = v(t),
      i = at(t, .75) - at(t, .25);
    return r && i ? Math.ceil((e - n) / (2 * i * Math.pow(r, -1 / 3))) : 1;
  }, t.thresholdScott = function (t, n, e) {
    const r = v(t),
      i = w(t);
    return r && i ? Math.ceil((e - n) * Math.cbrt(r) / (3.49 * i)) : 1;
  }, t.thresholdSturges = K, t.tickFormat = Eg, t.tickIncrement = V, t.tickStep = W, t.ticks = G, t.timeDay = py, t.timeDays = gy, t.timeFormatDefaultLocale = P_, t.timeFormatLocale = hv, t.timeFriday = Sy, t.timeFridays = $y, t.timeHour = sy, t.timeHours = ly, t.timeInterval = Vg, t.timeMillisecond = Wg, t.timeMilliseconds = Zg, t.timeMinute = ay, t.timeMinutes = uy, t.timeMonday = wy, t.timeMondays = ky, t.timeMonth = Zy, t.timeMonths = Ky, t.timeSaturday = Ey, t.timeSaturdays = Dy, t.timeSecond = iy, t.timeSeconds = oy, t.timeSunday = xy, t.timeSundays = Ny, t.timeThursday = Ay, t.timeThursdays = zy, t.timeTickInterval = cv, t.timeTicks = uv, t.timeTuesday = My, t.timeTuesdays = Cy, t.timeWednesday = Ty, t.timeWednesdays = Py, t.timeWeek = xy, t.timeWeeks = Ny, t.timeYear = tv, t.timeYears = nv, t.timeout = $i, t.timer = Ni, t.timerFlush = ki, t.transition = go, t.transpose = gt, t.tree = function () {
    var t = $p,
      n = 1,
      e = 1,
      r = null;
    function i(i) {
      var c = function (t) {
        for (var n, e, r, i, o, a = new Up(t, 0), u = [a]; n = u.pop();) if (r = n._.children) for (n.children = new Array(o = r.length), i = o - 1; i >= 0; --i) u.push(e = n.children[i] = new Up(r[i], i)), e.parent = n;
        return (a.parent = new Up(null, 0)).children = [a], a;
      }(i);
      if (c.eachAfter(o), c.parent.m = -c.z, c.eachBefore(a), r) i.eachBefore(u);else {
        var f = i,
          s = i,
          l = i;
        i.eachBefore(function (t) {
          t.x < f.x && (f = t), t.x > s.x && (s = t), t.depth > l.depth && (l = t);
        });
        var h = f === s ? 1 : t(f, s) / 2,
          d = h - f.x,
          p = n / (s.x + h + d),
          g = e / (l.depth || 1);
        i.eachBefore(function (t) {
          t.x = (t.x + d) * p, t.y = t.depth * g;
        });
      }
      return i;
    }
    function o(n) {
      var e = n.children,
        r = n.parent.children,
        i = n.i ? r[n.i - 1] : null;
      if (e) {
        !function (t) {
          for (var n, e = 0, r = 0, i = t.children, o = i.length; --o >= 0;) (n = i[o]).z += e, n.m += e, e += n.s + (r += n.c);
        }(n);
        var o = (e[0].z + e[e.length - 1].z) / 2;
        i ? (n.z = i.z + t(n._, i._), n.m = n.z - o) : n.z = o;
      } else i && (n.z = i.z + t(n._, i._));
      n.parent.A = function (n, e, r) {
        if (e) {
          for (var i, o = n, a = n, u = e, c = o.parent.children[0], f = o.m, s = a.m, l = u.m, h = c.m; u = Rp(u), o = Dp(o), u && o;) c = Dp(c), (a = Rp(a)).a = n, (i = u.z + l - o.z - f + t(u._, o._)) > 0 && (Fp(qp(u, n, r), n, i), f += i, s += i), l += u.m, f += o.m, h += c.m, s += a.m;
          u && !Rp(a) && (a.t = u, a.m += l - s), o && !Dp(c) && (c.t = o, c.m += f - h, r = n);
        }
        return r;
      }(n, i, n.parent.A || r[0]);
    }
    function a(t) {
      t._.x = t.z + t.parent.m, t.m += t.parent.m;
    }
    function u(t) {
      t.x *= n, t.y = t.depth * e;
    }
    return i.separation = function (n) {
      return arguments.length ? (t = n, i) : t;
    }, i.size = function (t) {
      return arguments.length ? (r = !1, n = +t[0], e = +t[1], i) : r ? null : [n, e];
    }, i.nodeSize = function (t) {
      return arguments.length ? (r = !0, n = +t[0], e = +t[1], i) : r ? [n, e] : null;
    }, i;
  }, t.treemap = function () {
    var t = Yp,
      n = !1,
      e = 1,
      r = 1,
      i = [0],
      o = np,
      a = np,
      u = np,
      c = np,
      f = np;
    function s(t) {
      return t.x0 = t.y0 = 0, t.x1 = e, t.y1 = r, t.eachBefore(l), i = [0], n && t.eachBefore(Tp), t;
    }
    function l(n) {
      var e = i[n.depth],
        r = n.x0 + e,
        s = n.y0 + e,
        l = n.x1 - e,
        h = n.y1 - e;
      l < r && (r = l = (r + l) / 2), h < s && (s = h = (s + h) / 2), n.x0 = r, n.y0 = s, n.x1 = l, n.y1 = h, n.children && (e = i[n.depth + 1] = o(n) / 2, r += f(n) - e, s += a(n) - e, (l -= u(n) - e) < r && (r = l = (r + l) / 2), (h -= c(n) - e) < s && (s = h = (s + h) / 2), t(n, r, s, l, h));
    }
    return s.round = function (t) {
      return arguments.length ? (n = !!t, s) : n;
    }, s.size = function (t) {
      return arguments.length ? (e = +t[0], r = +t[1], s) : [e, r];
    }, s.tile = function (n) {
      return arguments.length ? (t = tp(n), s) : t;
    }, s.padding = function (t) {
      return arguments.length ? s.paddingInner(t).paddingOuter(t) : s.paddingInner();
    }, s.paddingInner = function (t) {
      return arguments.length ? (o = "function" == typeof t ? t : ep(+t), s) : o;
    }, s.paddingOuter = function (t) {
      return arguments.length ? s.paddingTop(t).paddingRight(t).paddingBottom(t).paddingLeft(t) : s.paddingTop();
    }, s.paddingTop = function (t) {
      return arguments.length ? (a = "function" == typeof t ? t : ep(+t), s) : a;
    }, s.paddingRight = function (t) {
      return arguments.length ? (u = "function" == typeof t ? t : ep(+t), s) : u;
    }, s.paddingBottom = function (t) {
      return arguments.length ? (c = "function" == typeof t ? t : ep(+t), s) : c;
    }, s.paddingLeft = function (t) {
      return arguments.length ? (f = "function" == typeof t ? t : ep(+t), s) : f;
    }, s;
  }, t.treemapBinary = function (t, n, e, r, i) {
    var o,
      a,
      u = t.children,
      c = u.length,
      f = new Array(c + 1);
    for (f[0] = a = o = 0; o < c; ++o) f[o + 1] = a += u[o].value;
    !function t(n, e, r, i, o, a, c) {
      if (n >= e - 1) {
        var s = u[n];
        return s.x0 = i, s.y0 = o, s.x1 = a, void (s.y1 = c);
      }
      var l = f[n],
        h = r / 2 + l,
        d = n + 1,
        p = e - 1;
      for (; d < p;) {
        var g = d + p >>> 1;
        f[g] < h ? d = g + 1 : p = g;
      }
      h - f[d - 1] < f[d] - h && n + 1 < d && --d;
      var y = f[d] - l,
        v = r - y;
      if (a - i > c - o) {
        var _ = r ? (i * v + a * y) / r : a;
        t(n, d, y, i, o, _, c), t(d, e, v, _, o, a, c);
      } else {
        var b = r ? (o * v + c * y) / r : c;
        t(n, d, y, i, o, a, b), t(d, e, v, i, b, a, c);
      }
    }(0, c, t.value, n, e, r, i);
  }, t.treemapDice = Ap, t.treemapResquarify = Lp, t.treemapSlice = Ip, t.treemapSliceDice = function (t, n, e, r, i) {
    (1 & t.depth ? Ip : Ap)(t, n, e, r, i);
  }, t.treemapSquarify = Yp, t.tsv = Mc, t.tsvFormat = lc, t.tsvFormatBody = hc, t.tsvFormatRow = pc, t.tsvFormatRows = dc, t.tsvFormatValue = gc, t.tsvParse = fc, t.tsvParseRows = sc, t.union = function (...t) {
    const n = new InternSet();
    for (const e of t) for (const t of e) n.add(t);
    return n;
  }, t.unixDay = _y, t.unixDays = by, t.utcDay = yy, t.utcDays = vy, t.utcFriday = By, t.utcFridays = Vy, t.utcHour = hy, t.utcHours = dy, t.utcMillisecond = Wg, t.utcMilliseconds = Zg, t.utcMinute = cy, t.utcMinutes = fy, t.utcMonday = qy, t.utcMondays = jy, t.utcMonth = Qy, t.utcMonths = Jy, t.utcSaturday = Yy, t.utcSaturdays = Wy, t.utcSecond = iy, t.utcSeconds = oy, t.utcSunday = Fy, t.utcSundays = Ly, t.utcThursday = Oy, t.utcThursdays = Gy, t.utcTickInterval = av, t.utcTicks = ov, t.utcTuesday = Uy, t.utcTuesdays = Hy, t.utcWednesday = Iy, t.utcWednesdays = Xy, t.utcWeek = Fy, t.utcWeeks = Ly, t.utcYear = ev, t.utcYears = rv, t.variance = x, t.version = "7.8.5", t.window = pn, t.xml = Sc, t.zip = function () {
    return gt(arguments);
  }, t.zoom = function () {
    var t,
      n,
      e,
      r = Sw,
      i = Ew,
      o = Pw,
      a = kw,
      u = Cw,
      c = [0, 1 / 0],
      f = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]],
      s = 250,
      l = ri,
      h = $t("start", "zoom", "end"),
      d = 500,
      p = 150,
      g = 0,
      y = 10;
    function v(t) {
      t.property("__zoom", Nw).on("wheel.zoom", T, {
        passive: !1
      }).on("mousedown.zoom", A).on("dblclick.zoom", S).filter(u).on("touchstart.zoom", E).on("touchmove.zoom", N).on("touchend.zoom touchcancel.zoom", k).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function _(t, n) {
      return (n = Math.max(c[0], Math.min(c[1], n))) === t.k ? t : new xw(n, t.x, t.y);
    }
    function b(t, n, e) {
      var r = n[0] - e[0] * t.k,
        i = n[1] - e[1] * t.k;
      return r === t.x && i === t.y ? t : new xw(t.k, r, i);
    }
    function m(t) {
      return [(+t[0][0] + +t[1][0]) / 2, (+t[0][1] + +t[1][1]) / 2];
    }
    function x(t, n, e, r) {
      t.on("start.zoom", function () {
        w(this, arguments).event(r).start();
      }).on("interrupt.zoom end.zoom", function () {
        w(this, arguments).event(r).end();
      }).tween("zoom", function () {
        var t = this,
          o = arguments,
          a = w(t, o).event(r),
          u = i.apply(t, o),
          c = null == e ? m(u) : "function" == typeof e ? e.apply(t, o) : e,
          f = Math.max(u[1][0] - u[0][0], u[1][1] - u[0][1]),
          s = t.__zoom,
          h = "function" == typeof n ? n.apply(t, o) : n,
          d = l(s.invert(c).concat(f / s.k), h.invert(c).concat(f / h.k));
        return function (t) {
          if (1 === t) t = h;else {
            var n = d(t),
              e = f / n[2];
            t = new xw(e, c[0] - n[0] * e, c[1] - n[1] * e);
          }
          a.zoom(null, t);
        };
      });
    }
    function w(t, n, e) {
      return !e && t.__zooming || new M(t, n);
    }
    function M(t, n) {
      this.that = t, this.args = n, this.active = 0, this.sourceEvent = null, this.extent = i.apply(t, n), this.taps = 0;
    }
    function T(t, ...n) {
      if (r.apply(this, arguments)) {
        var e = w(this, n).event(t),
          i = this.__zoom,
          u = Math.max(c[0], Math.min(c[1], i.k * Math.pow(2, a.apply(this, arguments)))),
          s = ne(t);
        if (e.wheel) e.mouse[0][0] === s[0] && e.mouse[0][1] === s[1] || (e.mouse[1] = i.invert(e.mouse[0] = s)), clearTimeout(e.wheel);else {
          if (i.k === u) return;
          e.mouse = [s, i.invert(s)], Gi(this), e.start();
        }
        Aw(t), e.wheel = setTimeout(function () {
          e.wheel = null, e.end();
        }, p), e.zoom("mouse", o(b(_(i, u), e.mouse[0], e.mouse[1]), e.extent, f));
      }
    }
    function A(t, ...n) {
      if (!e && r.apply(this, arguments)) {
        var i = t.currentTarget,
          a = w(this, n, !0).event(t),
          u = Zn(t.view).on("mousemove.zoom", function (t) {
            if (Aw(t), !a.moved) {
              var n = t.clientX - s,
                e = t.clientY - l;
              a.moved = n * n + e * e > g;
            }
            a.event(t).zoom("mouse", o(b(a.that.__zoom, a.mouse[0] = ne(t, i), a.mouse[1]), a.extent, f));
          }, !0).on("mouseup.zoom", function (t) {
            u.on("mousemove.zoom mouseup.zoom", null), ue(t.view, a.moved), Aw(t), a.event(t).end();
          }, !0),
          c = ne(t, i),
          s = t.clientX,
          l = t.clientY;
        ae(t.view), Tw(t), a.mouse = [c, this.__zoom.invert(c)], Gi(this), a.start();
      }
    }
    function S(t, ...n) {
      if (r.apply(this, arguments)) {
        var e = this.__zoom,
          a = ne(t.changedTouches ? t.changedTouches[0] : t, this),
          u = e.invert(a),
          c = e.k * (t.shiftKey ? .5 : 2),
          l = o(b(_(e, c), a, u), i.apply(this, n), f);
        Aw(t), s > 0 ? Zn(this).transition().duration(s).call(x, l, a, t) : Zn(this).call(v.transform, l, a, t);
      }
    }
    function E(e, ...i) {
      if (r.apply(this, arguments)) {
        var o,
          a,
          u,
          c,
          f = e.touches,
          s = f.length,
          l = w(this, i, e.changedTouches.length === s).event(e);
        for (Tw(e), a = 0; a < s; ++a) c = [c = ne(u = f[a], this), this.__zoom.invert(c), u.identifier], l.touch0 ? l.touch1 || l.touch0[2] === c[2] || (l.touch1 = c, l.taps = 0) : (l.touch0 = c, o = !0, l.taps = 1 + !!t);
        t && (t = clearTimeout(t)), o && (l.taps < 2 && (n = c[0], t = setTimeout(function () {
          t = null;
        }, d)), Gi(this), l.start());
      }
    }
    function N(t, ...n) {
      if (this.__zooming) {
        var e,
          r,
          i,
          a,
          u = w(this, n).event(t),
          c = t.changedTouches,
          s = c.length;
        for (Aw(t), e = 0; e < s; ++e) i = ne(r = c[e], this), u.touch0 && u.touch0[2] === r.identifier ? u.touch0[0] = i : u.touch1 && u.touch1[2] === r.identifier && (u.touch1[0] = i);
        if (r = u.that.__zoom, u.touch1) {
          var l = u.touch0[0],
            h = u.touch0[1],
            d = u.touch1[0],
            p = u.touch1[1],
            g = (g = d[0] - l[0]) * g + (g = d[1] - l[1]) * g,
            y = (y = p[0] - h[0]) * y + (y = p[1] - h[1]) * y;
          r = _(r, Math.sqrt(g / y)), i = [(l[0] + d[0]) / 2, (l[1] + d[1]) / 2], a = [(h[0] + p[0]) / 2, (h[1] + p[1]) / 2];
        } else {
          if (!u.touch0) return;
          i = u.touch0[0], a = u.touch0[1];
        }
        u.zoom("touch", o(b(r, i, a), u.extent, f));
      }
    }
    function k(t, ...r) {
      if (this.__zooming) {
        var i,
          o,
          a = w(this, r).event(t),
          u = t.changedTouches,
          c = u.length;
        for (Tw(t), e && clearTimeout(e), e = setTimeout(function () {
          e = null;
        }, d), i = 0; i < c; ++i) o = u[i], a.touch0 && a.touch0[2] === o.identifier ? delete a.touch0 : a.touch1 && a.touch1[2] === o.identifier && delete a.touch1;
        if (a.touch1 && !a.touch0 && (a.touch0 = a.touch1, delete a.touch1), a.touch0) a.touch0[1] = this.__zoom.invert(a.touch0[0]);else if (a.end(), 2 === a.taps && (o = ne(o, this), Math.hypot(n[0] - o[0], n[1] - o[1]) < y)) {
          var f = Zn(this).on("dblclick.zoom");
          f && f.apply(this, arguments);
        }
      }
    }
    return v.transform = function (t, n, e, r) {
      var i = t.selection ? t.selection() : t;
      i.property("__zoom", Nw), t !== i ? x(t, n, e, r) : i.interrupt().each(function () {
        w(this, arguments).event(r).start().zoom(null, "function" == typeof n ? n.apply(this, arguments) : n).end();
      });
    }, v.scaleBy = function (t, n, e, r) {
      v.scaleTo(t, function () {
        return this.__zoom.k * ("function" == typeof n ? n.apply(this, arguments) : n);
      }, e, r);
    }, v.scaleTo = function (t, n, e, r) {
      v.transform(t, function () {
        var t = i.apply(this, arguments),
          r = this.__zoom,
          a = null == e ? m(t) : "function" == typeof e ? e.apply(this, arguments) : e,
          u = r.invert(a),
          c = "function" == typeof n ? n.apply(this, arguments) : n;
        return o(b(_(r, c), a, u), t, f);
      }, e, r);
    }, v.translateBy = function (t, n, e, r) {
      v.transform(t, function () {
        return o(this.__zoom.translate("function" == typeof n ? n.apply(this, arguments) : n, "function" == typeof e ? e.apply(this, arguments) : e), i.apply(this, arguments), f);
      }, null, r);
    }, v.translateTo = function (t, n, e, r, a) {
      v.transform(t, function () {
        var t = i.apply(this, arguments),
          a = this.__zoom,
          u = null == r ? m(t) : "function" == typeof r ? r.apply(this, arguments) : r;
        return o(ww.translate(u[0], u[1]).scale(a.k).translate("function" == typeof n ? -n.apply(this, arguments) : -n, "function" == typeof e ? -e.apply(this, arguments) : -e), t, f);
      }, r, a);
    }, M.prototype = {
      event: function (t) {
        return t && (this.sourceEvent = t), this;
      },
      start: function () {
        return 1 == ++this.active && (this.that.__zooming = this, this.emit("start")), this;
      },
      zoom: function (t, n) {
        return this.mouse && "mouse" !== t && (this.mouse[1] = n.invert(this.mouse[0])), this.touch0 && "touch" !== t && (this.touch0[1] = n.invert(this.touch0[0])), this.touch1 && "touch" !== t && (this.touch1[1] = n.invert(this.touch1[0])), this.that.__zoom = n, this.emit("zoom"), this;
      },
      end: function () {
        return 0 == --this.active && (delete this.that.__zooming, this.emit("end")), this;
      },
      emit: function (t) {
        var n = Zn(this.that).datum();
        h.call(t, this.that, new mw(t, {
          sourceEvent: this.sourceEvent,
          target: v,
          type: t,
          transform: this.that.__zoom,
          dispatch: h
        }), n);
      }
    }, v.wheelDelta = function (t) {
      return arguments.length ? (a = "function" == typeof t ? t : bw(+t), v) : a;
    }, v.filter = function (t) {
      return arguments.length ? (r = "function" == typeof t ? t : bw(!!t), v) : r;
    }, v.touchable = function (t) {
      return arguments.length ? (u = "function" == typeof t ? t : bw(!!t), v) : u;
    }, v.extent = function (t) {
      return arguments.length ? (i = "function" == typeof t ? t : bw([[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]]), v) : i;
    }, v.scaleExtent = function (t) {
      return arguments.length ? (c[0] = +t[0], c[1] = +t[1], v) : [c[0], c[1]];
    }, v.translateExtent = function (t) {
      return arguments.length ? (f[0][0] = +t[0][0], f[1][0] = +t[1][0], f[0][1] = +t[0][1], f[1][1] = +t[1][1], v) : [[f[0][0], f[0][1]], [f[1][0], f[1][1]]];
    }, v.constrain = function (t) {
      return arguments.length ? (o = t, v) : o;
    }, v.duration = function (t) {
      return arguments.length ? (s = +t, v) : s;
    }, v.interpolate = function (t) {
      return arguments.length ? (l = t, v) : l;
    }, v.on = function () {
      var t = h.on.apply(h, arguments);
      return t === h ? v : t;
    }, v.clickDistance = function (t) {
      return arguments.length ? (g = (t = +t) * t, v) : Math.sqrt(g);
    }, v.tapDistance = function (t) {
      return arguments.length ? (y = +t, v) : y;
    }, v;
  }, t.zoomIdentity = ww, t.zoomTransform = Mw;
});

},{}],5:[function(require,module,exports){
const d3 = require("../d3.min.js");
const colorList = [[0.2, 0.2, 0.2], [219 / 255, 68 / 255, 55 / 255], [244 / 255, 180 / 255, 0], [14 / 255, 157 / 255, 88 / 255], [88 / 255, 81 / 255, 216 / 255], [192 / 255, 53 / 255, 132 / 255], [255 / 255, 48 / 255, 108 / 255], [88 / 255, 81 / 255, 216 / 255], [255 / 255, 220 / 255, 128 / 255], [137 / 255, 211 / 255, 223 / 255], [99 / 255, 193 / 255, 160 / 255], [255 / 255, 153 / 255, 0], [66 / 255, 133 / 255, 244 / 255], [0, 0, 0], [248 / 255, 0, 0]];
exports.colorList = colorList;
exports.funcs = {
  "clusters": settings => {
    var rng = d3.randomNormal(0, settings.std);
    var xy = [];
    var cols = [];
    for (var i = 0; i < settings.n / settings.groups; i++) {
      // not perfectly uniform in entire area.
      // Also not exactly N, but I don't care about the details.
      var x = Math.random() * 2 - 1,
        y = Math.random() * 2 - 1;
      for (var j = 0; j < settings.groups; j++) {
        // weird implementation.
        var l = rng();
        var ang = Math.random() * 2 * Math.PI;
        var nx = l * Math.cos(ang);
        var ny = l * Math.sin(ang);
        xy.push([nx + x, ny + y]);
        cols.push(colorList[0]);
      }
    }
    return {
      xy: xy,
      cols: cols
    };
  },
  "spiral": settings => {
    var R = 2 * Math.PI;
    var xy = [];
    var cols = [];
    for (var i = 0; i < settings.n / 2; i++) {
      var r = Math.random() * R + 2;
      var x = r * Math.cos(r) / 10;
      var y = r * Math.sin(r) / 10;
      var dx = Math.random() * 0.1;
      var dy = Math.random() * 0.1;
      xy.push([dx + x, dy + y]);
      cols.push(colorList[0]);
    }
    for (var i = 0; i < settings.n / 2; i++) {
      var r = Math.random() * R + 2;
      var x = r * Math.cos(r + Math.PI) / 8;
      var y = r * Math.sin(r + Math.PI) / 8;
      var dx = Math.random() * 0.1;
      var dy = Math.random() * 0.1;
      xy.push([dx + x, dy + y]);
      cols.push(colorList[0]);
    }
    return {
      xy: xy,
      cols: cols
    };
  },
  "uniform": settings => {
    var xy = [];
    var cols = [];
    for (var i = 0; i < settings.n; i++) {
      var x = Math.random() * 2 - 1,
        y = Math.random() * 2 - 1;
      xy.push([x, y]);
      cols.push(colorList[0]);
    }
    return {
      xy: xy,
      cols: cols
    };
  },
  "circles": settings => {
    var xy = [];
    var cols = [];
    var smallCircleRadius = 0.2;
    for (var i = 0; i < Math.floor(settings.n * 1 / 4); i++) {
      var randR = Math.random() * smallCircleRadius;
      var randTheta = Math.random() * Math.PI * 2;
      var x = randR * Math.cos(randTheta);
      var y = randR * Math.sin(randTheta);
      xy.push([x, y]);
      cols.push(colorList[0]);
    }
    var bigCircleRadius = 1;
    var gap = 0.5;
    for (var i = 0; i < Math.floor(settings.n * 3 / 4); i++) {
      var randR = Math.random() * (bigCircleRadius - gap - smallCircleRadius) + gap;
      var randTheta = Math.random() * Math.PI * 2;
      var x = randR * Math.cos(randTheta);
      var y = randR * Math.sin(randTheta);
      xy.push([x, y]);
      cols.push(colorList[0]);
    }
    return {
      xy: xy,
      cols: cols
    };
  },
  "Us": settings => {
    var xy = [];
    var cols = [];

    // cosx
    for (var i = 0; i < 50; i++) {
      var x = Math.random() * Math.PI - Math.PI / 2;
      var y = Math.cos(x) + Math.random() * 0.3;
      x = x / Math.PI;
      xy.push([x, y]);
      cols.push(colorList[0]);
    }

    // sinx
    for (var i = 0; i < 50; i++) {
      var x = Math.random() * Math.PI;
      var y = -Math.sin(x) + Math.random() * 0.3;
      x = x / Math.PI;
      xy.push([x, y]);
      cols.push(colorList[0]);
    }
    return {
      xy: xy,
      cols: cols
    };
  }
};

},{"../d3.min.js":4}],6:[function(require,module,exports){
const regl = require("regl")();
const d3 = require("../d3.min.js");
const {
  Pane
} = require("tweakpane");
const TweakpaneLatexPlugin = require("tweakpane-latex");
const {
  funcs,
  colorList
} = require("./funcs.js");
const pane = new Pane({
  title: "DBSCAN Algorithm (Prototype I)"
});
pane.registerPlugin(TweakpaneLatexPlugin);
pane.addBlade({
  view: "latex",
  content: `
The Density-Based Spatial Clustering Algorithm with Noise is a way of finding clusters in data.
It it is density-based so it has a sense of where data is more dense regardless of shape
 while also ignoring outliers.
It also doesn't require us to know the number of clusters before hand like k-means.
`,
  border: false,
  markdown: true
});
const url = new URLSearchParams(window.location.search);
const maxSpeed = 4;
const settings = {
  function: url.get("function") || "circles",
  n: parseInt(url.get("n")) || 100,
  groups: parseInt(url.get("groups")) || 20,
  speed: 0.8 * maxSpeed,
  std: parseFloat(url.get("std")) || 0.1,
  minPoints: parseInt(url.get("minPoints")) || 4,
  epsilon: parseFloat(url.get("epsilon")) || 0.3
};
var optionList = {};
for (let k in funcs) {
  optionList[k] = k;
}
console.log(optionList);
pane.addInput(settings, "function", {
  options: optionList
}).on("change", ev => {
  window.history.replaceState(null, null, '?function=' + ev.value);
  window.location.reload();
});
// pane.addInput(settings, "n", {
//   step: 14,
//   min: 1,
//   max: 200
// }).on("change", (ev) => {
//   window.history.replaceState(null, null, '?n='+ev.value);
//   window.location.reload();
// });
// pane.addInput(settings, "groups", {
//   step: 1,
//   min: settings.n/14,
//   max: settings.n
// }).on("change", (ev) => {
//   window.history.replaceState(null, null, '?groups='+ev.value);
//   window.location.reload();
// });
pane.addInput(settings, "speed", {
  min: 0,
  max: maxSpeed
});
pane.addInput(settings, "std", {
  min: 0.01,
  max: 1
}).on("change", ev => {
  window.history.replaceState(null, null, '?std=' + ev.value);
  window.location.reload();
});
pane.addInput(settings, "minPoints", {
  step: 1,
  min: 1,
  max: 10
}).on("change", ev => {
  window.history.replaceState(null, null, '?minPoints=' + ev.value);
  window.location.reload();
});
pane.addInput(settings, "epsilon", {
  min: 0.01,
  max: 3
}).on("change", ev => {
  window.history.replaceState(null, null, '?epsilon=' + ev.value);
  window.location.reload();
});
const btn = pane.addButton({
  title: 'refresh'
});
btn.on('click', () => {
  window.location.reload();
});
const algorithm = pane.addFolder({
  title: "Algorithm",
  expanded: false
});
algorithm.addBlade({
  view: "latex",
  content: `
1. Find Core Points. Points with $\\geq$ minPts within $\\epsilon$ distance away
2. Find the connected components of core points on the neighbor graph, ignoring all non-core points.
3. Add non-core points to nearby clusters that are within $\\epsilon$ distance away
`,
  border: false,
  markdown: true
});
const drawPoints = regl({
  depth: {
    enable: false
  },
  blend: {
    enable: true,
    func: {
      srcRGB: 'src alpha',
      srcAlpha: 1,
      dstRGB: 1,
      dstAlpha: 1
    },
    equation: {
      rgb: 'reverse subtract',
      alpha: 'add'
    }
  },
  uniforms: {
    size: (ctx, props) => props.size,
    alpha: regl.prop("alpha"),
    aspect: ctx => {
      var w = ctx.viewportWidth;
      var h = ctx.viewportHeight;
      return w / h > 1 ? [h / w, 1] : [1, w / h];
    }
  },
  attributes: {
    xy: regl.prop("xy"),
    color: regl.prop("color")
  },
  primitive: "points",
  count: (ctx, props) => {
    return props.xy.length;
  },
  vert: `
  precision mediump float;
  attribute vec2 xy;
  attribute vec3 color;

  uniform vec2 aspect;
  uniform float size;

  varying vec3 col;

  void main() {
    col = color;
    gl_Position = vec4(xy * aspect, 0, 1);
    gl_PointSize = size;
  }`,
  frag: `
  precision mediump float;
  uniform float size;
  uniform float alpha;
  varying vec3 col;

  void main() {
    vec2 uv = gl_PointCoord - 0.5;
    float r = length(uv) * size * 2.0;
    gl_FragColor = vec4(col, alpha * smoothstep(size, size - 2.0, r));
  }
  `
});
window.addEventListener("resize", function (e) {
  iteration = 0;
});
let iteration = 0;
var {
  xy,
  cols
} = funcs[settings.function](settings);
let lastFrame = 0;
var toCheck = xy.map(e => e);
function findCorePoints() {
  // highlight the core points
  var corePoints = xy.map(_ => 0);
  for (var i = 0; i < xy.length; i++) {
    for (var j = i + 1; j < xy.length; j++) {
      var dist = Math.sqrt(Math.pow(xy[i][0] - xy[j][0], 2) + Math.pow(xy[i][1] - xy[j][1], 2));
      if (dist < settings.epsilon) {
        corePoints[i]++;
        corePoints[j]++;
      }
    }
  }
  var returnVal = [];
  for (var i = 0; i < corePoints.length; i++) {
    if (corePoints[i] >= settings.minPoints) {
      returnVal.push(i);
    }
  }
  return returnVal;
}
var corePoints = findCorePoints();
var clusters = [[]];
var currentCluster = 0;
var toCheck = [corePoints[0]];
var iterateCorepoints = true;
regl.frame(context => {
  if (context.time - lastFrame < maxSpeed - settings.speed) {
    return;
  }

  // iterate corepoints. add them to cluster.
  // don't worry about performance right now
  if (iterateCorepoints) {
    // next closest corePoint;
    // very low performance, might need to change later.
    var nextToCheck = [];
    var nonCores = [];
    for (var j = 0; j < toCheck.length; j++) {
      for (var i = 0; i < xy.length; i++) {
        var c = xy[toCheck[j]];
        var dist = Math.sqrt(Math.pow(c[0] - xy[i][0], 2) + Math.pow(c[1] - xy[i][1], 2));
        if (dist < settings.epsilon) {
          if (corePoints.includes(i) && !clusters[currentCluster].includes(i) && !nextToCheck.includes(i)) {
            nextToCheck.push(i);
          } else if (!clusters[currentCluster].includes(i) && !nextToCheck.includes(i)) {
            nonCores.push(i);
          }
        }
      }
    }

    // next time around check all the neighbors.
    // this time add these neighbors to our cluster.
    toCheck = nextToCheck;
    clusters[currentCluster] = clusters[currentCluster].concat(toCheck);
    clusters[currentCluster] = clusters[currentCluster].concat(nonCores);

    // if nothing can be added to previous cluster
    // start at next corepoint
    if (toCheck.length === 0) {
      currentCluster++;
      clusters[currentCluster] = [];
      toCheck = [corePoints[0]];
    }

    // remove toCheck from corePoints.
    corePoints = corePoints.filter(e => !toCheck.includes(e));
    if (corePoints.length == 0) {
      iterateCorepoints = false;
    }
  } else {
    console.log("done");
  }
  regl.clear({
    color: [1, 1, 1, 1]
  });
  drawPoints({
    xy: xy,
    color: cols,
    size: 10,
    alpha: 0.6
  });
  var shellsXY = [];
  var colorsXY = [];
  for (var i = 0; i < clusters.length; i++) {
    for (var j = 0; j < clusters[i].length; j++) {
      var pointInd = clusters[i][j];
      shellsXY.push(xy[pointInd]);
      colorsXY.push(colorList[i + 1]);
    }
  }
  drawPoints({
    xy: shellsXY,
    color: colorsXY,
    size: settings.epsilon * 100,
    alpha: 0.3
  });
  iteration++;
  lastFrame = context.time;
});

},{"../d3.min.js":4,"./funcs.js":5,"regl":1,"tweakpane":3,"tweakpane-latex":2}]},{},[6]);
